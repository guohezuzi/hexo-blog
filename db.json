{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/diaspora/source/css/diaspora.css","path":"css/diaspora.css","modified":0,"renderable":1},{"_id":"themes/diaspora/source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":1},{"_id":"themes/diaspora/source/img/logo.png","path":"img/logo.png","modified":0,"renderable":1},{"_id":"themes/diaspora/source/js/diaspora.js","path":"js/diaspora.js","modified":0,"renderable":1},{"_id":"themes/diaspora/source/js/plugin.js","path":"js/plugin.js","modified":0,"renderable":1},{"_id":"themes/diaspora/source/photoswipe/photoswipe-ui-default.js","path":"photoswipe/photoswipe-ui-default.js","modified":0,"renderable":1},{"_id":"themes/diaspora/source/photoswipe/photoswipe-ui-default.min.js","path":"photoswipe/photoswipe-ui-default.min.js","modified":0,"renderable":1},{"_id":"themes/diaspora/source/photoswipe/photoswipe.css","path":"photoswipe/photoswipe.css","modified":0,"renderable":1},{"_id":"themes/diaspora/source/photoswipe/photoswipe.min.js","path":"photoswipe/photoswipe.min.js","modified":0,"renderable":1},{"_id":"themes/diaspora/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/diaspora/source/photoswipe/photoswipe.js","path":"photoswipe/photoswipe.js","modified":0,"renderable":1},{"_id":"themes/diaspora/source/img/cover.jpg","path":"img/cover.jpg","modified":0,"renderable":1},{"_id":"themes/diaspora/source/img/welcome-cover.jpg","path":"img/welcome-cover.jpg","modified":0,"renderable":1},{"_id":"themes/diaspora/source/photoswipe/default-skin/default-skin.css","path":"photoswipe/default-skin/default-skin.css","modified":0,"renderable":1},{"_id":"themes/diaspora/source/photoswipe/default-skin/default-skin.png","path":"photoswipe/default-skin/default-skin.png","modified":0,"renderable":1},{"_id":"themes/diaspora/source/photoswipe/default-skin/default-skin.svg","path":"photoswipe/default-skin/default-skin.svg","modified":0,"renderable":1},{"_id":"themes/diaspora/source/photoswipe/default-skin/preloader.gif","path":"photoswipe/default-skin/preloader.gif","modified":0,"renderable":1}],"Cache":[{"_id":"themes/diaspora/.gitignore","hash":"711861c1bdc49a4d5c6704a22546dcafc31d4730","modified":1573630557177},{"_id":"themes/diaspora/LICENSE","hash":"63175a16773044bed84e1778009a54ad03dd5520","modified":1573630557177},{"_id":"themes/diaspora/README.md","hash":"c2118504a024e7eade2ad2a0cc293db8d3eb63fa","modified":1573630557177},{"_id":"themes/diaspora/_config.yml","hash":"b9f2b6b352f51a7abf9f6faa9eb12d52e4b4c894","modified":1573630557177},{"_id":"source/_posts/Arch填坑之路.md","hash":"555c6184606dc45c6854b0a6c7b0ae51be2d3c32","modified":1573639887891},{"_id":"source/_posts/Docker disable autostart.md","hash":"5a4b439914f30bfa1f41dc5339bafd9143deec55","modified":1573639851463},{"_id":"source/_posts/H5表单的那些事.md","hash":"231fb2985349517f22c8cd5616f412cc6d276996","modified":1573639851463},{"_id":"source/_posts/Java static加载机制.md","hash":"9b695f908546600c2cfdadd27772606891d19811","modified":1573639851463},{"_id":"source/_posts/Java作用域访问权限.md","hash":"fbe3d9c7fbd51b88f063147e44efae85ea5d991d","modified":1573639851463},{"_id":"source/_posts/Java多线程-Thread类详解.md","hash":"bc0b87d4a27cc311a1d05b8fbd12c22708bae8ae","modified":1573639851463},{"_id":"source/_posts/Java多线程面经清单.md","hash":"4687f2310a67c6482977cb7ab3e9caa801433b19","modified":1573639851463},{"_id":"source/_posts/Logback xml配置以及springboot配置.md","hash":"07deda4b1e83477c9078ccf9604e221976c726cc","modified":1573639851463},{"_id":"source/_posts/MySQL主键唯一ID生成策略.md","hash":"550e0be7bb11d46b5e3d0f32b9be1babec2989cb","modified":1573639851463},{"_id":"source/_posts/Mysql 语句执行顺序.md","hash":"27c369e698e29800fd44c3d42142abcbacb4d6c7","modified":1573639851463},{"_id":"source/_posts/Linux使用上踩过的坑.md","hash":"1e92bc7d6348add5c6b148b2593f1ddabf2006da","modified":1573639851463},{"_id":"source/_posts/Mysql数据库优化.md","hash":"6b6b14dd0eaea6ea8ba1ec3f929397e1fbba8549","modified":1573639851463},{"_id":"source/_posts/Spring XSS处理.md","hash":"624d22b3aaf4c3f3a82bac2792cc2f99e9eecc78","modified":1573639851463},{"_id":"source/_posts/Ubuntu操作系统下的 Arch Linux安装.md","hash":"9c31f4c08b0531ee390d50c848feba5887b386f1","modified":1573639851463},{"_id":"source/_posts/auto-upload.sh","hash":"f5dbfb28761a5e7132d893cbc38c06537a2ef43d","modified":1573633637908},{"_id":"source/_posts/let's encrypt 证书dns验证安装.md","hash":"59a06c6dae7667b05e973879236fe1e0ec62d31f","modified":1573639851463},{"_id":"source/_posts/mybatis 查询无记录的返回值.md","hash":"ada999058c39b64a5a0027d62ff2642e2d1f0201","modified":1573639851463},{"_id":"source/_posts/一些Git命令.md","hash":"9a28f6b698355c25360114f361b93594e2e53975","modified":1573639851463},{"_id":"source/_posts/事务机制详解.md","hash":"ba7724efef2c0cb96ddedad411626f71c52b3589","modified":1573639851463},{"_id":"source/_posts/关于网站建设的一些分享-前端篇.md","hash":"29a6156d13087db92dab90be02759130b4aeb9f5","modified":1573639851463},{"_id":"source/_posts/前端浏览器缓存数据终极解决方案.md","hash":"6ee737efe32bb8f272ea15a8f3e0386b6794d61d","modified":1573639851463},{"_id":"source/_posts/基于vw的移动端适配方案.md","hash":"1abae0eab84243a4c77b08fa152b70421894fd4e","modified":1573639851463},{"_id":"source/_posts/数据库建模解决方案.md","hash":"7f53b162cf231492c4f9f76835c7c30e1e210d71","modified":1573639851463},{"_id":"source/_posts/常见的正则表达式.md","hash":"e6ac1ed47f74aa40f1d78c440e1117460f6ebb39","modified":1573639851463},{"_id":"source/_posts/目前网站的网络安全.md","hash":"10a23288def04405dfa435104389c951bd559b2d","modified":1573639851463},{"_id":"source/_posts/网站建设分享 - 文章页面实现代码高亮.md","hash":"b308280a9e7f659258337744d00628a2576c8561","modified":1573639851463},{"_id":"source/_posts/自制Vue轮子的一些规范.md","hash":"4570cd52b4f5c0e1c7cc38a3b8c35d3ecaeed4b6","modified":1573639851463},{"_id":"source/_posts/记一次Java11切换经历.md","hash":"f9677b70fa20802877011abb6465c3836efd0501","modified":1573640136446},{"_id":"source/_posts/记一次网站后台无法登录后的问题排查.md","hash":"efa84c760ce0d1327e4a6504533dcfc3e8b460f5","modified":1573639851463},{"_id":"themes/diaspora/languages/default.yml","hash":"1b2b75ca9ff3bfeddb596239889b584cdfcecc32","modified":1573630557177},{"_id":"themes/diaspora/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1573630557177},{"_id":"themes/diaspora/languages/it.yml","hash":"6ae71000ed039f56572143ffe90da17b95d1a66f","modified":1573630557177},{"_id":"themes/diaspora/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1573630557177},{"_id":"themes/diaspora/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1573630557177},{"_id":"themes/diaspora/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1573630557177},{"_id":"themes/diaspora/languages/zh-CN.yml","hash":"ccbba6315760755926f5abfe1b98c225a6650581","modified":1573630557177},{"_id":"themes/diaspora/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1573630557177},{"_id":"themes/diaspora/layout/archive.ejs","hash":"e50d2e66e8a66789d6a8ef456979aa05143224ce","modified":1573630557177},{"_id":"themes/diaspora/layout/category.ejs","hash":"920114db892fe39fab097c4f65d8ffc9b2a76b69","modified":1573630557177},{"_id":"themes/diaspora/layout/index.ejs","hash":"7ccb03f40fada2cd74c00554e5b6718508545d71","modified":1573630557177},{"_id":"themes/diaspora/layout/layout.ejs","hash":"bbead31ed8f81cb75b22d6c220793c9ed4ff3e66","modified":1573630557177},{"_id":"themes/diaspora/layout/page.ejs","hash":"c311e177fc5eea6954e313374e73bd690814c91a","modified":1573630557177},{"_id":"themes/diaspora/layout/post.ejs","hash":"e585d8b4680c52dccfc40ffa6b2c5df515bf20d2","modified":1573630557177},{"_id":"themes/diaspora/scripts/page_title.js","hash":"35dbc39e4edd53b20f5433dc0d1708024049186d","modified":1573630557177},{"_id":"themes/diaspora/layout/tag.ejs","hash":"920114db892fe39fab097c4f65d8ffc9b2a76b69","modified":1573630557177},{"_id":"source/_posts/多线程/Java多线程 - Spring中的线程安全.md","hash":"309e217d72f3f544bbb3d09e0385dee010ddb3fe","modified":1573639751267},{"_id":"source/_posts/多线程/Java多线程 - AQS详解.md","hash":"e56971e073d219939ca989c08febe499dca4114d","modified":1573639670475},{"_id":"source/_posts/多线程/Java多线程 - 从JVM角度理解多线程.md","hash":"878fd4c0899a7a6f548d8b0c4abeead3121cb5ae","modified":1573639551543},{"_id":"source/_posts/多线程/Java多线程-单例模式的实现.md","hash":"a02acb423b9e850a6e676c7631321e9efa479d93","modified":1573639751271},{"_id":"source/_posts/多线程/Java多线程 - ThreadLocal详解.md","hash":"46ab95850c8f2e835d422aaa645c6c2e89810d65","modified":1573639751271},{"_id":"source/_posts/多线程/Java多线程 - 锁机制.md","hash":"c45408564001ff6a0bfd186a6ba42b275f0e6448","modified":1573639625227},{"_id":"source/_posts/多线程/Java多线程-线程的使用.md","hash":"23c4385458ac659d7123393695ea178f782a2d07","modified":1573639751271},{"_id":"themes/diaspora/layout/_partial/categories.ejs","hash":"02cf5a962644da311e52fa441d2b300b0c9286a5","modified":1573630557177},{"_id":"themes/diaspora/layout/_partial/head.ejs","hash":"af13f26ebecc228ff8893cf458959aec9ba328d0","modified":1573630557177},{"_id":"themes/diaspora/layout/_partial/google-analytics.ejs","hash":"4806289a1c3de19a1cc4e6242c82cdd429c3bfe8","modified":1573630557177},{"_id":"themes/diaspora/layout/_partial/list.ejs","hash":"8e03499580aa81ec0b4c8316347b4e3839849007","modified":1573630557177},{"_id":"themes/diaspora/layout/_partial/menu.ejs","hash":"e2f1c6944b269760456575fb7fed713fa04a1761","modified":1573630557177},{"_id":"themes/diaspora/layout/_partial/pagination.ejs","hash":"23bf862b3b8a3cd831850504d9b5a24d21b005e7","modified":1573630557177},{"_id":"themes/diaspora/layout/_partial/photoswipe.ejs","hash":"d1d36cf0a2c03ff3c2acbc208fe11cd0afd8b7bd","modified":1573630557177},{"_id":"themes/diaspora/layout/_partial/screen.ejs","hash":"dd52f41ad214020646674df3db50ae87e6e4542b","modified":1573630557177},{"_id":"themes/diaspora/layout/_partial/scripts.ejs","hash":"041a2e405157447b20b5d339596f35a2ec89808c","modified":1573630557177},{"_id":"themes/diaspora/.github/ISSUE_TEMPLATE/issues-template.md","hash":"34869fddae53c69c2648712d2f82fe9cb6e9cb0d","modified":1573630557177},{"_id":"themes/diaspora/layout/_partial/tags.ejs","hash":"16cfcf585417ec279c12d8cfbcf6383bf7f2a8c6","modified":1573630557177},{"_id":"source/_posts/多线程/Java多线程-阻塞队列详解.md","hash":"dc498b584652c15dd8a2ecb1015a95ae4397e303","modified":1573639751271},{"_id":"themes/diaspora/source/css/diaspora.css","hash":"eb7846caab5112cc20c270c4b6a72a824ab123be","modified":1573630557177},{"_id":"themes/diaspora/source/img/favicon.ico","hash":"5a7d36d4908fa9009b4df422007b81ff26ed5208","modified":1573630557177},{"_id":"themes/diaspora/source/img/logo.png","hash":"83d21db60b0b0f9613d22c3e99a8c9dbbc8c0eca","modified":1573630557177},{"_id":"themes/diaspora/source/js/diaspora.js","hash":"559740e9f119855dcd4b94435c8bc532ba7caeb3","modified":1573630557177},{"_id":"themes/diaspora/source/js/plugin.js","hash":"0ac6bf36a9a11ca6fad0af1f20e5705bc326abf4","modified":1573630557177},{"_id":"themes/diaspora/source/photoswipe/photoswipe-ui-default.js","hash":"c844cca2f9a9969a810a0fb534063e008424c936","modified":1573630557177},{"_id":"themes/diaspora/source/photoswipe/photoswipe-ui-default.min.js","hash":"d80b713ca1bab90f27a8af7d8e43563f0fe81860","modified":1573630557177},{"_id":"themes/diaspora/source/photoswipe/photoswipe.css","hash":"a31fa495095783ef5a84ba4dba0bd6f7de3b07ea","modified":1573630557177},{"_id":"themes/diaspora/source/photoswipe/photoswipe.min.js","hash":"791703278e7c576b08b67f18404bae9eb8cebfaf","modified":1573630557177},{"_id":"themes/diaspora/source/js/jquery.min.js","hash":"3f1b0e9e54af1af2db2c8a639530448723462151","modified":1573630557177},{"_id":"themes/diaspora/source/photoswipe/photoswipe.js","hash":"30967789eb2a3e1da9927e71f4f3c5339ebed39a","modified":1573630557177},{"_id":"themes/diaspora/layout/_partial/post/article.ejs","hash":"b2dbaf24cc2fa05be414b97ec5f0315328a8d84c","modified":1573630557177},{"_id":"themes/diaspora/layout/_partial/post/date.ejs","hash":"6f2d1aa9562df343b797d25705f1945323c465fb","modified":1573630557177},{"_id":"themes/diaspora/layout/_partial/post/gitalk.ejs","hash":"7b684b561eca872b8e18e270c07f459ea3634676","modified":1573630557177},{"_id":"themes/diaspora/layout/_partial/post/header.ejs","hash":"36f40f61e49c9ba1a2d1d9cb33ad8d797bd92efe","modified":1573630557177},{"_id":"themes/diaspora/layout/_partial/post/item.ejs","hash":"b7a75aa667765b5c3a16b3b9a71ed38ea0a128a4","modified":1573630557177},{"_id":"themes/diaspora/layout/_partial/post/tag.ejs","hash":"c2b4ce7e1d7eed59f4c333915cd431f008f898e3","modified":1573630557177},{"_id":"themes/diaspora/layout/_partial/post/title.ejs","hash":"33f2a96f17fb1efa354c92aef906d96984abd9ab","modified":1573630557177},{"_id":"themes/diaspora/source/img/cover.jpg","hash":"dc7103d4c4e05650595712b3fa395b89726df32b","modified":1573630557177},{"_id":"themes/diaspora/source/img/welcome-cover.jpg","hash":"c393dfeb52aff20a9921c1f56e2ce127683ab35a","modified":1573630557177},{"_id":"themes/diaspora/source/photoswipe/default-skin/default-skin.css","hash":"5763bd1a8015774f37215359bfcb5edd65d198a6","modified":1573630557177},{"_id":"themes/diaspora/source/photoswipe/default-skin/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1573630557177},{"_id":"themes/diaspora/source/photoswipe/default-skin/default-skin.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1573630557177},{"_id":"themes/diaspora/source/photoswipe/default-skin/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1573630557177},{"_id":"public/2019/10/04/Linux使用上踩过的坑/index.html","hash":"17edf56ef372f99ee1675e69516126a2f550d66b","modified":1573640149477},{"_id":"public/2019/08/30/Java多线程-Thread类详解/index.html","hash":"0aa57e78d998da4f7dcdf59623876b024662bad4","modified":1573640149477},{"_id":"public/2019/06/05/多线程/Java多线程 - 从JVM角度理解多线程/index.html","hash":"42e1a135395554383988b1f868ad7e889ba623a6","modified":1573640149477},{"_id":"public/1999/02/24/Mysql数据库优化/index.html","hash":"d85a7c62da47f093df78758a2e8b3c95f11afaab","modified":1573640149477},{"_id":"public/1999/02/24/Spring XSS处理/index.html","hash":"c15f50cb85dd42598a470bd5efe95e28ace58405","modified":1573640149477},{"_id":"public/1999/02/24/let's encrypt 证书dns验证安装/index.html","hash":"68244381eecbf3590dd32c62f58752bab990a12e","modified":1573640149477},{"_id":"public/1999/02/24/Ubuntu操作系统下的 Arch Linux安装/index.html","hash":"aa156d29b663f490177e3b0db362b0ab3412db05","modified":1573640149478},{"_id":"public/1999/02/24/mybatis 查询无记录的返回值/index.html","hash":"8ca483d70ae38aa8457236e45d4a54e1196d4ea3","modified":1573640149478},{"_id":"public/1999/02/24/一些Git命令/index.html","hash":"67f80d43d277b56372b0f04077cc5dc7d2b0c836","modified":1573640149478},{"_id":"public/1999/02/24/事务机制详解/index.html","hash":"56a7142c92a90ef61488b2c8c4ed6910b7a7b5ff","modified":1573640149478},{"_id":"public/1999/02/24/Docker disable autostart/index.html","hash":"155f1f4bcfb8c85c4c46b06a6e0e26a09aceaec4","modified":1573640149478},{"_id":"public/1999/02/24/基于vw的移动端适配方案/index.html","hash":"f69ad718e2ddbee49dfc341cd80d1f33d4b5683d","modified":1573640149478},{"_id":"public/1999/02/24/前端浏览器缓存数据终极解决方案/index.html","hash":"9e8056eff1c50903905514e5b29ef1d0efda09cd","modified":1573640149478},{"_id":"public/1999/02/24/常见的正则表达式/index.html","hash":"a4e888cd027e0de299f48f8c9942bb2c8037165e","modified":1573640149478},{"_id":"public/1999/02/24/数据库建模解决方案/index.html","hash":"dc347edfb634de633fb7e85553528f7f631637ed","modified":1573640149478},{"_id":"public/1999/02/24/目前网站的网络安全/index.html","hash":"c2ad49d67ca131f580ab9dd2998f17553ee9863f","modified":1573640149478},{"_id":"public/1999/02/24/自制Vue轮子的一些规范/index.html","hash":"49992dcfe6d160826dc3748a6df267e1f2ced917","modified":1573640149478},{"_id":"public/1999/02/24/网站建设分享 - 文章页面实现代码高亮/index.html","hash":"4f70a22a93ef02e31d940d4e4b2b89b8862c3b43","modified":1573640149478},{"_id":"public/1999/02/24/Java static加载机制/index.html","hash":"8dc483f8e898d32a5c74f8e9359e9b96fbb8c1ef","modified":1573640149478},{"_id":"public/1999/02/24/记一次网站后台无法登录后的问题排查/index.html","hash":"0bbfbae5eba4f9a118e630ed0e1f90482c335b8a","modified":1573640149478},{"_id":"public/1999/02/24/Java作用域访问权限/index.html","hash":"0baaa0f62e250635ba2a8eb93aa7c4bfb0bf0d27","modified":1573640149478},{"_id":"public/1999/02/24/Arch填坑之路/index.html","hash":"2e5406772f081f33aa57c94b9180eddff7cfb3fc","modified":1573640149478},{"_id":"public/1999/02/24/Java多线程面经清单/index.html","hash":"d11e40b33d26a3cbda93c1500c7542f22b00e7aa","modified":1573640149478},{"_id":"public/1999/02/24/Logback xml配置以及springboot配置/index.html","hash":"6b31bf2e4a83186a1647f4bbd948b55d979e71c3","modified":1573640149478},{"_id":"public/1999/02/24/MySQL主键唯一ID生成策略/index.html","hash":"5897a78073664aba30b33c46413c4a057b4d984c","modified":1573640149478},{"_id":"public/1999/02/24/Mysql 语句执行顺序/index.html","hash":"03d28ab590c274534c2c5f29ce49075ef63fe5bc","modified":1573640149478},{"_id":"public/1999/02/24/H5表单的那些事/index.html","hash":"56d59bfd4014454caf24ec6ec0e12baa3a4c97ed","modified":1573640149478},{"_id":"public/1999/02/24/关于网站建设的一些分享-前端篇/index.html","hash":"2d4fdf67ff632a07e8ab528339f9c9bb88473e33","modified":1573640149478},{"_id":"public/archives/index.html","hash":"12c12653ec6b7cfd9ddd4fd5f39bebc627b17415","modified":1573640149478},{"_id":"public/archives/page/2/index.html","hash":"e6579972294dad749c4660793312d528c01965ab","modified":1573640149478},{"_id":"public/archives/page/3/index.html","hash":"07a4335067af77db8744a2fb251fb235d21112a0","modified":1573640149479},{"_id":"public/archives/page/4/index.html","hash":"eef958b19903c9cdd4b3436a3d61cfb215d9b805","modified":1573640149479},{"_id":"public/archives/1999/index.html","hash":"d2b39c9b484fe2f2d98bd4acbafc0db9d12c2e6d","modified":1573640149479},{"_id":"public/archives/1999/page/2/index.html","hash":"dca489bb7725e4e1332a00ab4b9a672db5c82c5c","modified":1573640149479},{"_id":"public/archives/1999/page/3/index.html","hash":"cd0823be2392a5f13a0c72eab0f321e780efbe49","modified":1573640149479},{"_id":"public/archives/1999/02/index.html","hash":"9d40a7db0ed717143747d2ee5cd0b2b7ee900ca6","modified":1573640149479},{"_id":"public/archives/1999/02/page/2/index.html","hash":"9768daa5d95f718f714162f3466eb465cd8a518a","modified":1573640149479},{"_id":"public/archives/1999/02/page/3/index.html","hash":"4db8cfb26387929ec0a0d7b15b32a74ce09608c6","modified":1573640149479},{"_id":"public/archives/2019/index.html","hash":"4f76f2a075a24cd4baf9dcda6eb934285b5e004a","modified":1573640149479},{"_id":"public/archives/2019/page/2/index.html","hash":"67712b9d20699b44ef2795efe95ccffb9d7b046f","modified":1573640149479},{"_id":"public/archives/2019/06/index.html","hash":"1050f92363d3640925c49d3012ecc22b9cd16dd3","modified":1573640149479},{"_id":"public/archives/2019/07/index.html","hash":"c2cc2faf8747e2464a89ef8b134830b0d2a62b71","modified":1573640149479},{"_id":"public/archives/2019/08/index.html","hash":"82f5a27bf09fb4782745dadea1a42ac27a7af9f6","modified":1573640149479},{"_id":"public/archives/2019/10/index.html","hash":"cb027983458b2319b3999ff1192dbee357d11725","modified":1573640149479},{"_id":"public/index.html","hash":"5a2ba68d05fb84f3f7c83c48d23c121aa6083b6f","modified":1573640149479},{"_id":"public/page/2/index.html","hash":"5909a6279f110f27204f878d52a8d6db114c2cb2","modified":1573640149479},{"_id":"public/page/3/index.html","hash":"88350222cf650d5193e373a5b1b76ac9d0589443","modified":1573640149479},{"_id":"public/page/4/index.html","hash":"7e515e7fb19cf3eb88434be0162b3e2cca887ba5","modified":1573640149479},{"_id":"public/2019/07/30/记一次Java11切换经历/index.html","hash":"7f7118917a0b8f6585ea329766deaa895769be56","modified":1573640149479},{"_id":"public/2019/06/16/多线程/Java多线程 - ThreadLocal详解/index.html","hash":"eb5efa5557c6de225a04ee34a4c2943d77eced07","modified":1573640149479},{"_id":"public/2019/06/15/多线程/Java多线程 - Spring中的线程安全/index.html","hash":"f12972a57d927b3a6e40d60d6893f96721c17f53","modified":1573640149479},{"_id":"public/2019/06/12/多线程/Java多线程-阻塞队列详解/index.html","hash":"b9a3a3926571808e0f0b61cd3e96ea804281b8ea","modified":1573640149479},{"_id":"public/2019/06/10/多线程/Java多线程-线程的使用/index.html","hash":"c5b2a162b5b84b9556ce5bdd2d7617cc135a827f","modified":1573640149479},{"_id":"public/2019/06/10/多线程/Java多线程 - AQS详解/index.html","hash":"da8970bcc9bf66e2566f2f48f4b128c55575c084","modified":1573640149479},{"_id":"public/2019/06/08/多线程/Java多线程-单例模式的实现/index.html","hash":"9c377f273b584b1399771b16ecc65d2a7caf0cb1","modified":1573640149480},{"_id":"public/2019/06/07/多线程/Java多线程 - 锁机制/index.html","hash":"b1b1558014cba9175802963596a3f693a1607dad","modified":1573640149480},{"_id":"public/img/favicon.ico","hash":"5a7d36d4908fa9009b4df422007b81ff26ed5208","modified":1573640149482},{"_id":"public/img/logo.png","hash":"83d21db60b0b0f9613d22c3e99a8c9dbbc8c0eca","modified":1573640149482},{"_id":"public/photoswipe/default-skin/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1573640149482},{"_id":"public/photoswipe/default-skin/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1573640149482},{"_id":"public/photoswipe/default-skin/default-skin.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1573640149482},{"_id":"public/photoswipe/photoswipe.css","hash":"a31fa495095783ef5a84ba4dba0bd6f7de3b07ea","modified":1573640149487},{"_id":"public/photoswipe/photoswipe-ui-default.min.js","hash":"d80b713ca1bab90f27a8af7d8e43563f0fe81860","modified":1573640149487},{"_id":"public/photoswipe/default-skin/default-skin.css","hash":"5763bd1a8015774f37215359bfcb5edd65d198a6","modified":1573640149487},{"_id":"public/css/diaspora.css","hash":"eb7846caab5112cc20c270c4b6a72a824ab123be","modified":1573640149487},{"_id":"public/js/diaspora.js","hash":"559740e9f119855dcd4b94435c8bc532ba7caeb3","modified":1573640149487},{"_id":"public/js/plugin.js","hash":"0ac6bf36a9a11ca6fad0af1f20e5705bc326abf4","modified":1573640149487},{"_id":"public/photoswipe/photoswipe-ui-default.js","hash":"c844cca2f9a9969a810a0fb534063e008424c936","modified":1573640149487},{"_id":"public/photoswipe/photoswipe.min.js","hash":"791703278e7c576b08b67f18404bae9eb8cebfaf","modified":1573640149487},{"_id":"public/photoswipe/photoswipe.js","hash":"30967789eb2a3e1da9927e71f4f3c5339ebed39a","modified":1573640149487},{"_id":"public/js/jquery.min.js","hash":"3f1b0e9e54af1af2db2c8a639530448723462151","modified":1573640149487},{"_id":"public/img/cover.jpg","hash":"dc7103d4c4e05650595712b3fa395b89726df32b","modified":1573640149487},{"_id":"public/img/welcome-cover.jpg","hash":"c393dfeb52aff20a9921c1f56e2ce127683ab35a","modified":1573640149487}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Arch填坑之路","date":"1999-02-23T16:00:00.000Z","_content":"\n# Arch填坑之路\n\n## 亮度调节\n\necho 300>/sys/\n","source":"_posts/Arch填坑之路.md","raw":"---\ntitle: Arch填坑之路\ndate: 1999-2-24\ntags:\n---\n\n# Arch填坑之路\n\n## 亮度调节\n\necho 300>/sys/\n","slug":"Arch填坑之路","published":1,"updated":"2019-11-13T10:11:27.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppx200001w2e5me9hb76","content":"<h1 id=\"Arch填坑之路\"><a href=\"#Arch填坑之路\" class=\"headerlink\" title=\"Arch填坑之路\"></a>Arch填坑之路</h1><h2 id=\"亮度调节\"><a href=\"#亮度调节\" class=\"headerlink\" title=\"亮度调节\"></a>亮度调节</h2><p>echo 300&gt;/sys/</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Arch填坑之路\"><a href=\"#Arch填坑之路\" class=\"headerlink\" title=\"Arch填坑之路\"></a>Arch填坑之路</h1><h2 id=\"亮度调节\"><a href=\"#亮度调节\" class=\"headerlink\" title=\"亮度调节\"></a>亮度调节</h2><p>echo 300&gt;/sys/</p>\n"},{"title":"Docker disable autostart","date":"1999-02-23T16:00:00.000Z","_content":"\n# Docker disable autostart\n\n`docker update --restart=no <Container>`\n","source":"_posts/Docker disable autostart.md","raw":"---\ntitle: Docker disable autostart\ndate: 1999-02-24\ntags:\n---\n\n# Docker disable autostart\n\n`docker update --restart=no <Container>`\n","slug":"Docker disable autostart","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppx500011w2el307if9q","content":"<h1 id=\"Docker-disable-autostart\"><a href=\"#Docker-disable-autostart\" class=\"headerlink\" title=\"Docker disable autostart\"></a>Docker disable autostart</h1><p><code>docker update --restart=no &lt;Container&gt;</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Docker-disable-autostart\"><a href=\"#Docker-disable-autostart\" class=\"headerlink\" title=\"Docker disable autostart\"></a>Docker disable autostart</h1><p><code>docker update --restart=no &lt;Container&gt;</code></p>\n"},{"title":"H5表单的那些事","date":"1999-02-23T16:00:00.000Z","_content":"\n# H5表单的那些事\n\ninput设置了readonly后css:valid将不起作用\n","source":"_posts/H5表单的那些事.md","raw":"---\ntitle: H5表单的那些事\ndate: 1999-02-24\ntags:\n---\n\n# H5表单的那些事\n\ninput设置了readonly后css:valid将不起作用\n","slug":"H5表单的那些事","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppx600021w2e1ud9b8i6","content":"<h1 id=\"H5表单的那些事\"><a href=\"#H5表单的那些事\" class=\"headerlink\" title=\"H5表单的那些事\"></a>H5表单的那些事</h1><p>input设置了readonly后css:valid将不起作用</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"H5表单的那些事\"><a href=\"#H5表单的那些事\" class=\"headerlink\" title=\"H5表单的那些事\"></a>H5表单的那些事</h1><p>input设置了readonly后css:valid将不起作用</p>\n"},{"title":"Java static加载机制","date":"1999-02-23T16:00:00.000Z","_content":"\n# Java static加载机制\n\n## 静态变量\n\n- 在类加载时，将静态存储结构转换为方法区的运行时数据结构\n\n- 在类初始化时，进行初始化\n\n## 静态代码块\n\n- 类初始化时加载\n\n## 静态内部类\n\n- 外部类被加载时内部类并不会立即加载内部类，内部类类加载时进行加载\n\n## 类加载过程\n\n![](https://images2015.cnblogs.com/blog/879896/201604/879896-20160414224549770-60006655.png)\n\n### 类加载时机\n\n类的加载是通过类加载器（Classloader）完成的，它既可以是饿汉式[eagerly load]（只要有其它类引用了它就加载）加载类，也可以是懒加载[lazy load]（等到类初始化发生的时候才加载）。不过我相信这跟不同的JVM实现有关，然而他又是受JLS保证的（当有静态初始化需求的时候才被加载）。\n\n### 初始化时机\n\n- 使用new关键字实例化对象的时候、读取或设置一个类的静态字段的时候，已经调用一个类的静态方法的时候。\n\n- 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，则需要先触发其初始化。\n\n- 当初始化一个类的时候，如果发现其父类没有被初始化就会先初始化它的父类。\n\n- 当虚拟机启动的时候，用户需要指定一个要执行的主类（就是包含main()方法的那个类），虚拟机会先初始化这个类；\n\n- 使用Jdk1.7动态语言支持的时候的一些情况。\n","source":"_posts/Java static加载机制.md","raw":"---\ntitle: Java static加载机制\ndate: 1999-02-24\ntags:\n---\n\n# Java static加载机制\n\n## 静态变量\n\n- 在类加载时，将静态存储结构转换为方法区的运行时数据结构\n\n- 在类初始化时，进行初始化\n\n## 静态代码块\n\n- 类初始化时加载\n\n## 静态内部类\n\n- 外部类被加载时内部类并不会立即加载内部类，内部类类加载时进行加载\n\n## 类加载过程\n\n![](https://images2015.cnblogs.com/blog/879896/201604/879896-20160414224549770-60006655.png)\n\n### 类加载时机\n\n类的加载是通过类加载器（Classloader）完成的，它既可以是饿汉式[eagerly load]（只要有其它类引用了它就加载）加载类，也可以是懒加载[lazy load]（等到类初始化发生的时候才加载）。不过我相信这跟不同的JVM实现有关，然而他又是受JLS保证的（当有静态初始化需求的时候才被加载）。\n\n### 初始化时机\n\n- 使用new关键字实例化对象的时候、读取或设置一个类的静态字段的时候，已经调用一个类的静态方法的时候。\n\n- 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，则需要先触发其初始化。\n\n- 当初始化一个类的时候，如果发现其父类没有被初始化就会先初始化它的父类。\n\n- 当虚拟机启动的时候，用户需要指定一个要执行的主类（就是包含main()方法的那个类），虚拟机会先初始化这个类；\n\n- 使用Jdk1.7动态语言支持的时候的一些情况。\n","slug":"Java static加载机制","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppx700031w2efbd2xr70","content":"<h1 id=\"Java-static加载机制\"><a href=\"#Java-static加载机制\" class=\"headerlink\" title=\"Java static加载机制\"></a>Java static加载机制</h1><h2 id=\"静态变量\"><a href=\"#静态变量\" class=\"headerlink\" title=\"静态变量\"></a>静态变量</h2><ul>\n<li><p>在类加载时，将静态存储结构转换为方法区的运行时数据结构</p>\n</li>\n<li><p>在类初始化时，进行初始化</p>\n</li>\n</ul>\n<h2 id=\"静态代码块\"><a href=\"#静态代码块\" class=\"headerlink\" title=\"静态代码块\"></a>静态代码块</h2><ul>\n<li>类初始化时加载</li>\n</ul>\n<h2 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h2><ul>\n<li>外部类被加载时内部类并不会立即加载内部类，内部类类加载时进行加载</li>\n</ul>\n<h2 id=\"类加载过程\"><a href=\"#类加载过程\" class=\"headerlink\" title=\"类加载过程\"></a>类加载过程</h2><p><img src=\"https://images2015.cnblogs.com/blog/879896/201604/879896-20160414224549770-60006655.png\" alt></p>\n<h3 id=\"类加载时机\"><a href=\"#类加载时机\" class=\"headerlink\" title=\"类加载时机\"></a>类加载时机</h3><p>类的加载是通过类加载器（Classloader）完成的，它既可以是饿汉式[eagerly load]（只要有其它类引用了它就加载）加载类，也可以是懒加载[lazy load]（等到类初始化发生的时候才加载）。不过我相信这跟不同的JVM实现有关，然而他又是受JLS保证的（当有静态初始化需求的时候才被加载）。</p>\n<h3 id=\"初始化时机\"><a href=\"#初始化时机\" class=\"headerlink\" title=\"初始化时机\"></a>初始化时机</h3><ul>\n<li><p>使用new关键字实例化对象的时候、读取或设置一个类的静态字段的时候，已经调用一个类的静态方法的时候。</p>\n</li>\n<li><p>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，则需要先触发其初始化。</p>\n</li>\n<li><p>当初始化一个类的时候，如果发现其父类没有被初始化就会先初始化它的父类。</p>\n</li>\n<li><p>当虚拟机启动的时候，用户需要指定一个要执行的主类（就是包含main()方法的那个类），虚拟机会先初始化这个类；</p>\n</li>\n<li><p>使用Jdk1.7动态语言支持的时候的一些情况。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java-static加载机制\"><a href=\"#Java-static加载机制\" class=\"headerlink\" title=\"Java static加载机制\"></a>Java static加载机制</h1><h2 id=\"静态变量\"><a href=\"#静态变量\" class=\"headerlink\" title=\"静态变量\"></a>静态变量</h2><ul>\n<li><p>在类加载时，将静态存储结构转换为方法区的运行时数据结构</p>\n</li>\n<li><p>在类初始化时，进行初始化</p>\n</li>\n</ul>\n<h2 id=\"静态代码块\"><a href=\"#静态代码块\" class=\"headerlink\" title=\"静态代码块\"></a>静态代码块</h2><ul>\n<li>类初始化时加载</li>\n</ul>\n<h2 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h2><ul>\n<li>外部类被加载时内部类并不会立即加载内部类，内部类类加载时进行加载</li>\n</ul>\n<h2 id=\"类加载过程\"><a href=\"#类加载过程\" class=\"headerlink\" title=\"类加载过程\"></a>类加载过程</h2><p><img src=\"https://images2015.cnblogs.com/blog/879896/201604/879896-20160414224549770-60006655.png\" alt></p>\n<h3 id=\"类加载时机\"><a href=\"#类加载时机\" class=\"headerlink\" title=\"类加载时机\"></a>类加载时机</h3><p>类的加载是通过类加载器（Classloader）完成的，它既可以是饿汉式[eagerly load]（只要有其它类引用了它就加载）加载类，也可以是懒加载[lazy load]（等到类初始化发生的时候才加载）。不过我相信这跟不同的JVM实现有关，然而他又是受JLS保证的（当有静态初始化需求的时候才被加载）。</p>\n<h3 id=\"初始化时机\"><a href=\"#初始化时机\" class=\"headerlink\" title=\"初始化时机\"></a>初始化时机</h3><ul>\n<li><p>使用new关键字实例化对象的时候、读取或设置一个类的静态字段的时候，已经调用一个类的静态方法的时候。</p>\n</li>\n<li><p>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，则需要先触发其初始化。</p>\n</li>\n<li><p>当初始化一个类的时候，如果发现其父类没有被初始化就会先初始化它的父类。</p>\n</li>\n<li><p>当虚拟机启动的时候，用户需要指定一个要执行的主类（就是包含main()方法的那个类），虚拟机会先初始化这个类；</p>\n</li>\n<li><p>使用Jdk1.7动态语言支持的时候的一些情况。</p>\n</li>\n</ul>\n"},{"title":"Java作用域访问权限","date":"1999-02-23T16:00:00.000Z","_content":"\n# Java作用域访问权限\n\n不写的时候就是默认\n\n| 作用域       | 当前类                | 同一包                | 子类                 | 其他包                |\n| --------- | ------------------ | ------------------ | ------------------ | ------------------ |\n| public    | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: |\n| protected | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: |                    |\n| default   | :heavy_check_mark: | :heavy_check_mark: |                    |                    |\n| private   | :heavy_check_mark: |                    |                    |                    |\n","source":"_posts/Java作用域访问权限.md","raw":"---\ntitle: Java作用域访问权限\ndate: 1999-02-24\ntags:\n---\n\n# Java作用域访问权限\n\n不写的时候就是默认\n\n| 作用域       | 当前类                | 同一包                | 子类                 | 其他包                |\n| --------- | ------------------ | ------------------ | ------------------ | ------------------ |\n| public    | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: |\n| protected | :heavy_check_mark: | :heavy_check_mark: | :heavy_check_mark: |                    |\n| default   | :heavy_check_mark: | :heavy_check_mark: |                    |                    |\n| private   | :heavy_check_mark: |                    |                    |                    |\n","slug":"Java作用域访问权限","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppx800041w2ew0wipw91","content":"<h1 id=\"Java作用域访问权限\"><a href=\"#Java作用域访问权限\" class=\"headerlink\" title=\"Java作用域访问权限\"></a>Java作用域访问权限</h1><p>不写的时候就是默认</p>\n<table>\n<thead>\n<tr>\n<th>作用域</th>\n<th>当前类</th>\n<th>同一包</th>\n<th>子类</th>\n<th>其他包</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public</td>\n<td>:heavy_check_mark:</td>\n<td>:heavy_check_mark:</td>\n<td>:heavy_check_mark:</td>\n<td>:heavy_check_mark:</td>\n</tr>\n<tr>\n<td>protected</td>\n<td>:heavy_check_mark:</td>\n<td>:heavy_check_mark:</td>\n<td>:heavy_check_mark:</td>\n<td></td>\n</tr>\n<tr>\n<td>default</td>\n<td>:heavy_check_mark:</td>\n<td>:heavy_check_mark:</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>private</td>\n<td>:heavy_check_mark:</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java作用域访问权限\"><a href=\"#Java作用域访问权限\" class=\"headerlink\" title=\"Java作用域访问权限\"></a>Java作用域访问权限</h1><p>不写的时候就是默认</p>\n<table>\n<thead>\n<tr>\n<th>作用域</th>\n<th>当前类</th>\n<th>同一包</th>\n<th>子类</th>\n<th>其他包</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>public</td>\n<td>:heavy_check_mark:</td>\n<td>:heavy_check_mark:</td>\n<td>:heavy_check_mark:</td>\n<td>:heavy_check_mark:</td>\n</tr>\n<tr>\n<td>protected</td>\n<td>:heavy_check_mark:</td>\n<td>:heavy_check_mark:</td>\n<td>:heavy_check_mark:</td>\n<td></td>\n</tr>\n<tr>\n<td>default</td>\n<td>:heavy_check_mark:</td>\n<td>:heavy_check_mark:</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>private</td>\n<td>:heavy_check_mark:</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n"},{"title":"Java多线程-Thread类详解","date":"2019-08-29T16:00:00.000Z","_content":"\n# Java多线程-Thread类详解\n\n## 实例方法\n\n2. 对线程对象的一些局部变量的get/set方法，id、name、priority...\n\n3. 线程对象的一些状态信息，getState()、isAlive()、isDaemon()...\n\n## 静态方法\n\n### yield()方法\n\nA hint to the scheduler that the current thread is willing to yield its current use of a processor. The scheduler is free to ignore this hint.\nYield is a heuristic attempt to improve relative progression between threads that would otherwise over-utilise a CPU. Its use should be combined with detailed profiling and benchmarking to ensure that it actually has the desired effect.\nIt is rarely appropriate to use this method. It may be useful for debugging or testing purposes, where it may help to reproduce bugs due to race conditions. It may also be useful when designing concurrency control constructs such as the ones in the java.util.concurrent.locks package.\n\n向调度程序提示当前线程是否愿意让度其当前使用的处理器。 调度程序可以忽略此提示。\nYield是一种启发式尝试，用于改善线程之间的相对进展，否则会过度利用CPU。 它的使用应与详细的分析和基准测试相结合，以确保它实际上具有所需的效果。\n使用这种方法很少是合适的。 它可能对调试或测试目的很有用，它可能有助于重现因竞争条件而产生的错误。 在设计并发控制结构（例如java.util.concurrent.locks包中的结构）时，它也可能很有用。\n\n### sleep()方法\n\nCauses the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds, subject to the precision and accuracy of system timers and schedulers. The thread does not lose ownership of any monitors.\n\n导致当前正在执行的线程休眠（暂时停止执行）指定的毫秒数，具体取决于系统计时器和调度程序的精度和准确性。 该线程不会失去任何监视器的所有权(比如对一个资源的锁)\n\n### interrupt()方法\n\nInterrupts this thread.\nUnless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.\nIf this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.\nIf this thread is blocked in an I/O operation upon an InterruptibleChannel then the channel will be closed, the thread's interrupt status will be set, and the thread will receive a java.nio.channels.ClosedByInterruptException.\nIf this thread is blocked in a java.nio.channels.Selector then the thread's interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector's wakeup method were invoked.\nIf none of the previous conditions hold then this thread's interrupt status will be set.\nInterrupting a thread that is not alive need not have any effect.\n\n中断当前线程，如果当前线程遇到当前线程正在中断，或者遇到wait()、join()、sleep()阻塞或IO阻塞时会报不同异常。\n\n## 其他\n\n### wait()方法\n\n它是object类的方法，wait()方法需要和notify()及notifyAll()两个方法一起使用，这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized语句块内使用，也就是说，调用wait()，notify()和notifyAll()的任务在调用这些方法前必须拥有对象的锁。注意，它们都是Object类的方法，而不是Thread类的方法。\n　　wait()方法与sleep()方法的不同之处在于，wait()方法会释放对象的“锁标志”。当调用某一对象的wait()方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了notify()方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的notifyAll()方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。\n　　除了使用notify()和notifyAll()方法，还可以使用带毫秒参数的wait(long timeout)方法，效果是在延迟timeout毫秒后，被暂停的线程将被恢复到锁标志等待池。\n　　此外，wait()，notify()及notifyAll()只能在synchronized语句中使用，但是如果使用的是ReenTrantLock实现同步，该如何达到这三个方法的效果呢？解决方法是使用ReenTrantLock.newCondition()获取一个Condition类对象，然后Condition的await()，signal()以及signalAll()分别对应上面的三个方法。\n\n## 参考\n\n[sleep()，wait()，yield()和join()方法的区别](https://blog.csdn.net/xiangwanpeng/article/details/54972952)\n\n\n","source":"_posts/Java多线程-Thread类详解.md","raw":"---\ntitle: Java多线程-Thread类详解\ndate: 2019-08-30\ntags:\n---\n\n# Java多线程-Thread类详解\n\n## 实例方法\n\n2. 对线程对象的一些局部变量的get/set方法，id、name、priority...\n\n3. 线程对象的一些状态信息，getState()、isAlive()、isDaemon()...\n\n## 静态方法\n\n### yield()方法\n\nA hint to the scheduler that the current thread is willing to yield its current use of a processor. The scheduler is free to ignore this hint.\nYield is a heuristic attempt to improve relative progression between threads that would otherwise over-utilise a CPU. Its use should be combined with detailed profiling and benchmarking to ensure that it actually has the desired effect.\nIt is rarely appropriate to use this method. It may be useful for debugging or testing purposes, where it may help to reproduce bugs due to race conditions. It may also be useful when designing concurrency control constructs such as the ones in the java.util.concurrent.locks package.\n\n向调度程序提示当前线程是否愿意让度其当前使用的处理器。 调度程序可以忽略此提示。\nYield是一种启发式尝试，用于改善线程之间的相对进展，否则会过度利用CPU。 它的使用应与详细的分析和基准测试相结合，以确保它实际上具有所需的效果。\n使用这种方法很少是合适的。 它可能对调试或测试目的很有用，它可能有助于重现因竞争条件而产生的错误。 在设计并发控制结构（例如java.util.concurrent.locks包中的结构）时，它也可能很有用。\n\n### sleep()方法\n\nCauses the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds, subject to the precision and accuracy of system timers and schedulers. The thread does not lose ownership of any monitors.\n\n导致当前正在执行的线程休眠（暂时停止执行）指定的毫秒数，具体取决于系统计时器和调度程序的精度和准确性。 该线程不会失去任何监视器的所有权(比如对一个资源的锁)\n\n### interrupt()方法\n\nInterrupts this thread.\nUnless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.\nIf this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.\nIf this thread is blocked in an I/O operation upon an InterruptibleChannel then the channel will be closed, the thread's interrupt status will be set, and the thread will receive a java.nio.channels.ClosedByInterruptException.\nIf this thread is blocked in a java.nio.channels.Selector then the thread's interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector's wakeup method were invoked.\nIf none of the previous conditions hold then this thread's interrupt status will be set.\nInterrupting a thread that is not alive need not have any effect.\n\n中断当前线程，如果当前线程遇到当前线程正在中断，或者遇到wait()、join()、sleep()阻塞或IO阻塞时会报不同异常。\n\n## 其他\n\n### wait()方法\n\n它是object类的方法，wait()方法需要和notify()及notifyAll()两个方法一起使用，这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized语句块内使用，也就是说，调用wait()，notify()和notifyAll()的任务在调用这些方法前必须拥有对象的锁。注意，它们都是Object类的方法，而不是Thread类的方法。\n　　wait()方法与sleep()方法的不同之处在于，wait()方法会释放对象的“锁标志”。当调用某一对象的wait()方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了notify()方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的notifyAll()方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。\n　　除了使用notify()和notifyAll()方法，还可以使用带毫秒参数的wait(long timeout)方法，效果是在延迟timeout毫秒后，被暂停的线程将被恢复到锁标志等待池。\n　　此外，wait()，notify()及notifyAll()只能在synchronized语句中使用，但是如果使用的是ReenTrantLock实现同步，该如何达到这三个方法的效果呢？解决方法是使用ReenTrantLock.newCondition()获取一个Condition类对象，然后Condition的await()，signal()以及signalAll()分别对应上面的三个方法。\n\n## 参考\n\n[sleep()，wait()，yield()和join()方法的区别](https://blog.csdn.net/xiangwanpeng/article/details/54972952)\n\n\n","slug":"Java多线程-Thread类详解","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppx900051w2ek9o94ah3","content":"<h1 id=\"Java多线程-Thread类详解\"><a href=\"#Java多线程-Thread类详解\" class=\"headerlink\" title=\"Java多线程-Thread类详解\"></a>Java多线程-Thread类详解</h1><h2 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h2><ol start=\"2\">\n<li><p>对线程对象的一些局部变量的get/set方法，id、name、priority…</p>\n</li>\n<li><p>线程对象的一些状态信息，getState()、isAlive()、isDaemon()…</p>\n</li>\n</ol>\n<h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><h3 id=\"yield-方法\"><a href=\"#yield-方法\" class=\"headerlink\" title=\"yield()方法\"></a>yield()方法</h3><p>A hint to the scheduler that the current thread is willing to yield its current use of a processor. The scheduler is free to ignore this hint.<br>Yield is a heuristic attempt to improve relative progression between threads that would otherwise over-utilise a CPU. Its use should be combined with detailed profiling and benchmarking to ensure that it actually has the desired effect.<br>It is rarely appropriate to use this method. It may be useful for debugging or testing purposes, where it may help to reproduce bugs due to race conditions. It may also be useful when designing concurrency control constructs such as the ones in the java.util.concurrent.locks package.</p>\n<p>向调度程序提示当前线程是否愿意让度其当前使用的处理器。 调度程序可以忽略此提示。<br>Yield是一种启发式尝试，用于改善线程之间的相对进展，否则会过度利用CPU。 它的使用应与详细的分析和基准测试相结合，以确保它实际上具有所需的效果。<br>使用这种方法很少是合适的。 它可能对调试或测试目的很有用，它可能有助于重现因竞争条件而产生的错误。 在设计并发控制结构（例如java.util.concurrent.locks包中的结构）时，它也可能很有用。</p>\n<h3 id=\"sleep-方法\"><a href=\"#sleep-方法\" class=\"headerlink\" title=\"sleep()方法\"></a>sleep()方法</h3><p>Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds, subject to the precision and accuracy of system timers and schedulers. The thread does not lose ownership of any monitors.</p>\n<p>导致当前正在执行的线程休眠（暂时停止执行）指定的毫秒数，具体取决于系统计时器和调度程序的精度和准确性。 该线程不会失去任何监视器的所有权(比如对一个资源的锁)</p>\n<h3 id=\"interrupt-方法\"><a href=\"#interrupt-方法\" class=\"headerlink\" title=\"interrupt()方法\"></a>interrupt()方法</h3><p>Interrupts this thread.<br>Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.<br>If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.<br>If this thread is blocked in an I/O operation upon an InterruptibleChannel then the channel will be closed, the thread’s interrupt status will be set, and the thread will receive a java.nio.channels.ClosedByInterruptException.<br>If this thread is blocked in a java.nio.channels.Selector then the thread’s interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector’s wakeup method were invoked.<br>If none of the previous conditions hold then this thread’s interrupt status will be set.<br>Interrupting a thread that is not alive need not have any effect.</p>\n<p>中断当前线程，如果当前线程遇到当前线程正在中断，或者遇到wait()、join()、sleep()阻塞或IO阻塞时会报不同异常。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"wait-方法\"><a href=\"#wait-方法\" class=\"headerlink\" title=\"wait()方法\"></a>wait()方法</h3><p>它是object类的方法，wait()方法需要和notify()及notifyAll()两个方法一起使用，这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized语句块内使用，也就是说，调用wait()，notify()和notifyAll()的任务在调用这些方法前必须拥有对象的锁。注意，它们都是Object类的方法，而不是Thread类的方法。<br>　　wait()方法与sleep()方法的不同之处在于，wait()方法会释放对象的“锁标志”。当调用某一对象的wait()方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了notify()方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的notifyAll()方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。<br>　　除了使用notify()和notifyAll()方法，还可以使用带毫秒参数的wait(long timeout)方法，效果是在延迟timeout毫秒后，被暂停的线程将被恢复到锁标志等待池。<br>　　此外，wait()，notify()及notifyAll()只能在synchronized语句中使用，但是如果使用的是ReenTrantLock实现同步，该如何达到这三个方法的效果呢？解决方法是使用ReenTrantLock.newCondition()获取一个Condition类对象，然后Condition的await()，signal()以及signalAll()分别对应上面的三个方法。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/xiangwanpeng/article/details/54972952\" target=\"_blank\" rel=\"noopener\">sleep()，wait()，yield()和join()方法的区别</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java多线程-Thread类详解\"><a href=\"#Java多线程-Thread类详解\" class=\"headerlink\" title=\"Java多线程-Thread类详解\"></a>Java多线程-Thread类详解</h1><h2 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h2><ol start=\"2\">\n<li><p>对线程对象的一些局部变量的get/set方法，id、name、priority…</p>\n</li>\n<li><p>线程对象的一些状态信息，getState()、isAlive()、isDaemon()…</p>\n</li>\n</ol>\n<h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><h3 id=\"yield-方法\"><a href=\"#yield-方法\" class=\"headerlink\" title=\"yield()方法\"></a>yield()方法</h3><p>A hint to the scheduler that the current thread is willing to yield its current use of a processor. The scheduler is free to ignore this hint.<br>Yield is a heuristic attempt to improve relative progression between threads that would otherwise over-utilise a CPU. Its use should be combined with detailed profiling and benchmarking to ensure that it actually has the desired effect.<br>It is rarely appropriate to use this method. It may be useful for debugging or testing purposes, where it may help to reproduce bugs due to race conditions. It may also be useful when designing concurrency control constructs such as the ones in the java.util.concurrent.locks package.</p>\n<p>向调度程序提示当前线程是否愿意让度其当前使用的处理器。 调度程序可以忽略此提示。<br>Yield是一种启发式尝试，用于改善线程之间的相对进展，否则会过度利用CPU。 它的使用应与详细的分析和基准测试相结合，以确保它实际上具有所需的效果。<br>使用这种方法很少是合适的。 它可能对调试或测试目的很有用，它可能有助于重现因竞争条件而产生的错误。 在设计并发控制结构（例如java.util.concurrent.locks包中的结构）时，它也可能很有用。</p>\n<h3 id=\"sleep-方法\"><a href=\"#sleep-方法\" class=\"headerlink\" title=\"sleep()方法\"></a>sleep()方法</h3><p>Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds, subject to the precision and accuracy of system timers and schedulers. The thread does not lose ownership of any monitors.</p>\n<p>导致当前正在执行的线程休眠（暂时停止执行）指定的毫秒数，具体取决于系统计时器和调度程序的精度和准确性。 该线程不会失去任何监视器的所有权(比如对一个资源的锁)</p>\n<h3 id=\"interrupt-方法\"><a href=\"#interrupt-方法\" class=\"headerlink\" title=\"interrupt()方法\"></a>interrupt()方法</h3><p>Interrupts this thread.<br>Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.<br>If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.<br>If this thread is blocked in an I/O operation upon an InterruptibleChannel then the channel will be closed, the thread’s interrupt status will be set, and the thread will receive a java.nio.channels.ClosedByInterruptException.<br>If this thread is blocked in a java.nio.channels.Selector then the thread’s interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector’s wakeup method were invoked.<br>If none of the previous conditions hold then this thread’s interrupt status will be set.<br>Interrupting a thread that is not alive need not have any effect.</p>\n<p>中断当前线程，如果当前线程遇到当前线程正在中断，或者遇到wait()、join()、sleep()阻塞或IO阻塞时会报不同异常。</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"wait-方法\"><a href=\"#wait-方法\" class=\"headerlink\" title=\"wait()方法\"></a>wait()方法</h3><p>它是object类的方法，wait()方法需要和notify()及notifyAll()两个方法一起使用，这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized语句块内使用，也就是说，调用wait()，notify()和notifyAll()的任务在调用这些方法前必须拥有对象的锁。注意，它们都是Object类的方法，而不是Thread类的方法。<br>　　wait()方法与sleep()方法的不同之处在于，wait()方法会释放对象的“锁标志”。当调用某一对象的wait()方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了notify()方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的notifyAll()方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。<br>　　除了使用notify()和notifyAll()方法，还可以使用带毫秒参数的wait(long timeout)方法，效果是在延迟timeout毫秒后，被暂停的线程将被恢复到锁标志等待池。<br>　　此外，wait()，notify()及notifyAll()只能在synchronized语句中使用，但是如果使用的是ReenTrantLock实现同步，该如何达到这三个方法的效果呢？解决方法是使用ReenTrantLock.newCondition()获取一个Condition类对象，然后Condition的await()，signal()以及signalAll()分别对应上面的三个方法。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/xiangwanpeng/article/details/54972952\" target=\"_blank\" rel=\"noopener\">sleep()，wait()，yield()和join()方法的区别</a></p>\n"},{"title":"Java多线程面经清单","date":"1999-02-23T16:00:00.000Z","_content":"\n# Java多线程面经清单\n\n1. ConcurrentHashMap 如何做到高并发的\n\n2. 线程池平常怎么用\n\n3. 多个线程等待到某一节点然后统一放行有几种实现方式?\n\n4. 解释下乐观锁悲观锁\n\n5. 分布式锁有哪些主流实现方式?redis 和 zk 锁有什么区别?\n\n6. ThreadLocal 作用是什么?说下用法\n\n7. A,B 系统转账如何保证分布式数据一致性?\n\n8. 有没有遇到过死锁?\n\n9. A 往 B 转钱,B 往 A 转钱,同时的会死锁吗?如何解决死锁?\n\n10. 高并发的问题有遇到过吗?分布式锁是排他的,如何提升存储效率?\n\n11. ThreadLocal 是怎样的概念?如何实现线程隔离的?基于这个原理有没有更加优化的方式? ​\n\n12. 线程池用 ThreadLocal 有什么问题?有什么思路来让业务方不去关注 ThreadLocal 的 set ​ ThreadLocal 在线程复用的时候值可能不是最新的,需要每次都 set\n","source":"_posts/Java多线程面经清单.md","raw":"---\ntitle: Java多线程面经清单\ndate: 1999-02-24\ntags:\n---\n\n# Java多线程面经清单\n\n1. ConcurrentHashMap 如何做到高并发的\n\n2. 线程池平常怎么用\n\n3. 多个线程等待到某一节点然后统一放行有几种实现方式?\n\n4. 解释下乐观锁悲观锁\n\n5. 分布式锁有哪些主流实现方式?redis 和 zk 锁有什么区别?\n\n6. ThreadLocal 作用是什么?说下用法\n\n7. A,B 系统转账如何保证分布式数据一致性?\n\n8. 有没有遇到过死锁?\n\n9. A 往 B 转钱,B 往 A 转钱,同时的会死锁吗?如何解决死锁?\n\n10. 高并发的问题有遇到过吗?分布式锁是排他的,如何提升存储效率?\n\n11. ThreadLocal 是怎样的概念?如何实现线程隔离的?基于这个原理有没有更加优化的方式? ​\n\n12. 线程池用 ThreadLocal 有什么问题?有什么思路来让业务方不去关注 ThreadLocal 的 set ​ ThreadLocal 在线程复用的时候值可能不是最新的,需要每次都 set\n","slug":"Java多线程面经清单","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppx900061w2e4nflg6oo","content":"<h1 id=\"Java多线程面经清单\"><a href=\"#Java多线程面经清单\" class=\"headerlink\" title=\"Java多线程面经清单\"></a>Java多线程面经清单</h1><ol>\n<li><p>ConcurrentHashMap 如何做到高并发的</p>\n</li>\n<li><p>线程池平常怎么用</p>\n</li>\n<li><p>多个线程等待到某一节点然后统一放行有几种实现方式?</p>\n</li>\n<li><p>解释下乐观锁悲观锁</p>\n</li>\n<li><p>分布式锁有哪些主流实现方式?redis 和 zk 锁有什么区别?</p>\n</li>\n<li><p>ThreadLocal 作用是什么?说下用法</p>\n</li>\n<li><p>A,B 系统转账如何保证分布式数据一致性?</p>\n</li>\n<li><p>有没有遇到过死锁?</p>\n</li>\n<li><p>A 往 B 转钱,B 往 A 转钱,同时的会死锁吗?如何解决死锁?</p>\n</li>\n<li><p>高并发的问题有遇到过吗?分布式锁是排他的,如何提升存储效率?</p>\n</li>\n<li><p>ThreadLocal 是怎样的概念?如何实现线程隔离的?基于这个原理有没有更加优化的方式? ​</p>\n</li>\n<li><p>线程池用 ThreadLocal 有什么问题?有什么思路来让业务方不去关注 ThreadLocal 的 set ​ ThreadLocal 在线程复用的时候值可能不是最新的,需要每次都 set</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java多线程面经清单\"><a href=\"#Java多线程面经清单\" class=\"headerlink\" title=\"Java多线程面经清单\"></a>Java多线程面经清单</h1><ol>\n<li><p>ConcurrentHashMap 如何做到高并发的</p>\n</li>\n<li><p>线程池平常怎么用</p>\n</li>\n<li><p>多个线程等待到某一节点然后统一放行有几种实现方式?</p>\n</li>\n<li><p>解释下乐观锁悲观锁</p>\n</li>\n<li><p>分布式锁有哪些主流实现方式?redis 和 zk 锁有什么区别?</p>\n</li>\n<li><p>ThreadLocal 作用是什么?说下用法</p>\n</li>\n<li><p>A,B 系统转账如何保证分布式数据一致性?</p>\n</li>\n<li><p>有没有遇到过死锁?</p>\n</li>\n<li><p>A 往 B 转钱,B 往 A 转钱,同时的会死锁吗?如何解决死锁?</p>\n</li>\n<li><p>高并发的问题有遇到过吗?分布式锁是排他的,如何提升存储效率?</p>\n</li>\n<li><p>ThreadLocal 是怎样的概念?如何实现线程隔离的?基于这个原理有没有更加优化的方式? ​</p>\n</li>\n<li><p>线程池用 ThreadLocal 有什么问题?有什么思路来让业务方不去关注 ThreadLocal 的 set ​ ThreadLocal 在线程复用的时候值可能不是最新的,需要每次都 set</p>\n</li>\n</ol>\n"},{"title":"Logback xml配置以及springboot配置","date":"1999-02-23T16:00:00.000Z","_content":"\n# Logback xml配置以及springboot配置\n\n## XML标签\n\n- appender(定义日志输出的格式)\n\n- include(包含的其他日志配置)\n\n- springProfile(只针对spring)\n\n- logger(特定的日志对应的水平)\n\n- root(根日志对应的水平)\n\n## Springboot application.xml配置\n\n- logging.config 自定义的日志文件的位置\n\n- logging.pattern.* 不同日志输出的格式\n\n- logging.level 不同日志输出的日志水平\n\n- logging.path 日志的路径\n\n- logging.file.* 日志输出文件的一系列配置\n","source":"_posts/Logback xml配置以及springboot配置.md","raw":"---\ntitle: Logback xml配置以及springboot配置\ndate: 1999-02-24\ntags:\n---\n\n# Logback xml配置以及springboot配置\n\n## XML标签\n\n- appender(定义日志输出的格式)\n\n- include(包含的其他日志配置)\n\n- springProfile(只针对spring)\n\n- logger(特定的日志对应的水平)\n\n- root(根日志对应的水平)\n\n## Springboot application.xml配置\n\n- logging.config 自定义的日志文件的位置\n\n- logging.pattern.* 不同日志输出的格式\n\n- logging.level 不同日志输出的日志水平\n\n- logging.path 日志的路径\n\n- logging.file.* 日志输出文件的一系列配置\n","slug":"Logback xml配置以及springboot配置","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxa00071w2e5tf593sn","content":"<h1 id=\"Logback-xml配置以及springboot配置\"><a href=\"#Logback-xml配置以及springboot配置\" class=\"headerlink\" title=\"Logback xml配置以及springboot配置\"></a>Logback xml配置以及springboot配置</h1><h2 id=\"XML标签\"><a href=\"#XML标签\" class=\"headerlink\" title=\"XML标签\"></a>XML标签</h2><ul>\n<li><p>appender(定义日志输出的格式)</p>\n</li>\n<li><p>include(包含的其他日志配置)</p>\n</li>\n<li><p>springProfile(只针对spring)</p>\n</li>\n<li><p>logger(特定的日志对应的水平)</p>\n</li>\n<li><p>root(根日志对应的水平)</p>\n</li>\n</ul>\n<h2 id=\"Springboot-application-xml配置\"><a href=\"#Springboot-application-xml配置\" class=\"headerlink\" title=\"Springboot application.xml配置\"></a>Springboot application.xml配置</h2><ul>\n<li><p>logging.config 自定义的日志文件的位置</p>\n</li>\n<li><p>logging.pattern.* 不同日志输出的格式</p>\n</li>\n<li><p>logging.level 不同日志输出的日志水平</p>\n</li>\n<li><p>logging.path 日志的路径</p>\n</li>\n<li><p>logging.file.* 日志输出文件的一系列配置</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Logback-xml配置以及springboot配置\"><a href=\"#Logback-xml配置以及springboot配置\" class=\"headerlink\" title=\"Logback xml配置以及springboot配置\"></a>Logback xml配置以及springboot配置</h1><h2 id=\"XML标签\"><a href=\"#XML标签\" class=\"headerlink\" title=\"XML标签\"></a>XML标签</h2><ul>\n<li><p>appender(定义日志输出的格式)</p>\n</li>\n<li><p>include(包含的其他日志配置)</p>\n</li>\n<li><p>springProfile(只针对spring)</p>\n</li>\n<li><p>logger(特定的日志对应的水平)</p>\n</li>\n<li><p>root(根日志对应的水平)</p>\n</li>\n</ul>\n<h2 id=\"Springboot-application-xml配置\"><a href=\"#Springboot-application-xml配置\" class=\"headerlink\" title=\"Springboot application.xml配置\"></a>Springboot application.xml配置</h2><ul>\n<li><p>logging.config 自定义的日志文件的位置</p>\n</li>\n<li><p>logging.pattern.* 不同日志输出的格式</p>\n</li>\n<li><p>logging.level 不同日志输出的日志水平</p>\n</li>\n<li><p>logging.path 日志的路径</p>\n</li>\n<li><p>logging.file.* 日志输出文件的一系列配置</p>\n</li>\n</ul>\n"},{"title":"MySQL主键唯一ID生成策略","date":"1999-02-23T16:00:00.000Z","_content":"\n# MySQL主键唯一ID生成策略\n\n## 主键自增\n\n## UUID\n\n## Sequence ID\n\n## Snowflake\n\n## Redis生成ID\n","source":"_posts/MySQL主键唯一ID生成策略.md","raw":"---\ntitle: MySQL主键唯一ID生成策略\ndate: 1999-02-24\ntags:\n---\n\n# MySQL主键唯一ID生成策略\n\n## 主键自增\n\n## UUID\n\n## Sequence ID\n\n## Snowflake\n\n## Redis生成ID\n","slug":"MySQL主键唯一ID生成策略","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxb00081w2e629kzfrw","content":"<h1 id=\"MySQL主键唯一ID生成策略\"><a href=\"#MySQL主键唯一ID生成策略\" class=\"headerlink\" title=\"MySQL主键唯一ID生成策略\"></a>MySQL主键唯一ID生成策略</h1><h2 id=\"主键自增\"><a href=\"#主键自增\" class=\"headerlink\" title=\"主键自增\"></a>主键自增</h2><h2 id=\"UUID\"><a href=\"#UUID\" class=\"headerlink\" title=\"UUID\"></a>UUID</h2><h2 id=\"Sequence-ID\"><a href=\"#Sequence-ID\" class=\"headerlink\" title=\"Sequence ID\"></a>Sequence ID</h2><h2 id=\"Snowflake\"><a href=\"#Snowflake\" class=\"headerlink\" title=\"Snowflake\"></a>Snowflake</h2><h2 id=\"Redis生成ID\"><a href=\"#Redis生成ID\" class=\"headerlink\" title=\"Redis生成ID\"></a>Redis生成ID</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"MySQL主键唯一ID生成策略\"><a href=\"#MySQL主键唯一ID生成策略\" class=\"headerlink\" title=\"MySQL主键唯一ID生成策略\"></a>MySQL主键唯一ID生成策略</h1><h2 id=\"主键自增\"><a href=\"#主键自增\" class=\"headerlink\" title=\"主键自增\"></a>主键自增</h2><h2 id=\"UUID\"><a href=\"#UUID\" class=\"headerlink\" title=\"UUID\"></a>UUID</h2><h2 id=\"Sequence-ID\"><a href=\"#Sequence-ID\" class=\"headerlink\" title=\"Sequence ID\"></a>Sequence ID</h2><h2 id=\"Snowflake\"><a href=\"#Snowflake\" class=\"headerlink\" title=\"Snowflake\"></a>Snowflake</h2><h2 id=\"Redis生成ID\"><a href=\"#Redis生成ID\" class=\"headerlink\" title=\"Redis生成ID\"></a>Redis生成ID</h2>"},{"title":"Mysql 语句执行顺序","date":"1999-02-23T16:00:00.000Z","_content":"\n# Mysql 语句执行顺序\n\n1. FROM\n2. JOIN\n3. ON\n4. WHERE\n5. GROUP BY\n6. HAVING\n7. SELECT\n8. ORDER BY\n","source":"_posts/Mysql 语句执行顺序.md","raw":"---\ntitle: Mysql 语句执行顺序\ndate: 1999-02-24\ntags:\n---\n\n# Mysql 语句执行顺序\n\n1. FROM\n2. JOIN\n3. ON\n4. WHERE\n5. GROUP BY\n6. HAVING\n7. SELECT\n8. ORDER BY\n","slug":"Mysql 语句执行顺序","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxb00091w2elsr9aqz7","content":"<h1 id=\"Mysql-语句执行顺序\"><a href=\"#Mysql-语句执行顺序\" class=\"headerlink\" title=\"Mysql 语句执行顺序\"></a>Mysql 语句执行顺序</h1><ol>\n<li>FROM</li>\n<li>JOIN</li>\n<li>ON</li>\n<li>WHERE</li>\n<li>GROUP BY</li>\n<li>HAVING</li>\n<li>SELECT</li>\n<li>ORDER BY</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Mysql-语句执行顺序\"><a href=\"#Mysql-语句执行顺序\" class=\"headerlink\" title=\"Mysql 语句执行顺序\"></a>Mysql 语句执行顺序</h1><ol>\n<li>FROM</li>\n<li>JOIN</li>\n<li>ON</li>\n<li>WHERE</li>\n<li>GROUP BY</li>\n<li>HAVING</li>\n<li>SELECT</li>\n<li>ORDER BY</li>\n</ol>\n"},{"title":"Linux使用上踩过的坑","date":"2019-10-03T16:00:00.000Z","_content":"\n# Linux使用上踩过的坑\n\n## 前言\n\n记录我在linux使用上遇到的一些坑，帮助其他人能够更快的发现问题(ps: ctrl+f进行关键词搜素)\n\n## 主要内容\n\n### 开机优化及问题排查\n\n- 使用 systemd-analyze blame 查看各个服务开机耗时，可disable一些不必要的服务\n\n- dmesg查看启动的系统日志，对存在的问题优化\n\n- 设置grub/etc/default/grub文件的GRUB_CMDLINE_LINUX_DEFAULT参数loglevel=0，开机时显示最详细的日志信息\n\n- 如果gdm启动过慢，或许可以通过修改/etc/gdm/custom.conf文件添加\n  \n  [daemon]\n  \n  WaylandEnable=false\n  \n  禁用Wayland使用Xorg服务\n\n### 一些外设的命令行配置\n\n#### wifi\n\n- 一般系统自带命令wpa,参考 [Arch linux wiki](https://wiki.archlinux.org/index.php/WPA_supplicant)\n  \n  1.通过`wpa_passphrase *MYSSID* *passphrase* > /etc/wpa_supplicant/example.conf`生成用户名密码配置文件\n  \n  2.通过`wpa_supplicant -B -i wlp1s0 -c /etc/wpa_supplicant/example.conf`连接wifi\n\n- 通过安装[netctl](https://wiki.archlinux.org/index.php/Netctl)进行连接\n  \n  1.通过仿照目录/etc/netctl/examples/下配置生成配置文件到目录/etc/netctl/下\n  \n  2.通过命令`sudo netctl start home`连接wifi\n\n#### 蓝牙\n\n1.通过`sudo systemctl start bluetooth.service`启动蓝牙服务\n\n2.安装[Bluetooth](https://en.wikipedia.org/wiki/Bluetooth)进行蓝牙控制，参考Bluetooth文档连接蓝牙\n\n#### 硬盘\n\n1.修改[/etc/fstab](https://en.wikipedia.org/wiki/Fstab)，对硬盘进行开机时挂载行为控制,一些常见的配置\n\n- 对于外置硬盘如果插入开机自动挂载`UUID=******** /mnt/disk   ext4    defaults,nofail 0 2 `\n\n2.通过`sudo mount -a`，安装让系统按照/etc/fstab进行挂载\n\n#### 显示器\n\n通过[Xrandr](https://wiki.archlinux.org/index.php/Xrandr)命令进行显示器的连接，一些常用的操作:\n\n1.`xrandr --output HDMI-1 --mode 1920x1080 --pos 1920x0`在显示器右侧添加另一个显示器\n\n2.`xrandr --output HDMI-1 --off`关闭HDMI-1接口的显示器\n\nps:可安装[Arandr](https://christian.amsuess.com/tools/arandr/)进行图像界面的操作\n\n### 音频\n\n1.安装alsa-utils,`sudo pacman install alsa-utils`\n\n2.使用amixer命令控制\n\n- `amixer`显示声卡信息\n\n- `amixer sset Master unmute`解除静音\n\n- `amixer sset Master 80%`调整Master声卡音量为80%\n\n### 其他的一些有用的命令\n\n#### 图片优化\n\n1.安装[ImageMagick](https://wiki.archlinux.org/index.php/ImageMagick)\n\n2.一些常用的命令\n\n- `convert -sample 50%x50%  xxx.jpg  xxx-opt.jpg` 图片压缩,减小图片体积\n\n- `convert  xxx.jpg  xxx.png` 图片转化\n","source":"_posts/Linux使用上踩过的坑.md","raw":"---\ntitle: Linux使用上踩过的坑\ndate: 2019-10-04\ntags:\n---\n\n# Linux使用上踩过的坑\n\n## 前言\n\n记录我在linux使用上遇到的一些坑，帮助其他人能够更快的发现问题(ps: ctrl+f进行关键词搜素)\n\n## 主要内容\n\n### 开机优化及问题排查\n\n- 使用 systemd-analyze blame 查看各个服务开机耗时，可disable一些不必要的服务\n\n- dmesg查看启动的系统日志，对存在的问题优化\n\n- 设置grub/etc/default/grub文件的GRUB_CMDLINE_LINUX_DEFAULT参数loglevel=0，开机时显示最详细的日志信息\n\n- 如果gdm启动过慢，或许可以通过修改/etc/gdm/custom.conf文件添加\n  \n  [daemon]\n  \n  WaylandEnable=false\n  \n  禁用Wayland使用Xorg服务\n\n### 一些外设的命令行配置\n\n#### wifi\n\n- 一般系统自带命令wpa,参考 [Arch linux wiki](https://wiki.archlinux.org/index.php/WPA_supplicant)\n  \n  1.通过`wpa_passphrase *MYSSID* *passphrase* > /etc/wpa_supplicant/example.conf`生成用户名密码配置文件\n  \n  2.通过`wpa_supplicant -B -i wlp1s0 -c /etc/wpa_supplicant/example.conf`连接wifi\n\n- 通过安装[netctl](https://wiki.archlinux.org/index.php/Netctl)进行连接\n  \n  1.通过仿照目录/etc/netctl/examples/下配置生成配置文件到目录/etc/netctl/下\n  \n  2.通过命令`sudo netctl start home`连接wifi\n\n#### 蓝牙\n\n1.通过`sudo systemctl start bluetooth.service`启动蓝牙服务\n\n2.安装[Bluetooth](https://en.wikipedia.org/wiki/Bluetooth)进行蓝牙控制，参考Bluetooth文档连接蓝牙\n\n#### 硬盘\n\n1.修改[/etc/fstab](https://en.wikipedia.org/wiki/Fstab)，对硬盘进行开机时挂载行为控制,一些常见的配置\n\n- 对于外置硬盘如果插入开机自动挂载`UUID=******** /mnt/disk   ext4    defaults,nofail 0 2 `\n\n2.通过`sudo mount -a`，安装让系统按照/etc/fstab进行挂载\n\n#### 显示器\n\n通过[Xrandr](https://wiki.archlinux.org/index.php/Xrandr)命令进行显示器的连接，一些常用的操作:\n\n1.`xrandr --output HDMI-1 --mode 1920x1080 --pos 1920x0`在显示器右侧添加另一个显示器\n\n2.`xrandr --output HDMI-1 --off`关闭HDMI-1接口的显示器\n\nps:可安装[Arandr](https://christian.amsuess.com/tools/arandr/)进行图像界面的操作\n\n### 音频\n\n1.安装alsa-utils,`sudo pacman install alsa-utils`\n\n2.使用amixer命令控制\n\n- `amixer`显示声卡信息\n\n- `amixer sset Master unmute`解除静音\n\n- `amixer sset Master 80%`调整Master声卡音量为80%\n\n### 其他的一些有用的命令\n\n#### 图片优化\n\n1.安装[ImageMagick](https://wiki.archlinux.org/index.php/ImageMagick)\n\n2.一些常用的命令\n\n- `convert -sample 50%x50%  xxx.jpg  xxx-opt.jpg` 图片压缩,减小图片体积\n\n- `convert  xxx.jpg  xxx.png` 图片转化\n","slug":"Linux使用上踩过的坑","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxc000a1w2ezev9jbi2","content":"<h1 id=\"Linux使用上踩过的坑\"><a href=\"#Linux使用上踩过的坑\" class=\"headerlink\" title=\"Linux使用上踩过的坑\"></a>Linux使用上踩过的坑</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>记录我在linux使用上遇到的一些坑，帮助其他人能够更快的发现问题(ps: ctrl+f进行关键词搜素)</p>\n<h2 id=\"主要内容\"><a href=\"#主要内容\" class=\"headerlink\" title=\"主要内容\"></a>主要内容</h2><h3 id=\"开机优化及问题排查\"><a href=\"#开机优化及问题排查\" class=\"headerlink\" title=\"开机优化及问题排查\"></a>开机优化及问题排查</h3><ul>\n<li><p>使用 systemd-analyze blame 查看各个服务开机耗时，可disable一些不必要的服务</p>\n</li>\n<li><p>dmesg查看启动的系统日志，对存在的问题优化</p>\n</li>\n<li><p>设置grub/etc/default/grub文件的GRUB_CMDLINE_LINUX_DEFAULT参数loglevel=0，开机时显示最详细的日志信息</p>\n</li>\n<li><p>如果gdm启动过慢，或许可以通过修改/etc/gdm/custom.conf文件添加</p>\n<p>[daemon]</p>\n<p>WaylandEnable=false</p>\n<p>禁用Wayland使用Xorg服务</p>\n</li>\n</ul>\n<h3 id=\"一些外设的命令行配置\"><a href=\"#一些外设的命令行配置\" class=\"headerlink\" title=\"一些外设的命令行配置\"></a>一些外设的命令行配置</h3><h4 id=\"wifi\"><a href=\"#wifi\" class=\"headerlink\" title=\"wifi\"></a>wifi</h4><ul>\n<li><p>一般系统自带命令wpa,参考 <a href=\"https://wiki.archlinux.org/index.php/WPA_supplicant\" target=\"_blank\" rel=\"noopener\">Arch linux wiki</a></p>\n<p>1.通过<code>wpa_passphrase *MYSSID* *passphrase* &gt; /etc/wpa_supplicant/example.conf</code>生成用户名密码配置文件</p>\n<p>2.通过<code>wpa_supplicant -B -i wlp1s0 -c /etc/wpa_supplicant/example.conf</code>连接wifi</p>\n</li>\n<li><p>通过安装<a href=\"https://wiki.archlinux.org/index.php/Netctl\" target=\"_blank\" rel=\"noopener\">netctl</a>进行连接</p>\n<p>1.通过仿照目录/etc/netctl/examples/下配置生成配置文件到目录/etc/netctl/下</p>\n<p>2.通过命令<code>sudo netctl start home</code>连接wifi</p>\n</li>\n</ul>\n<h4 id=\"蓝牙\"><a href=\"#蓝牙\" class=\"headerlink\" title=\"蓝牙\"></a>蓝牙</h4><p>1.通过<code>sudo systemctl start bluetooth.service</code>启动蓝牙服务</p>\n<p>2.安装<a href=\"https://en.wikipedia.org/wiki/Bluetooth\" target=\"_blank\" rel=\"noopener\">Bluetooth</a>进行蓝牙控制，参考Bluetooth文档连接蓝牙</p>\n<h4 id=\"硬盘\"><a href=\"#硬盘\" class=\"headerlink\" title=\"硬盘\"></a>硬盘</h4><p>1.修改<a href=\"https://en.wikipedia.org/wiki/Fstab\" target=\"_blank\" rel=\"noopener\">/etc/fstab</a>，对硬盘进行开机时挂载行为控制,一些常见的配置</p>\n<ul>\n<li>对于外置硬盘如果插入开机自动挂载<code>UUID=******** /mnt/disk   ext4    defaults,nofail 0 2</code></li>\n</ul>\n<p>2.通过<code>sudo mount -a</code>，安装让系统按照/etc/fstab进行挂载</p>\n<h4 id=\"显示器\"><a href=\"#显示器\" class=\"headerlink\" title=\"显示器\"></a>显示器</h4><p>通过<a href=\"https://wiki.archlinux.org/index.php/Xrandr\" target=\"_blank\" rel=\"noopener\">Xrandr</a>命令进行显示器的连接，一些常用的操作:</p>\n<p>1.<code>xrandr --output HDMI-1 --mode 1920x1080 --pos 1920x0</code>在显示器右侧添加另一个显示器</p>\n<p>2.<code>xrandr --output HDMI-1 --off</code>关闭HDMI-1接口的显示器</p>\n<p>ps:可安装<a href=\"https://christian.amsuess.com/tools/arandr/\" target=\"_blank\" rel=\"noopener\">Arandr</a>进行图像界面的操作</p>\n<h3 id=\"音频\"><a href=\"#音频\" class=\"headerlink\" title=\"音频\"></a>音频</h3><p>1.安装alsa-utils,<code>sudo pacman install alsa-utils</code></p>\n<p>2.使用amixer命令控制</p>\n<ul>\n<li><p><code>amixer</code>显示声卡信息</p>\n</li>\n<li><p><code>amixer sset Master unmute</code>解除静音</p>\n</li>\n<li><p><code>amixer sset Master 80%</code>调整Master声卡音量为80%</p>\n</li>\n</ul>\n<h3 id=\"其他的一些有用的命令\"><a href=\"#其他的一些有用的命令\" class=\"headerlink\" title=\"其他的一些有用的命令\"></a>其他的一些有用的命令</h3><h4 id=\"图片优化\"><a href=\"#图片优化\" class=\"headerlink\" title=\"图片优化\"></a>图片优化</h4><p>1.安装<a href=\"https://wiki.archlinux.org/index.php/ImageMagick\" target=\"_blank\" rel=\"noopener\">ImageMagick</a></p>\n<p>2.一些常用的命令</p>\n<ul>\n<li><p><code>convert -sample 50%x50%  xxx.jpg  xxx-opt.jpg</code> 图片压缩,减小图片体积</p>\n</li>\n<li><p><code>convert  xxx.jpg  xxx.png</code> 图片转化</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Linux使用上踩过的坑\"><a href=\"#Linux使用上踩过的坑\" class=\"headerlink\" title=\"Linux使用上踩过的坑\"></a>Linux使用上踩过的坑</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>记录我在linux使用上遇到的一些坑，帮助其他人能够更快的发现问题(ps: ctrl+f进行关键词搜素)</p>\n<h2 id=\"主要内容\"><a href=\"#主要内容\" class=\"headerlink\" title=\"主要内容\"></a>主要内容</h2><h3 id=\"开机优化及问题排查\"><a href=\"#开机优化及问题排查\" class=\"headerlink\" title=\"开机优化及问题排查\"></a>开机优化及问题排查</h3><ul>\n<li><p>使用 systemd-analyze blame 查看各个服务开机耗时，可disable一些不必要的服务</p>\n</li>\n<li><p>dmesg查看启动的系统日志，对存在的问题优化</p>\n</li>\n<li><p>设置grub/etc/default/grub文件的GRUB_CMDLINE_LINUX_DEFAULT参数loglevel=0，开机时显示最详细的日志信息</p>\n</li>\n<li><p>如果gdm启动过慢，或许可以通过修改/etc/gdm/custom.conf文件添加</p>\n<p>[daemon]</p>\n<p>WaylandEnable=false</p>\n<p>禁用Wayland使用Xorg服务</p>\n</li>\n</ul>\n<h3 id=\"一些外设的命令行配置\"><a href=\"#一些外设的命令行配置\" class=\"headerlink\" title=\"一些外设的命令行配置\"></a>一些外设的命令行配置</h3><h4 id=\"wifi\"><a href=\"#wifi\" class=\"headerlink\" title=\"wifi\"></a>wifi</h4><ul>\n<li><p>一般系统自带命令wpa,参考 <a href=\"https://wiki.archlinux.org/index.php/WPA_supplicant\" target=\"_blank\" rel=\"noopener\">Arch linux wiki</a></p>\n<p>1.通过<code>wpa_passphrase *MYSSID* *passphrase* &gt; /etc/wpa_supplicant/example.conf</code>生成用户名密码配置文件</p>\n<p>2.通过<code>wpa_supplicant -B -i wlp1s0 -c /etc/wpa_supplicant/example.conf</code>连接wifi</p>\n</li>\n<li><p>通过安装<a href=\"https://wiki.archlinux.org/index.php/Netctl\" target=\"_blank\" rel=\"noopener\">netctl</a>进行连接</p>\n<p>1.通过仿照目录/etc/netctl/examples/下配置生成配置文件到目录/etc/netctl/下</p>\n<p>2.通过命令<code>sudo netctl start home</code>连接wifi</p>\n</li>\n</ul>\n<h4 id=\"蓝牙\"><a href=\"#蓝牙\" class=\"headerlink\" title=\"蓝牙\"></a>蓝牙</h4><p>1.通过<code>sudo systemctl start bluetooth.service</code>启动蓝牙服务</p>\n<p>2.安装<a href=\"https://en.wikipedia.org/wiki/Bluetooth\" target=\"_blank\" rel=\"noopener\">Bluetooth</a>进行蓝牙控制，参考Bluetooth文档连接蓝牙</p>\n<h4 id=\"硬盘\"><a href=\"#硬盘\" class=\"headerlink\" title=\"硬盘\"></a>硬盘</h4><p>1.修改<a href=\"https://en.wikipedia.org/wiki/Fstab\" target=\"_blank\" rel=\"noopener\">/etc/fstab</a>，对硬盘进行开机时挂载行为控制,一些常见的配置</p>\n<ul>\n<li>对于外置硬盘如果插入开机自动挂载<code>UUID=******** /mnt/disk   ext4    defaults,nofail 0 2</code></li>\n</ul>\n<p>2.通过<code>sudo mount -a</code>，安装让系统按照/etc/fstab进行挂载</p>\n<h4 id=\"显示器\"><a href=\"#显示器\" class=\"headerlink\" title=\"显示器\"></a>显示器</h4><p>通过<a href=\"https://wiki.archlinux.org/index.php/Xrandr\" target=\"_blank\" rel=\"noopener\">Xrandr</a>命令进行显示器的连接，一些常用的操作:</p>\n<p>1.<code>xrandr --output HDMI-1 --mode 1920x1080 --pos 1920x0</code>在显示器右侧添加另一个显示器</p>\n<p>2.<code>xrandr --output HDMI-1 --off</code>关闭HDMI-1接口的显示器</p>\n<p>ps:可安装<a href=\"https://christian.amsuess.com/tools/arandr/\" target=\"_blank\" rel=\"noopener\">Arandr</a>进行图像界面的操作</p>\n<h3 id=\"音频\"><a href=\"#音频\" class=\"headerlink\" title=\"音频\"></a>音频</h3><p>1.安装alsa-utils,<code>sudo pacman install alsa-utils</code></p>\n<p>2.使用amixer命令控制</p>\n<ul>\n<li><p><code>amixer</code>显示声卡信息</p>\n</li>\n<li><p><code>amixer sset Master unmute</code>解除静音</p>\n</li>\n<li><p><code>amixer sset Master 80%</code>调整Master声卡音量为80%</p>\n</li>\n</ul>\n<h3 id=\"其他的一些有用的命令\"><a href=\"#其他的一些有用的命令\" class=\"headerlink\" title=\"其他的一些有用的命令\"></a>其他的一些有用的命令</h3><h4 id=\"图片优化\"><a href=\"#图片优化\" class=\"headerlink\" title=\"图片优化\"></a>图片优化</h4><p>1.安装<a href=\"https://wiki.archlinux.org/index.php/ImageMagick\" target=\"_blank\" rel=\"noopener\">ImageMagick</a></p>\n<p>2.一些常用的命令</p>\n<ul>\n<li><p><code>convert -sample 50%x50%  xxx.jpg  xxx-opt.jpg</code> 图片压缩,减小图片体积</p>\n</li>\n<li><p><code>convert  xxx.jpg  xxx.png</code> 图片转化</p>\n</li>\n</ul>\n"},{"title":"Mysql数据库优化","date":"1999-02-23T16:00:00.000Z","_content":"\n# Mysql数据库优化\n\n- 单表千万行数据时 或者 数据储存超过10G时进行分表操作\n\n- \n","source":"_posts/Mysql数据库优化.md","raw":"---\ntitle: Mysql数据库优化\ndate: 1999-02-24\ntags:\n---\n\n# Mysql数据库优化\n\n- 单表千万行数据时 或者 数据储存超过10G时进行分表操作\n\n- \n","slug":"Mysql数据库优化","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxd000b1w2exi9h2k5x","content":"<h1 id=\"Mysql数据库优化\"><a href=\"#Mysql数据库优化\" class=\"headerlink\" title=\"Mysql数据库优化\"></a>Mysql数据库优化</h1><ul>\n<li><p>单表千万行数据时 或者 数据储存超过10G时进行分表操作</p>\n</li>\n<li></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Mysql数据库优化\"><a href=\"#Mysql数据库优化\" class=\"headerlink\" title=\"Mysql数据库优化\"></a>Mysql数据库优化</h1><ul>\n<li><p>单表千万行数据时 或者 数据储存超过10G时进行分表操作</p>\n</li>\n<li></li>\n</ul>\n"},{"title":"Spring XSS处理","date":"1999-02-23T16:00:00.000Z","_content":"\n# Spring XSS处理\n\n# 针对 request Param 处理\n\n\n\n# 针对Json数据处理\n\n\n","source":"_posts/Spring XSS处理.md","raw":"---\ntitle: Spring XSS处理\ndate: 1999-02-24\ntags:\n---\n\n# Spring XSS处理\n\n# 针对 request Param 处理\n\n\n\n# 针对Json数据处理\n\n\n","slug":"Spring XSS处理","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxe000c1w2eg2786bal","content":"<h1 id=\"Spring-XSS处理\"><a href=\"#Spring-XSS处理\" class=\"headerlink\" title=\"Spring XSS处理\"></a>Spring XSS处理</h1><h1 id=\"针对-request-Param-处理\"><a href=\"#针对-request-Param-处理\" class=\"headerlink\" title=\"针对 request Param 处理\"></a>针对 request Param 处理</h1><h1 id=\"针对Json数据处理\"><a href=\"#针对Json数据处理\" class=\"headerlink\" title=\"针对Json数据处理\"></a>针对Json数据处理</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Spring-XSS处理\"><a href=\"#Spring-XSS处理\" class=\"headerlink\" title=\"Spring XSS处理\"></a>Spring XSS处理</h1><h1 id=\"针对-request-Param-处理\"><a href=\"#针对-request-Param-处理\" class=\"headerlink\" title=\"针对 request Param 处理\"></a>针对 request Param 处理</h1><h1 id=\"针对Json数据处理\"><a href=\"#针对Json数据处理\" class=\"headerlink\" title=\"针对Json数据处理\"></a>针对Json数据处理</h1>"},{"title":"let's encrypt 证书dns验证安装","date":"1999-02-23T16:00:00.000Z","_content":"\n# let's encrypt 证书dns验证安装\n\n./certbot-auto certonly --manual -d cdn.guohezuzi.cn --preferred-challenges dns-01 --server https://acme-v02.api.letsencrypt.org/directory\n","source":"_posts/let's encrypt 证书dns验证安装.md","raw":"---\ntitle: let's encrypt 证书dns验证安装\ndate: 1999-02-24\ntags:\n---\n\n# let's encrypt 证书dns验证安装\n\n./certbot-auto certonly --manual -d cdn.guohezuzi.cn --preferred-challenges dns-01 --server https://acme-v02.api.letsencrypt.org/directory\n","slug":"let's encrypt 证书dns验证安装","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxf000d1w2eqbtb51iw","content":"<h1 id=\"let’s-encrypt-证书dns验证安装\"><a href=\"#let’s-encrypt-证书dns验证安装\" class=\"headerlink\" title=\"let’s encrypt 证书dns验证安装\"></a>let’s encrypt 证书dns验证安装</h1><p>./certbot-auto certonly –manual -d cdn.guohezuzi.cn –preferred-challenges dns-01 –server <a href=\"https://acme-v02.api.letsencrypt.org/directory\" target=\"_blank\" rel=\"noopener\">https://acme-v02.api.letsencrypt.org/directory</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"let’s-encrypt-证书dns验证安装\"><a href=\"#let’s-encrypt-证书dns验证安装\" class=\"headerlink\" title=\"let’s encrypt 证书dns验证安装\"></a>let’s encrypt 证书dns验证安装</h1><p>./certbot-auto certonly –manual -d cdn.guohezuzi.cn –preferred-challenges dns-01 –server <a href=\"https://acme-v02.api.letsencrypt.org/directory\" target=\"_blank\" rel=\"noopener\">https://acme-v02.api.letsencrypt.org/directory</a></p>\n"},{"title":"Ubuntu操作系统下的 Arch Linux安装","date":"1999-02-23T16:00:00.000Z","_content":"\n# Ubuntu操作系统下的 Arch Linux安装\n","source":"_posts/Ubuntu操作系统下的 Arch Linux安装.md","raw":"---\ntitle: Ubuntu操作系统下的 Arch Linux安装\ndate: 1999-02-24\ntags:\n---\n\n# Ubuntu操作系统下的 Arch Linux安装\n","slug":"Ubuntu操作系统下的 Arch Linux安装","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxg000e1w2e9x1yl7bi","content":"<h1 id=\"Ubuntu操作系统下的-Arch-Linux安装\"><a href=\"#Ubuntu操作系统下的-Arch-Linux安装\" class=\"headerlink\" title=\"Ubuntu操作系统下的 Arch Linux安装\"></a>Ubuntu操作系统下的 Arch Linux安装</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Ubuntu操作系统下的-Arch-Linux安装\"><a href=\"#Ubuntu操作系统下的-Arch-Linux安装\" class=\"headerlink\" title=\"Ubuntu操作系统下的 Arch Linux安装\"></a>Ubuntu操作系统下的 Arch Linux安装</h1>"},{"title":"mybatis 查询无记录的返回值","date":"1999-02-23T16:00:00.000Z","_content":"\n# mybatis 查询无记录的返回值\n\n| 返回对象   | 值    |\n| ------ | ---- |\n| Object | null |\n| List   | []   |\n| String | null |\n\n\n","source":"_posts/mybatis 查询无记录的返回值.md","raw":"---\ntitle: mybatis 查询无记录的返回值\ndate: 1999-02-24\ntags:\n---\n\n# mybatis 查询无记录的返回值\n\n| 返回对象   | 值    |\n| ------ | ---- |\n| Object | null |\n| List   | []   |\n| String | null |\n\n\n","slug":"mybatis 查询无记录的返回值","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxh000f1w2etp267n0s","content":"<h1 id=\"mybatis-查询无记录的返回值\"><a href=\"#mybatis-查询无记录的返回值\" class=\"headerlink\" title=\"mybatis 查询无记录的返回值\"></a>mybatis 查询无记录的返回值</h1><table>\n<thead>\n<tr>\n<th>返回对象</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Object</td>\n<td>null</td>\n</tr>\n<tr>\n<td>List</td>\n<td>[]</td>\n</tr>\n<tr>\n<td>String</td>\n<td>null</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"mybatis-查询无记录的返回值\"><a href=\"#mybatis-查询无记录的返回值\" class=\"headerlink\" title=\"mybatis 查询无记录的返回值\"></a>mybatis 查询无记录的返回值</h1><table>\n<thead>\n<tr>\n<th>返回对象</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Object</td>\n<td>null</td>\n</tr>\n<tr>\n<td>List</td>\n<td>[]</td>\n</tr>\n<tr>\n<td>String</td>\n<td>null</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"一些Git命令","date":"1999-02-23T16:00:00.000Z","_content":"\n# 一些Git命令\n\n合并另一个分支的指定文件\n\n`git checkout source_branch <path>...`\n","source":"_posts/一些Git命令.md","raw":"---\ntitle: 一些Git命令\ndate: 1999-02-24\ntags:\n---\n\n# 一些Git命令\n\n合并另一个分支的指定文件\n\n`git checkout source_branch <path>...`\n","slug":"一些Git命令","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxh000g1w2e0szuh1a2","content":"<h1 id=\"一些Git命令\"><a href=\"#一些Git命令\" class=\"headerlink\" title=\"一些Git命令\"></a>一些Git命令</h1><p>合并另一个分支的指定文件</p>\n<p><code>git checkout source_branch &lt;path&gt;...</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一些Git命令\"><a href=\"#一些Git命令\" class=\"headerlink\" title=\"一些Git命令\"></a>一些Git命令</h1><p>合并另一个分支的指定文件</p>\n<p><code>git checkout source_branch &lt;path&gt;...</code></p>\n"},{"title":"事务机制详解","date":"1999-02-23T16:00:00.000Z","_content":"\n# 事务机制详解\n\n## 事务的特性\n\n- 原子性: 事务是最小的执行单位，不可分隔\n\n- 一致性:事务执行前后，数据库从一个一致性状态转换到另一个一致性状态。(系统中的某个数据被成功更新后，后续任何对该数据的读取操作都将得到更新后的值)\n\n- 隔离性:并发事务之间是相互独立的\n\n- 持久性:一个事务被提交后，对数据库的更改的永久的\n\n## 事务的隔离级别\n\nTransactionDefinition 接口中定义了五个表示隔离级别的常量：\n\n- TransactionDefinition.ISOLATION_DEFAULT: 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.\n\n- TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读\n\n- TransactionDefinition.ISOLATION_READ_COMMITTED: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生\n\n- TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己**所修改**，可以阻止脏读和不可重复读，但幻读仍有可能发生。\n\n- TransactionDefinition.ISOLATION_SERIALIZABLE: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。\n\n## Mysql事务的原理\n\n- 利用InnoDB的自动提交(autocommit)特性完成。\n\n- 普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。\n\n- 而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。\n\nlink：https://blog.csdn.net/qq_34337272/article/details/80394121 \n","source":"_posts/事务机制详解.md","raw":"---\ntitle: 事务机制详解\ndate: 1999-02-24\ntags:\n---\n\n# 事务机制详解\n\n## 事务的特性\n\n- 原子性: 事务是最小的执行单位，不可分隔\n\n- 一致性:事务执行前后，数据库从一个一致性状态转换到另一个一致性状态。(系统中的某个数据被成功更新后，后续任何对该数据的读取操作都将得到更新后的值)\n\n- 隔离性:并发事务之间是相互独立的\n\n- 持久性:一个事务被提交后，对数据库的更改的永久的\n\n## 事务的隔离级别\n\nTransactionDefinition 接口中定义了五个表示隔离级别的常量：\n\n- TransactionDefinition.ISOLATION_DEFAULT: 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.\n\n- TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读\n\n- TransactionDefinition.ISOLATION_READ_COMMITTED: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生\n\n- TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己**所修改**，可以阻止脏读和不可重复读，但幻读仍有可能发生。\n\n- TransactionDefinition.ISOLATION_SERIALIZABLE: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。\n\n## Mysql事务的原理\n\n- 利用InnoDB的自动提交(autocommit)特性完成。\n\n- 普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。\n\n- 而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。\n\nlink：https://blog.csdn.net/qq_34337272/article/details/80394121 \n","slug":"事务机制详解","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxi000h1w2efaejt3gy","content":"<h1 id=\"事务机制详解\"><a href=\"#事务机制详解\" class=\"headerlink\" title=\"事务机制详解\"></a>事务机制详解</h1><h2 id=\"事务的特性\"><a href=\"#事务的特性\" class=\"headerlink\" title=\"事务的特性\"></a>事务的特性</h2><ul>\n<li><p>原子性: 事务是最小的执行单位，不可分隔</p>\n</li>\n<li><p>一致性:事务执行前后，数据库从一个一致性状态转换到另一个一致性状态。(系统中的某个数据被成功更新后，后续任何对该数据的读取操作都将得到更新后的值)</p>\n</li>\n<li><p>隔离性:并发事务之间是相互独立的</p>\n</li>\n<li><p>持久性:一个事务被提交后，对数据库的更改的永久的</p>\n</li>\n</ul>\n<h2 id=\"事务的隔离级别\"><a href=\"#事务的隔离级别\" class=\"headerlink\" title=\"事务的隔离级别\"></a>事务的隔离级别</h2><p>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p>\n<ul>\n<li><p>TransactionDefinition.ISOLATION_DEFAULT: 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</p>\n</li>\n<li><p>TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</p>\n</li>\n<li><p>TransactionDefinition.ISOLATION_READ_COMMITTED: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</p>\n</li>\n<li><p>TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己<strong>所修改</strong>，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p>\n</li>\n<li><p>TransactionDefinition.ISOLATION_SERIALIZABLE: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</p>\n</li>\n</ul>\n<h2 id=\"Mysql事务的原理\"><a href=\"#Mysql事务的原理\" class=\"headerlink\" title=\"Mysql事务的原理\"></a>Mysql事务的原理</h2><ul>\n<li><p>利用InnoDB的自动提交(autocommit)特性完成。</p>\n</li>\n<li><p>普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。</p>\n</li>\n<li><p>而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。</p>\n</li>\n</ul>\n<p>link：<a href=\"https://blog.csdn.net/qq_34337272/article/details/80394121\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_34337272/article/details/80394121</a> </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"事务机制详解\"><a href=\"#事务机制详解\" class=\"headerlink\" title=\"事务机制详解\"></a>事务机制详解</h1><h2 id=\"事务的特性\"><a href=\"#事务的特性\" class=\"headerlink\" title=\"事务的特性\"></a>事务的特性</h2><ul>\n<li><p>原子性: 事务是最小的执行单位，不可分隔</p>\n</li>\n<li><p>一致性:事务执行前后，数据库从一个一致性状态转换到另一个一致性状态。(系统中的某个数据被成功更新后，后续任何对该数据的读取操作都将得到更新后的值)</p>\n</li>\n<li><p>隔离性:并发事务之间是相互独立的</p>\n</li>\n<li><p>持久性:一个事务被提交后，对数据库的更改的永久的</p>\n</li>\n</ul>\n<h2 id=\"事务的隔离级别\"><a href=\"#事务的隔离级别\" class=\"headerlink\" title=\"事务的隔离级别\"></a>事务的隔离级别</h2><p>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p>\n<ul>\n<li><p>TransactionDefinition.ISOLATION_DEFAULT: 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</p>\n</li>\n<li><p>TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</p>\n</li>\n<li><p>TransactionDefinition.ISOLATION_READ_COMMITTED: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</p>\n</li>\n<li><p>TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己<strong>所修改</strong>，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p>\n</li>\n<li><p>TransactionDefinition.ISOLATION_SERIALIZABLE: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</p>\n</li>\n</ul>\n<h2 id=\"Mysql事务的原理\"><a href=\"#Mysql事务的原理\" class=\"headerlink\" title=\"Mysql事务的原理\"></a>Mysql事务的原理</h2><ul>\n<li><p>利用InnoDB的自动提交(autocommit)特性完成。</p>\n</li>\n<li><p>普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。</p>\n</li>\n<li><p>而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。</p>\n</li>\n</ul>\n<p>link：<a href=\"https://blog.csdn.net/qq_34337272/article/details/80394121\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_34337272/article/details/80394121</a> </p>\n"},{"title":"关于网站建设的一些分享-前端篇","date":"1999-02-23T16:00:00.000Z","_content":"\n# 关于网站建设的一些分享-前端篇\n\n## 响应式布局\n\n### Flex布局\n\n### 针对vw/vh/vmin的响应式\n\n\n\n## SASS/CSS相关\n\n### sass的基本用法\n\n### css动画及过渡效果\n\n\n\n## Vue.js框架\n\n### 自制的一些轮子\n","source":"_posts/关于网站建设的一些分享-前端篇.md","raw":"---\ntitle: 关于网站建设的一些分享-前端篇\ndate: 1999-02-24\ntags:\n---\n\n# 关于网站建设的一些分享-前端篇\n\n## 响应式布局\n\n### Flex布局\n\n### 针对vw/vh/vmin的响应式\n\n\n\n## SASS/CSS相关\n\n### sass的基本用法\n\n### css动画及过渡效果\n\n\n\n## Vue.js框架\n\n### 自制的一些轮子\n","slug":"关于网站建设的一些分享-前端篇","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxi000i1w2edksv2h2c","content":"<h1 id=\"关于网站建设的一些分享-前端篇\"><a href=\"#关于网站建设的一些分享-前端篇\" class=\"headerlink\" title=\"关于网站建设的一些分享-前端篇\"></a>关于网站建设的一些分享-前端篇</h1><h2 id=\"响应式布局\"><a href=\"#响应式布局\" class=\"headerlink\" title=\"响应式布局\"></a>响应式布局</h2><h3 id=\"Flex布局\"><a href=\"#Flex布局\" class=\"headerlink\" title=\"Flex布局\"></a>Flex布局</h3><h3 id=\"针对vw-vh-vmin的响应式\"><a href=\"#针对vw-vh-vmin的响应式\" class=\"headerlink\" title=\"针对vw/vh/vmin的响应式\"></a>针对vw/vh/vmin的响应式</h3><h2 id=\"SASS-CSS相关\"><a href=\"#SASS-CSS相关\" class=\"headerlink\" title=\"SASS/CSS相关\"></a>SASS/CSS相关</h2><h3 id=\"sass的基本用法\"><a href=\"#sass的基本用法\" class=\"headerlink\" title=\"sass的基本用法\"></a>sass的基本用法</h3><h3 id=\"css动画及过渡效果\"><a href=\"#css动画及过渡效果\" class=\"headerlink\" title=\"css动画及过渡效果\"></a>css动画及过渡效果</h3><h2 id=\"Vue-js框架\"><a href=\"#Vue-js框架\" class=\"headerlink\" title=\"Vue.js框架\"></a>Vue.js框架</h2><h3 id=\"自制的一些轮子\"><a href=\"#自制的一些轮子\" class=\"headerlink\" title=\"自制的一些轮子\"></a>自制的一些轮子</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"关于网站建设的一些分享-前端篇\"><a href=\"#关于网站建设的一些分享-前端篇\" class=\"headerlink\" title=\"关于网站建设的一些分享-前端篇\"></a>关于网站建设的一些分享-前端篇</h1><h2 id=\"响应式布局\"><a href=\"#响应式布局\" class=\"headerlink\" title=\"响应式布局\"></a>响应式布局</h2><h3 id=\"Flex布局\"><a href=\"#Flex布局\" class=\"headerlink\" title=\"Flex布局\"></a>Flex布局</h3><h3 id=\"针对vw-vh-vmin的响应式\"><a href=\"#针对vw-vh-vmin的响应式\" class=\"headerlink\" title=\"针对vw/vh/vmin的响应式\"></a>针对vw/vh/vmin的响应式</h3><h2 id=\"SASS-CSS相关\"><a href=\"#SASS-CSS相关\" class=\"headerlink\" title=\"SASS/CSS相关\"></a>SASS/CSS相关</h2><h3 id=\"sass的基本用法\"><a href=\"#sass的基本用法\" class=\"headerlink\" title=\"sass的基本用法\"></a>sass的基本用法</h3><h3 id=\"css动画及过渡效果\"><a href=\"#css动画及过渡效果\" class=\"headerlink\" title=\"css动画及过渡效果\"></a>css动画及过渡效果</h3><h2 id=\"Vue-js框架\"><a href=\"#Vue-js框架\" class=\"headerlink\" title=\"Vue.js框架\"></a>Vue.js框架</h2><h3 id=\"自制的一些轮子\"><a href=\"#自制的一些轮子\" class=\"headerlink\" title=\"自制的一些轮子\"></a>自制的一些轮子</h3>"},{"title":"基于vw的移动端适配方案","date":"1999-02-23T16:00:00.000Z","_content":"\n# 基于vw的移动端适配方案\n\n字体 : 1.6vmin~2.4vmin 768: 12px~24px 最好默认为2vmin\n\n| 分辨率       | 1.6vmin-2.4vmin | 2vmin |\n| --------- | --------------- | ----- |\n| 1366x768  |                 |       |\n| 1920x1080 |                 |       |\n|           |                 |       |\n","source":"_posts/基于vw的移动端适配方案.md","raw":"---\ntitle: 基于vw的移动端适配方案\ndate: 1999-02-24\ntags:\n---\n\n# 基于vw的移动端适配方案\n\n字体 : 1.6vmin~2.4vmin 768: 12px~24px 最好默认为2vmin\n\n| 分辨率       | 1.6vmin-2.4vmin | 2vmin |\n| --------- | --------------- | ----- |\n| 1366x768  |                 |       |\n| 1920x1080 |                 |       |\n|           |                 |       |\n","slug":"基于vw的移动端适配方案","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxj000j1w2eq827hjfh","content":"<h1 id=\"基于vw的移动端适配方案\"><a href=\"#基于vw的移动端适配方案\" class=\"headerlink\" title=\"基于vw的移动端适配方案\"></a>基于vw的移动端适配方案</h1><p>字体 : 1.6vmin~2.4vmin 768: 12px~24px 最好默认为2vmin</p>\n<table>\n<thead>\n<tr>\n<th>分辨率</th>\n<th>1.6vmin-2.4vmin</th>\n<th>2vmin</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1366x768</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>1920x1080</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基于vw的移动端适配方案\"><a href=\"#基于vw的移动端适配方案\" class=\"headerlink\" title=\"基于vw的移动端适配方案\"></a>基于vw的移动端适配方案</h1><p>字体 : 1.6vmin~2.4vmin 768: 12px~24px 最好默认为2vmin</p>\n<table>\n<thead>\n<tr>\n<th>分辨率</th>\n<th>1.6vmin-2.4vmin</th>\n<th>2vmin</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1366x768</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>1920x1080</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n"},{"title":"前端浏览器缓存数据终极解决方案","date":"1999-02-23T16:00:00.000Z","_content":"\n# 前端浏览器缓存数据终极解决方案\n\n- 网站url储存url query ,url param(url太丑 用户体验太差)\n\n- js临时存储(页面刷新后数据消失) \n\n- webstore api localstore储存(浏览器无痕模式下不支持)\n\n- cookie存储(效率比webstore低)\n","source":"_posts/前端浏览器缓存数据终极解决方案.md","raw":"---\ntitle: 前端浏览器缓存数据终极解决方案\ndate: 1999-02-24\ntags:\n---\n\n# 前端浏览器缓存数据终极解决方案\n\n- 网站url储存url query ,url param(url太丑 用户体验太差)\n\n- js临时存储(页面刷新后数据消失) \n\n- webstore api localstore储存(浏览器无痕模式下不支持)\n\n- cookie存储(效率比webstore低)\n","slug":"前端浏览器缓存数据终极解决方案","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxk000k1w2e5zpzqfpr","content":"<h1 id=\"前端浏览器缓存数据终极解决方案\"><a href=\"#前端浏览器缓存数据终极解决方案\" class=\"headerlink\" title=\"前端浏览器缓存数据终极解决方案\"></a>前端浏览器缓存数据终极解决方案</h1><ul>\n<li><p>网站url储存url query ,url param(url太丑 用户体验太差)</p>\n</li>\n<li><p>js临时存储(页面刷新后数据消失) </p>\n</li>\n<li><p>webstore api localstore储存(浏览器无痕模式下不支持)</p>\n</li>\n<li><p>cookie存储(效率比webstore低)</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前端浏览器缓存数据终极解决方案\"><a href=\"#前端浏览器缓存数据终极解决方案\" class=\"headerlink\" title=\"前端浏览器缓存数据终极解决方案\"></a>前端浏览器缓存数据终极解决方案</h1><ul>\n<li><p>网站url储存url query ,url param(url太丑 用户体验太差)</p>\n</li>\n<li><p>js临时存储(页面刷新后数据消失) </p>\n</li>\n<li><p>webstore api localstore储存(浏览器无痕模式下不支持)</p>\n</li>\n<li><p>cookie存储(效率比webstore低)</p>\n</li>\n</ul>\n"},{"title":"常见的正则表达式","date":"1999-02-23T16:00:00.000Z","_content":"\n# 常见的正则表达式\n\n- 用户名 :    `^[a-z0-9_]{3,15}$`\n- 手机号：`^1(3|4|5|7|8)\\d{9}$`\n\n  \n","source":"_posts/常见的正则表达式.md","raw":"---\ntitle: 常见的正则表达式\ndate: 1999-02-24\ntags:\n---\n\n# 常见的正则表达式\n\n- 用户名 :    `^[a-z0-9_]{3,15}$`\n- 手机号：`^1(3|4|5|7|8)\\d{9}$`\n\n  \n","slug":"常见的正则表达式","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxk000l1w2ei7kpl1r3","content":"<h1 id=\"常见的正则表达式\"><a href=\"#常见的正则表达式\" class=\"headerlink\" title=\"常见的正则表达式\"></a>常见的正则表达式</h1><ul>\n<li>用户名 :    <code>^[a-z0-9_]{3,15}$</code></li>\n<li>手机号：<code>^1(3|4|5|7|8)\\d{9}$</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"常见的正则表达式\"><a href=\"#常见的正则表达式\" class=\"headerlink\" title=\"常见的正则表达式\"></a>常见的正则表达式</h1><ul>\n<li>用户名 :    <code>^[a-z0-9_]{3,15}$</code></li>\n<li>手机号：<code>^1(3|4|5|7|8)\\d{9}$</code></li>\n</ul>\n"},{"title":"数据库建模解决方案","date":"1999-02-23T16:00:00.000Z","_content":"\n# 数据库建模解决方案\n\n## 是否加外键约束\n\n不加 不利于后期的拓展 但是在处理业务逻辑时需兼顾外键\n\n## 是否加Join语句(按照阿里的架构来说:不用三表以上的join语句,不利于分表分库)\n\n- 前期使用,后期重构时,减少join语句\n\n- 去掌握不用join语句的数据库延时问题,加锁\n\n\n\n\n","source":"_posts/数据库建模解决方案.md","raw":"---\ntitle: 数据库建模解决方案\ndate: 1999-02-24\ntags:\n---\n\n# 数据库建模解决方案\n\n## 是否加外键约束\n\n不加 不利于后期的拓展 但是在处理业务逻辑时需兼顾外键\n\n## 是否加Join语句(按照阿里的架构来说:不用三表以上的join语句,不利于分表分库)\n\n- 前期使用,后期重构时,减少join语句\n\n- 去掌握不用join语句的数据库延时问题,加锁\n\n\n\n\n","slug":"数据库建模解决方案","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxl000m1w2eggpz203l","content":"<h1 id=\"数据库建模解决方案\"><a href=\"#数据库建模解决方案\" class=\"headerlink\" title=\"数据库建模解决方案\"></a>数据库建模解决方案</h1><h2 id=\"是否加外键约束\"><a href=\"#是否加外键约束\" class=\"headerlink\" title=\"是否加外键约束\"></a>是否加外键约束</h2><p>不加 不利于后期的拓展 但是在处理业务逻辑时需兼顾外键</p>\n<h2 id=\"是否加Join语句-按照阿里的架构来说-不用三表以上的join语句-不利于分表分库\"><a href=\"#是否加Join语句-按照阿里的架构来说-不用三表以上的join语句-不利于分表分库\" class=\"headerlink\" title=\"是否加Join语句(按照阿里的架构来说:不用三表以上的join语句,不利于分表分库)\"></a>是否加Join语句(按照阿里的架构来说:不用三表以上的join语句,不利于分表分库)</h2><ul>\n<li><p>前期使用,后期重构时,减少join语句</p>\n</li>\n<li><p>去掌握不用join语句的数据库延时问题,加锁</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数据库建模解决方案\"><a href=\"#数据库建模解决方案\" class=\"headerlink\" title=\"数据库建模解决方案\"></a>数据库建模解决方案</h1><h2 id=\"是否加外键约束\"><a href=\"#是否加外键约束\" class=\"headerlink\" title=\"是否加外键约束\"></a>是否加外键约束</h2><p>不加 不利于后期的拓展 但是在处理业务逻辑时需兼顾外键</p>\n<h2 id=\"是否加Join语句-按照阿里的架构来说-不用三表以上的join语句-不利于分表分库\"><a href=\"#是否加Join语句-按照阿里的架构来说-不用三表以上的join语句-不利于分表分库\" class=\"headerlink\" title=\"是否加Join语句(按照阿里的架构来说:不用三表以上的join语句,不利于分表分库)\"></a>是否加Join语句(按照阿里的架构来说:不用三表以上的join语句,不利于分表分库)</h2><ul>\n<li><p>前期使用,后期重构时,减少join语句</p>\n</li>\n<li><p>去掌握不用join语句的数据库延时问题,加锁</p>\n</li>\n</ul>\n"},{"title":"目前网站的网络安全","date":"1999-02-23T16:00:00.000Z","_content":"\n# 目前网站的网络安全\n\n- 未使用HTTPS加密!!!\n\n- 通过随机变化的url登录网站后台\n\n- 不能避免中间人攻击\n\n- 不能防ddos攻击\n\n\n","source":"_posts/目前网站的网络安全.md","raw":"---\ntitle: 目前网站的网络安全\ndate: 1999-02-24\ntags:\n---\n\n# 目前网站的网络安全\n\n- 未使用HTTPS加密!!!\n\n- 通过随机变化的url登录网站后台\n\n- 不能避免中间人攻击\n\n- 不能防ddos攻击\n\n\n","slug":"目前网站的网络安全","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxl000n1w2erekd9ak8","content":"<h1 id=\"目前网站的网络安全\"><a href=\"#目前网站的网络安全\" class=\"headerlink\" title=\"目前网站的网络安全\"></a>目前网站的网络安全</h1><ul>\n<li><p>未使用HTTPS加密!!!</p>\n</li>\n<li><p>通过随机变化的url登录网站后台</p>\n</li>\n<li><p>不能避免中间人攻击</p>\n</li>\n<li><p>不能防ddos攻击</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"目前网站的网络安全\"><a href=\"#目前网站的网络安全\" class=\"headerlink\" title=\"目前网站的网络安全\"></a>目前网站的网络安全</h1><ul>\n<li><p>未使用HTTPS加密!!!</p>\n</li>\n<li><p>通过随机变化的url登录网站后台</p>\n</li>\n<li><p>不能避免中间人攻击</p>\n</li>\n<li><p>不能防ddos攻击</p>\n</li>\n</ul>\n"},{"title":"自制Vue轮子的一些规范","date":"1999-02-23T16:00:00.000Z","_content":"\n# 自制Vue轮子的一些规范\n\n- 按钮 默认高30vmin 宽4vmin\n\n- \n","source":"_posts/自制Vue轮子的一些规范.md","raw":"---\ntitle: 自制Vue轮子的一些规范\ndate: 1999-02-24\ntags:\n---\n\n# 自制Vue轮子的一些规范\n\n- 按钮 默认高30vmin 宽4vmin\n\n- \n","slug":"自制Vue轮子的一些规范","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxm000o1w2eqdpnb4bg","content":"<h1 id=\"自制Vue轮子的一些规范\"><a href=\"#自制Vue轮子的一些规范\" class=\"headerlink\" title=\"自制Vue轮子的一些规范\"></a>自制Vue轮子的一些规范</h1><ul>\n<li><p>按钮 默认高30vmin 宽4vmin</p>\n</li>\n<li></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"自制Vue轮子的一些规范\"><a href=\"#自制Vue轮子的一些规范\" class=\"headerlink\" title=\"自制Vue轮子的一些规范\"></a>自制Vue轮子的一些规范</h1><ul>\n<li><p>按钮 默认高30vmin 宽4vmin</p>\n</li>\n<li></li>\n</ul>\n"},{"title":"网站建设分享 - 文章页面实现代码高亮","date":"1999-02-23T16:00:00.000Z","_content":"\n### 网站建设分享 - 文章页面实现代码高亮\n\nRef:\n\n1. [简书官方文档翻译](https://www.jianshu.com/p/d182ea991609)\n\n2. [highlight-bundle-size-decrease](https://bjacobel.com/2016/12/04/highlight-bundle-size/)\n","source":"_posts/网站建设分享 - 文章页面实现代码高亮.md","raw":"---\ntitle: 网站建设分享 - 文章页面实现代码高亮\ndate: 1999-02-24\ntags:\n---\n\n### 网站建设分享 - 文章页面实现代码高亮\n\nRef:\n\n1. [简书官方文档翻译](https://www.jianshu.com/p/d182ea991609)\n\n2. [highlight-bundle-size-decrease](https://bjacobel.com/2016/12/04/highlight-bundle-size/)\n","slug":"网站建设分享 - 文章页面实现代码高亮","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxm000p1w2eir79w7tk","content":"<h3 id=\"网站建设分享-文章页面实现代码高亮\"><a href=\"#网站建设分享-文章页面实现代码高亮\" class=\"headerlink\" title=\"网站建设分享 - 文章页面实现代码高亮\"></a>网站建设分享 - 文章页面实现代码高亮</h3><p>Ref:</p>\n<ol>\n<li><p><a href=\"https://www.jianshu.com/p/d182ea991609\" target=\"_blank\" rel=\"noopener\">简书官方文档翻译</a></p>\n</li>\n<li><p><a href=\"https://bjacobel.com/2016/12/04/highlight-bundle-size/\" target=\"_blank\" rel=\"noopener\">highlight-bundle-size-decrease</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"网站建设分享-文章页面实现代码高亮\"><a href=\"#网站建设分享-文章页面实现代码高亮\" class=\"headerlink\" title=\"网站建设分享 - 文章页面实现代码高亮\"></a>网站建设分享 - 文章页面实现代码高亮</h3><p>Ref:</p>\n<ol>\n<li><p><a href=\"https://www.jianshu.com/p/d182ea991609\" target=\"_blank\" rel=\"noopener\">简书官方文档翻译</a></p>\n</li>\n<li><p><a href=\"https://bjacobel.com/2016/12/04/highlight-bundle-size/\" target=\"_blank\" rel=\"noopener\">highlight-bundle-size-decrease</a></p>\n</li>\n</ol>\n"},{"title":"记一次Java11切换经历","date":"2019-07-29T16:00:00.000Z","_content":"\n# 记一次Java11切换经历\n\n### 系统切换(Arch Linux)\n\n##### JDK下载\n\n-  oracle官网下载[orcale-jdk](https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html)(源码带文档注释)\n\n- 源安装openjdk,运行`sudo pacman -S jdk11-openjdk `(idea查看源码反编译无注释),可运行`sudo pacman -S openjdk11-doc`增加稳定\n\n##### JDK版本切换\n\n通过源安装的open-jdk直接运行`sudo archlinux-java set java-8-openjdk`切换.\n\norcalce下载的jdk,通过将下载的jdk移动到`/usr/lib/jvm/`下,注意命名为java-\\${JAVA_MAJOR_VERSION}-${VENDOR_NAME},这时通过`archlinux-java status`命令查看会发现新增的JDK,然后设置.\n\n```bash\n ~ sudo cp -r app/jdk-11.0.4 /usr/lib/jvm/java-11-oraclejdk\n ~ archlinux-java status                         ✔  14:50:02\nAvailable Java environments:\n  java-11-oraclejdk (default)\n  java-8-openjdk\n ~ sudo archlinux-java set java-11-oraclejdk     ✔  14:50:06\n ~ java -version                                 ✔  14:50:29\njava version \"11.0.4\" 2019-07-16 LTS\nJava(TM) SE Runtime Environment 18.9 (build 11.0.4+10-LTS)\nJava HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.4+10-LTS, mixed mode)\n```\n\n### IDEA配置\n\n1.设置项目JDK\n\n![](https://www.guohezuzi.cn/public/img/blog/java11-1.png)\n\n2.设置模块JDK\n\n![](https://www.guohezuzi.cn/public/img/blog/java11-2.png)\n\n3.maven配置\n\n```xml\n<plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-compiler-plugin</artifactId>\n    <version>3.8.0</version>\n    <configuration>\n        <release>11</release>\n    </configuration>\n</plugin>\n```\n\n### 新特性使用\n\n1.Java 解释器直接执行 Java 源代码\n\n写一个简单的程序,计算个人存活及死亡时间\n\n```java\nimport java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\n\n/**\n * \\* Created with IntelliJ IDEA.\n * \\* @author: zuzi\n * \\* Date: 2019-07-29\n * \\* Time: 上午9:24\n * \\* Description: 向死而生\n * \\\n */\npublic class LiveTowardsDeath1 {\n    public static void main(String[] args) {\n        liveTowardsDeath(1999,2,24,80);\n    }\n\n    private static void liveTowardsDeath(int year,int month,int day,int liveYear){\n        LocalDate birth = LocalDate.of(year, month, day);\n        LocalDate death = LocalDate.of(year+liveYear, month, day);\n        long lifeDays = ChronoUnit.DAYS.between(birth, LocalDate.now());\n        long deathDays = ChronoUnit.DAYS.between(LocalDate.now(), death);\n        System.out.println(\"已存活: \"+lifeDays+\"天\");\n        System.out.println(\"距离死亡: \"+deathDays+\"天\");\n    }\n}\n\n```\n\n运行 \n\n```bash\n~ java LiveTowardsDeath1.java                   ✔  15:29:42\n已存活: 7461天\n距离死亡: 21759天\n```\n\n2.作为脚本运行\n\n修改.java文件为.sh并将内容修改如下:\n\n```bash\n#!java --source 11\n\nimport java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\n\n/**\n * \\* Created with IntelliJ IDEA.\n * \\* @author: zuzi\n * \\* Date: 2019-07-29\n * \\* Time: 上午9:24\n * \\* Description: 向死而生\n * \\\n */\npublic class LiveTowardsDeath0 {\n    public static void main(String[] args) {\n        liveTowardsDeath(1999,2,24,80);\n    }\n\n    private static void liveTowardsDeath(int year,int month,int day,int liveYear){\n        LocalDate birth = LocalDate.of(year, month, day);\n        LocalDate death = LocalDate.of(year+liveYear, month, day);\n        long lifeDays = ChronoUnit.DAYS.between(birth, LocalDate.now());\n        long deathDays = ChronoUnit.DAYS.between(LocalDate.now(), death);\n        System.out.println(\"已存活: \"+lifeDays+\"天 \");\n        System.out.println(\"距离死亡: \"+deathDays+\"天\");\n    }\n}\n\n```\n\n运行\n\n```bash\n ~ chmod u+x LiveTowardsDeath.sh                 ✔  15:34:45\n ~ ./LiveTowardsDeath.sh                         ✔  15:35:25\n已存活: 7461天 \n距离死亡: 21759天\n```\n\n### 参考\n\n[arch-linux文档](https://wiki.archlinux.org/index.php/Java_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87))\n","source":"_posts/记一次Java11切换经历.md","raw":"---\ntitle: 记一次Java11切换经历\ndate: 2019-07-30\ntags:\n---\n\n# 记一次Java11切换经历\n\n### 系统切换(Arch Linux)\n\n##### JDK下载\n\n-  oracle官网下载[orcale-jdk](https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html)(源码带文档注释)\n\n- 源安装openjdk,运行`sudo pacman -S jdk11-openjdk `(idea查看源码反编译无注释),可运行`sudo pacman -S openjdk11-doc`增加稳定\n\n##### JDK版本切换\n\n通过源安装的open-jdk直接运行`sudo archlinux-java set java-8-openjdk`切换.\n\norcalce下载的jdk,通过将下载的jdk移动到`/usr/lib/jvm/`下,注意命名为java-\\${JAVA_MAJOR_VERSION}-${VENDOR_NAME},这时通过`archlinux-java status`命令查看会发现新增的JDK,然后设置.\n\n```bash\n ~ sudo cp -r app/jdk-11.0.4 /usr/lib/jvm/java-11-oraclejdk\n ~ archlinux-java status                         ✔  14:50:02\nAvailable Java environments:\n  java-11-oraclejdk (default)\n  java-8-openjdk\n ~ sudo archlinux-java set java-11-oraclejdk     ✔  14:50:06\n ~ java -version                                 ✔  14:50:29\njava version \"11.0.4\" 2019-07-16 LTS\nJava(TM) SE Runtime Environment 18.9 (build 11.0.4+10-LTS)\nJava HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.4+10-LTS, mixed mode)\n```\n\n### IDEA配置\n\n1.设置项目JDK\n\n![](https://www.guohezuzi.cn/public/img/blog/java11-1.png)\n\n2.设置模块JDK\n\n![](https://www.guohezuzi.cn/public/img/blog/java11-2.png)\n\n3.maven配置\n\n```xml\n<plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-compiler-plugin</artifactId>\n    <version>3.8.0</version>\n    <configuration>\n        <release>11</release>\n    </configuration>\n</plugin>\n```\n\n### 新特性使用\n\n1.Java 解释器直接执行 Java 源代码\n\n写一个简单的程序,计算个人存活及死亡时间\n\n```java\nimport java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\n\n/**\n * \\* Created with IntelliJ IDEA.\n * \\* @author: zuzi\n * \\* Date: 2019-07-29\n * \\* Time: 上午9:24\n * \\* Description: 向死而生\n * \\\n */\npublic class LiveTowardsDeath1 {\n    public static void main(String[] args) {\n        liveTowardsDeath(1999,2,24,80);\n    }\n\n    private static void liveTowardsDeath(int year,int month,int day,int liveYear){\n        LocalDate birth = LocalDate.of(year, month, day);\n        LocalDate death = LocalDate.of(year+liveYear, month, day);\n        long lifeDays = ChronoUnit.DAYS.between(birth, LocalDate.now());\n        long deathDays = ChronoUnit.DAYS.between(LocalDate.now(), death);\n        System.out.println(\"已存活: \"+lifeDays+\"天\");\n        System.out.println(\"距离死亡: \"+deathDays+\"天\");\n    }\n}\n\n```\n\n运行 \n\n```bash\n~ java LiveTowardsDeath1.java                   ✔  15:29:42\n已存活: 7461天\n距离死亡: 21759天\n```\n\n2.作为脚本运行\n\n修改.java文件为.sh并将内容修改如下:\n\n```bash\n#!java --source 11\n\nimport java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\n\n/**\n * \\* Created with IntelliJ IDEA.\n * \\* @author: zuzi\n * \\* Date: 2019-07-29\n * \\* Time: 上午9:24\n * \\* Description: 向死而生\n * \\\n */\npublic class LiveTowardsDeath0 {\n    public static void main(String[] args) {\n        liveTowardsDeath(1999,2,24,80);\n    }\n\n    private static void liveTowardsDeath(int year,int month,int day,int liveYear){\n        LocalDate birth = LocalDate.of(year, month, day);\n        LocalDate death = LocalDate.of(year+liveYear, month, day);\n        long lifeDays = ChronoUnit.DAYS.between(birth, LocalDate.now());\n        long deathDays = ChronoUnit.DAYS.between(LocalDate.now(), death);\n        System.out.println(\"已存活: \"+lifeDays+\"天 \");\n        System.out.println(\"距离死亡: \"+deathDays+\"天\");\n    }\n}\n\n```\n\n运行\n\n```bash\n ~ chmod u+x LiveTowardsDeath.sh                 ✔  15:34:45\n ~ ./LiveTowardsDeath.sh                         ✔  15:35:25\n已存活: 7461天 \n距离死亡: 21759天\n```\n\n### 参考\n\n[arch-linux文档](https://wiki.archlinux.org/index.php/Java_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87))\n","slug":"记一次Java11切换经历","published":1,"updated":"2019-11-13T10:15:36.446Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxn000q1w2etl4b7ox7","content":"<h1 id=\"记一次Java11切换经历\"><a href=\"#记一次Java11切换经历\" class=\"headerlink\" title=\"记一次Java11切换经历\"></a>记一次Java11切换经历</h1><h3 id=\"系统切换-Arch-Linux\"><a href=\"#系统切换-Arch-Linux\" class=\"headerlink\" title=\"系统切换(Arch Linux)\"></a>系统切换(Arch Linux)</h3><h5 id=\"JDK下载\"><a href=\"#JDK下载\" class=\"headerlink\" title=\"JDK下载\"></a>JDK下载</h5><ul>\n<li><p>oracle官网下载<a href=\"https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html\" target=\"_blank\" rel=\"noopener\">orcale-jdk</a>(源码带文档注释)</p>\n</li>\n<li><p>源安装openjdk,运行<code>sudo pacman -S jdk11-openjdk</code>(idea查看源码反编译无注释),可运行<code>sudo pacman -S openjdk11-doc</code>增加稳定</p>\n</li>\n</ul>\n<h5 id=\"JDK版本切换\"><a href=\"#JDK版本切换\" class=\"headerlink\" title=\"JDK版本切换\"></a>JDK版本切换</h5><p>通过源安装的open-jdk直接运行<code>sudo archlinux-java set java-8-openjdk</code>切换.</p>\n<p>orcalce下载的jdk,通过将下载的jdk移动到<code>/usr/lib/jvm/</code>下,注意命名为java-\\${JAVA_MAJOR_VERSION}-${VENDOR_NAME},这时通过<code>archlinux-java status</code>命令查看会发现新增的JDK,然后设置.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> ~ sudo cp -r app/jdk-11.0.4 /usr/lib/jvm/java-11-oraclejdk</span><br><span class=\"line\"> ~ archlinux-java status                         ✔  14:50:02</span><br><span class=\"line\">Available Java environments:</span><br><span class=\"line\">  java-11-oraclejdk (default)</span><br><span class=\"line\">  java-8-openjdk</span><br><span class=\"line\"> ~ sudo archlinux-java <span class=\"built_in\">set</span> java-11-oraclejdk     ✔  14:50:06</span><br><span class=\"line\"> ~ java -version                                 ✔  14:50:29</span><br><span class=\"line\">java version <span class=\"string\">\"11.0.4\"</span> 2019-07-16 LTS</span><br><span class=\"line\">Java(TM) SE Runtime Environment 18.9 (build 11.0.4+10-LTS)</span><br><span class=\"line\">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.4+10-LTS, mixed mode)</span><br></pre></td></tr></table></figure>\n<h3 id=\"IDEA配置\"><a href=\"#IDEA配置\" class=\"headerlink\" title=\"IDEA配置\"></a>IDEA配置</h3><p>1.设置项目JDK</p>\n<p><img src=\"https://www.guohezuzi.cn/public/img/blog/java11-1.png\" alt></p>\n<p>2.设置模块JDK</p>\n<p><img src=\"https://www.guohezuzi.cn/public/img/blog/java11-2.png\" alt></p>\n<p>3.maven配置</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-compiler-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.8.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">release</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">release</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"新特性使用\"><a href=\"#新特性使用\" class=\"headerlink\" title=\"新特性使用\"></a>新特性使用</h3><p>1.Java 解释器直接执行 Java 源代码</p>\n<p>写一个简单的程序,计算个人存活及死亡时间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.time.LocalDate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.time.temporal.ChronoUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Created with IntelliJ IDEA.</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* <span class=\"doctag\">@author</span>: zuzi</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Date: 2019-07-29</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Time: 上午9:24</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Description: 向死而生</span></span><br><span class=\"line\"><span class=\"comment\"> * \\</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveTowardsDeath1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        liveTowardsDeath(<span class=\"number\">1999</span>,<span class=\"number\">2</span>,<span class=\"number\">24</span>,<span class=\"number\">80</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">liveTowardsDeath</span><span class=\"params\">(<span class=\"keyword\">int</span> year,<span class=\"keyword\">int</span> month,<span class=\"keyword\">int</span> day,<span class=\"keyword\">int</span> liveYear)</span></span>&#123;</span><br><span class=\"line\">        LocalDate birth = LocalDate.of(year, month, day);</span><br><span class=\"line\">        LocalDate death = LocalDate.of(year+liveYear, month, day);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> lifeDays = ChronoUnit.DAYS.between(birth, LocalDate.now());</span><br><span class=\"line\">        <span class=\"keyword\">long</span> deathDays = ChronoUnit.DAYS.between(LocalDate.now(), death);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"已存活: \"</span>+lifeDays+<span class=\"string\">\"天\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"距离死亡: \"</span>+deathDays+<span class=\"string\">\"天\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行 </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ java LiveTowardsDeath1.java                   ✔  15:29:42</span><br><span class=\"line\">已存活: 7461天</span><br><span class=\"line\">距离死亡: 21759天</span><br></pre></td></tr></table></figure>\n<p>2.作为脚本运行</p>\n<p>修改.java文件为.sh并将内容修改如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!java --source 11</span></span><br><span class=\"line\"></span><br><span class=\"line\">import java.time.LocalDate;</span><br><span class=\"line\">import java.time.temporal.ChronoUnit;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * \\* Created with IntelliJ IDEA.</span><br><span class=\"line\"> * \\* @author: zuzi</span><br><span class=\"line\"> * \\* Date: 2019-07-29</span><br><span class=\"line\"> * \\* Time: 上午9:24</span><br><span class=\"line\"> * \\* Description: 向死而生</span><br><span class=\"line\"> * \\</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class LiveTowardsDeath0 &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        liveTowardsDeath(1999,2,24,80);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void liveTowardsDeath(int year,int month,int day,int liveYear)&#123;</span><br><span class=\"line\">        LocalDate birth = LocalDate.of(year, month, day);</span><br><span class=\"line\">        LocalDate death = LocalDate.of(year+liveYear, month, day);</span><br><span class=\"line\">        long lifeDays = ChronoUnit.DAYS.between(birth, LocalDate.now());</span><br><span class=\"line\">        long deathDays = ChronoUnit.DAYS.between(LocalDate.now(), death);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"已存活: \"</span>+lifeDays+<span class=\"string\">\"天 \"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"距离死亡: \"</span>+deathDays+<span class=\"string\">\"天\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> ~ chmod u+x LiveTowardsDeath.sh                 ✔  15:34:45</span><br><span class=\"line\"> ~ ./LiveTowardsDeath.sh                         ✔  15:35:25</span><br><span class=\"line\">已存活: 7461天 </span><br><span class=\"line\">距离死亡: 21759天</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://wiki.archlinux.org/index.php/Java_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87\" target=\"_blank\" rel=\"noopener\">arch-linux文档</a>)</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"记一次Java11切换经历\"><a href=\"#记一次Java11切换经历\" class=\"headerlink\" title=\"记一次Java11切换经历\"></a>记一次Java11切换经历</h1><h3 id=\"系统切换-Arch-Linux\"><a href=\"#系统切换-Arch-Linux\" class=\"headerlink\" title=\"系统切换(Arch Linux)\"></a>系统切换(Arch Linux)</h3><h5 id=\"JDK下载\"><a href=\"#JDK下载\" class=\"headerlink\" title=\"JDK下载\"></a>JDK下载</h5><ul>\n<li><p>oracle官网下载<a href=\"https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html\" target=\"_blank\" rel=\"noopener\">orcale-jdk</a>(源码带文档注释)</p>\n</li>\n<li><p>源安装openjdk,运行<code>sudo pacman -S jdk11-openjdk</code>(idea查看源码反编译无注释),可运行<code>sudo pacman -S openjdk11-doc</code>增加稳定</p>\n</li>\n</ul>\n<h5 id=\"JDK版本切换\"><a href=\"#JDK版本切换\" class=\"headerlink\" title=\"JDK版本切换\"></a>JDK版本切换</h5><p>通过源安装的open-jdk直接运行<code>sudo archlinux-java set java-8-openjdk</code>切换.</p>\n<p>orcalce下载的jdk,通过将下载的jdk移动到<code>/usr/lib/jvm/</code>下,注意命名为java-\\${JAVA_MAJOR_VERSION}-${VENDOR_NAME},这时通过<code>archlinux-java status</code>命令查看会发现新增的JDK,然后设置.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> ~ sudo cp -r app/jdk-11.0.4 /usr/lib/jvm/java-11-oraclejdk</span><br><span class=\"line\"> ~ archlinux-java status                         ✔  14:50:02</span><br><span class=\"line\">Available Java environments:</span><br><span class=\"line\">  java-11-oraclejdk (default)</span><br><span class=\"line\">  java-8-openjdk</span><br><span class=\"line\"> ~ sudo archlinux-java <span class=\"built_in\">set</span> java-11-oraclejdk     ✔  14:50:06</span><br><span class=\"line\"> ~ java -version                                 ✔  14:50:29</span><br><span class=\"line\">java version <span class=\"string\">\"11.0.4\"</span> 2019-07-16 LTS</span><br><span class=\"line\">Java(TM) SE Runtime Environment 18.9 (build 11.0.4+10-LTS)</span><br><span class=\"line\">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.4+10-LTS, mixed mode)</span><br></pre></td></tr></table></figure>\n<h3 id=\"IDEA配置\"><a href=\"#IDEA配置\" class=\"headerlink\" title=\"IDEA配置\"></a>IDEA配置</h3><p>1.设置项目JDK</p>\n<p><img src=\"https://www.guohezuzi.cn/public/img/blog/java11-1.png\" alt></p>\n<p>2.设置模块JDK</p>\n<p><img src=\"https://www.guohezuzi.cn/public/img/blog/java11-2.png\" alt></p>\n<p>3.maven配置</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-compiler-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.8.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">release</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">release</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"新特性使用\"><a href=\"#新特性使用\" class=\"headerlink\" title=\"新特性使用\"></a>新特性使用</h3><p>1.Java 解释器直接执行 Java 源代码</p>\n<p>写一个简单的程序,计算个人存活及死亡时间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.time.LocalDate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.time.temporal.ChronoUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Created with IntelliJ IDEA.</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* <span class=\"doctag\">@author</span>: zuzi</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Date: 2019-07-29</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Time: 上午9:24</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Description: 向死而生</span></span><br><span class=\"line\"><span class=\"comment\"> * \\</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LiveTowardsDeath1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        liveTowardsDeath(<span class=\"number\">1999</span>,<span class=\"number\">2</span>,<span class=\"number\">24</span>,<span class=\"number\">80</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">liveTowardsDeath</span><span class=\"params\">(<span class=\"keyword\">int</span> year,<span class=\"keyword\">int</span> month,<span class=\"keyword\">int</span> day,<span class=\"keyword\">int</span> liveYear)</span></span>&#123;</span><br><span class=\"line\">        LocalDate birth = LocalDate.of(year, month, day);</span><br><span class=\"line\">        LocalDate death = LocalDate.of(year+liveYear, month, day);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> lifeDays = ChronoUnit.DAYS.between(birth, LocalDate.now());</span><br><span class=\"line\">        <span class=\"keyword\">long</span> deathDays = ChronoUnit.DAYS.between(LocalDate.now(), death);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"已存活: \"</span>+lifeDays+<span class=\"string\">\"天\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"距离死亡: \"</span>+deathDays+<span class=\"string\">\"天\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行 </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ java LiveTowardsDeath1.java                   ✔  15:29:42</span><br><span class=\"line\">已存活: 7461天</span><br><span class=\"line\">距离死亡: 21759天</span><br></pre></td></tr></table></figure>\n<p>2.作为脚本运行</p>\n<p>修改.java文件为.sh并将内容修改如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!java --source 11</span></span><br><span class=\"line\"></span><br><span class=\"line\">import java.time.LocalDate;</span><br><span class=\"line\">import java.time.temporal.ChronoUnit;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * \\* Created with IntelliJ IDEA.</span><br><span class=\"line\"> * \\* @author: zuzi</span><br><span class=\"line\"> * \\* Date: 2019-07-29</span><br><span class=\"line\"> * \\* Time: 上午9:24</span><br><span class=\"line\"> * \\* Description: 向死而生</span><br><span class=\"line\"> * \\</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class LiveTowardsDeath0 &#123;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        liveTowardsDeath(1999,2,24,80);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private static void liveTowardsDeath(int year,int month,int day,int liveYear)&#123;</span><br><span class=\"line\">        LocalDate birth = LocalDate.of(year, month, day);</span><br><span class=\"line\">        LocalDate death = LocalDate.of(year+liveYear, month, day);</span><br><span class=\"line\">        long lifeDays = ChronoUnit.DAYS.between(birth, LocalDate.now());</span><br><span class=\"line\">        long deathDays = ChronoUnit.DAYS.between(LocalDate.now(), death);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"已存活: \"</span>+lifeDays+<span class=\"string\">\"天 \"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"距离死亡: \"</span>+deathDays+<span class=\"string\">\"天\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> ~ chmod u+x LiveTowardsDeath.sh                 ✔  15:34:45</span><br><span class=\"line\"> ~ ./LiveTowardsDeath.sh                         ✔  15:35:25</span><br><span class=\"line\">已存活: 7461天 </span><br><span class=\"line\">距离死亡: 21759天</span><br></pre></td></tr></table></figure>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://wiki.archlinux.org/index.php/Java_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87\" target=\"_blank\" rel=\"noopener\">arch-linux文档</a>)</p>\n"},{"title":"记一次网站后台无法登录后的问题排查","date":"1999-02-23T16:00:00.000Z","_content":"\n# 记一次网站后台无法登录后的问题排查\n\n## 问题\n\n### 是否存在sql注入\n\n\n### 登录方式是否安全\n\n\n### 数据库是否有必要设置强密码\n\n\n## 优化\n\n### 部署使用systemd提高效率\n\n\n\n### 多环境日志打印重新配置，增加debug环境\n\n\n\n### 数据库定时备份\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/记一次网站后台无法登录后的问题排查.md","raw":"---\ntitle: 记一次网站后台无法登录后的问题排查\ndate: 1999-02-24\ntags:\n---\n\n# 记一次网站后台无法登录后的问题排查\n\n## 问题\n\n### 是否存在sql注入\n\n\n### 登录方式是否安全\n\n\n### 数据库是否有必要设置强密码\n\n\n## 优化\n\n### 部署使用systemd提高效率\n\n\n\n### 多环境日志打印重新配置，增加debug环境\n\n\n\n### 数据库定时备份\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"记一次网站后台无法登录后的问题排查","published":1,"updated":"2019-11-13T10:10:51.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxn000r1w2epo8ciqgv","content":"<h1 id=\"记一次网站后台无法登录后的问题排查\"><a href=\"#记一次网站后台无法登录后的问题排查\" class=\"headerlink\" title=\"记一次网站后台无法登录后的问题排查\"></a>记一次网站后台无法登录后的问题排查</h1><h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><h3 id=\"是否存在sql注入\"><a href=\"#是否存在sql注入\" class=\"headerlink\" title=\"是否存在sql注入\"></a>是否存在sql注入</h3><h3 id=\"登录方式是否安全\"><a href=\"#登录方式是否安全\" class=\"headerlink\" title=\"登录方式是否安全\"></a>登录方式是否安全</h3><h3 id=\"数据库是否有必要设置强密码\"><a href=\"#数据库是否有必要设置强密码\" class=\"headerlink\" title=\"数据库是否有必要设置强密码\"></a>数据库是否有必要设置强密码</h3><h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><h3 id=\"部署使用systemd提高效率\"><a href=\"#部署使用systemd提高效率\" class=\"headerlink\" title=\"部署使用systemd提高效率\"></a>部署使用systemd提高效率</h3><h3 id=\"多环境日志打印重新配置，增加debug环境\"><a href=\"#多环境日志打印重新配置，增加debug环境\" class=\"headerlink\" title=\"多环境日志打印重新配置，增加debug环境\"></a>多环境日志打印重新配置，增加debug环境</h3><h3 id=\"数据库定时备份\"><a href=\"#数据库定时备份\" class=\"headerlink\" title=\"数据库定时备份\"></a>数据库定时备份</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"记一次网站后台无法登录后的问题排查\"><a href=\"#记一次网站后台无法登录后的问题排查\" class=\"headerlink\" title=\"记一次网站后台无法登录后的问题排查\"></a>记一次网站后台无法登录后的问题排查</h1><h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><h3 id=\"是否存在sql注入\"><a href=\"#是否存在sql注入\" class=\"headerlink\" title=\"是否存在sql注入\"></a>是否存在sql注入</h3><h3 id=\"登录方式是否安全\"><a href=\"#登录方式是否安全\" class=\"headerlink\" title=\"登录方式是否安全\"></a>登录方式是否安全</h3><h3 id=\"数据库是否有必要设置强密码\"><a href=\"#数据库是否有必要设置强密码\" class=\"headerlink\" title=\"数据库是否有必要设置强密码\"></a>数据库是否有必要设置强密码</h3><h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><h3 id=\"部署使用systemd提高效率\"><a href=\"#部署使用systemd提高效率\" class=\"headerlink\" title=\"部署使用systemd提高效率\"></a>部署使用systemd提高效率</h3><h3 id=\"多环境日志打印重新配置，增加debug环境\"><a href=\"#多环境日志打印重新配置，增加debug环境\" class=\"headerlink\" title=\"多环境日志打印重新配置，增加debug环境\"></a>多环境日志打印重新配置，增加debug环境</h3><h3 id=\"数据库定时备份\"><a href=\"#数据库定时备份\" class=\"headerlink\" title=\"数据库定时备份\"></a>数据库定时备份</h3>"},{"title":"Java多线程 - Spring中的线程安全","date":"2019-06-15T09:19:04.000Z","_content":"\n# Java多线程 - Spring中的线程安全\n\n## 为什么我们一般使用的Spring bean是线程安全？\n\n在spring中bean的默认创建scope是singleton的，即创建的对象是**单例**的，并且当我们使用这些bean时，如我们经常使用的Service、DAO和Controller，大多数情况下都是以类似工具类的形式使用，只是调用这些bean的方法，而不会对bean的属性、状态进行改变，故不存在多线程竞争，即线程安全。\n\n## 如果我们要对这些bean的属性改变如何保证线程安全？\n\n### 通过将scope设置为prototype\n\n当将scope设置为prototype时，每次使用该对象是都会重新构造这个对象，故对象的属性(成员变量)都是线程独有的，是线程安全的。不过，这么多对象的创建和销毁会大量占用内存和消耗系统资源，更推荐使用下面的threadlocal。\n\n### 通过使用ThreadLocal\n\n当同步对象的属性不需要与其他线程共享，只需要保证在**自身线程封闭**，而不被其他线程修改时使用\n\n#### Threadloca原理\n\n参考:  [Java多线程 - ThreadLocal](https://www.guohezuzi.cn/article/java-multithread-threadlocal)\n\n#### Demo:\n\n 在每次请求中通过threadlocal类共享变量，通过filter、interceptor验证共享成功。在filter中打印threadlocal的值，在interceptor前设置threadlocal的值并打印，在interceptor后删除threadlocal的值，避免内存泄露。(ps:为了讲解方便，故将所有代码发到一个class文件，实现使用时需要分开)\n\n```java\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\nimport org.springframework.web.servlet.handler.HandlerInterceptorAdapter;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * \\* Created with IntelliJ IDEA.\n * \\* @author: zuzi\n * \\* Date: 2019-06-11\n * \\* Time: 下午12:06\n * \\* Description:\n * \\\n */\n@Slf4j\n@SpringBootApplication\npublic class JavaStudyApplication implements WebMvcConfigurer {\n    public static void main(String[] args) {\n        SpringApplication.run(JavaStudyApplication.class, args);\n    }\n\n    public static final ThreadLocal<String> threadLocal = new ThreadLocal<>();\n\n\n    @RestController(\"thread-local\")\n    class ThreadLocalController {\n        @PostMapping\n        public String threadLocalSet() {\n            threadLocal.set(\"controller set\");\n            return \"设置成功！\";\n        }\n\n        @GetMapping\n        public String threadLocalGet() {\n            return \"获取到的threadLocal：为\" + threadLocal.get();\n        }\n    }\n\n    class HttpFilter implements Filter {\n        @Override\n        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n            HttpServletRequest request = (HttpServletRequest) servletRequest;\n            log.info(\"do filter {} {} {}\", Thread.currentThread().getId(), request.getServletPath(), threadLocal.get());\n            filterChain.doFilter(request, servletResponse);\n        }\n    }\n\n    class HttpInterceptor extends HandlerInterceptorAdapter {\n        @Override\n        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n            threadLocal.set(\"interceptor set\");\n            log.info(\"pre handle , threadLocal:\" + threadLocal.get());\n            return true;\n        }\n\n        @Override\n        public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n            log.info(\"after completion, threadLocal:\" + threadLocal.get());\n            threadLocal.remove();\n        }\n    }\n\n\n    @Bean\n    public FilterRegistrationBean httpFilter() {\n        FilterRegistrationBean<Filter> registrationBean = new FilterRegistrationBean<>();\n        registrationBean.setFilter(new HttpFilter());\n        registrationBean.addUrlPatterns(\"/thread-local/*\");\n        return registrationBean;\n    }\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new HttpInterceptor()).addPathPatterns(\"/**\");\n    }\n}\n```\n\n#### 结果验证\n\n当请求`GET /thread-local` 时，由于未设置threadlocal filter打印结果为null，在interceptor 前设置了threadlocal，故打印 interceptor set，在controller中也为设置，返回值为interceptor set，interceptor 后同理为 interceptor set。\n\n请求：\n\n![](https://cdn.guohezuzi.cn/public/img/threadlocal-get-postman.png)\n\n日志：\n\n![](https://cdn.guohezuzi.cn/public/img/threadlocal-get-log.png)\n\n当请求`POST /thread-local`时，类似，结果如下：\n\n请求：\n\n![](https://cdn.guohezuzi.cn/public/img/threadlocal-post-postman.png)\n\n日志：\n\n![](https://cdn.guohezuzi.cn/public/img/threadlocal-post-log.png)\n\n### 通过加锁\n\n当同步对象的属性在多线程中共享时使用，参考: [Java多线程 - 锁机制](https://www.guohezuzi.cn/article/java-multithread-lock)\n","source":"_posts/多线程/Java多线程 - Spring中的线程安全.md","raw":"---\ntitle: Java多线程 - Spring中的线程安全\ndate: 2019-06-15 17:19:04\ntags:\n---\n\n# Java多线程 - Spring中的线程安全\n\n## 为什么我们一般使用的Spring bean是线程安全？\n\n在spring中bean的默认创建scope是singleton的，即创建的对象是**单例**的，并且当我们使用这些bean时，如我们经常使用的Service、DAO和Controller，大多数情况下都是以类似工具类的形式使用，只是调用这些bean的方法，而不会对bean的属性、状态进行改变，故不存在多线程竞争，即线程安全。\n\n## 如果我们要对这些bean的属性改变如何保证线程安全？\n\n### 通过将scope设置为prototype\n\n当将scope设置为prototype时，每次使用该对象是都会重新构造这个对象，故对象的属性(成员变量)都是线程独有的，是线程安全的。不过，这么多对象的创建和销毁会大量占用内存和消耗系统资源，更推荐使用下面的threadlocal。\n\n### 通过使用ThreadLocal\n\n当同步对象的属性不需要与其他线程共享，只需要保证在**自身线程封闭**，而不被其他线程修改时使用\n\n#### Threadloca原理\n\n参考:  [Java多线程 - ThreadLocal](https://www.guohezuzi.cn/article/java-multithread-threadlocal)\n\n#### Demo:\n\n 在每次请求中通过threadlocal类共享变量，通过filter、interceptor验证共享成功。在filter中打印threadlocal的值，在interceptor前设置threadlocal的值并打印，在interceptor后删除threadlocal的值，避免内存泄露。(ps:为了讲解方便，故将所有代码发到一个class文件，实现使用时需要分开)\n\n```java\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.servlet.config.annotation.InterceptorRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurer;\nimport org.springframework.web.servlet.handler.HandlerInterceptorAdapter;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * \\* Created with IntelliJ IDEA.\n * \\* @author: zuzi\n * \\* Date: 2019-06-11\n * \\* Time: 下午12:06\n * \\* Description:\n * \\\n */\n@Slf4j\n@SpringBootApplication\npublic class JavaStudyApplication implements WebMvcConfigurer {\n    public static void main(String[] args) {\n        SpringApplication.run(JavaStudyApplication.class, args);\n    }\n\n    public static final ThreadLocal<String> threadLocal = new ThreadLocal<>();\n\n\n    @RestController(\"thread-local\")\n    class ThreadLocalController {\n        @PostMapping\n        public String threadLocalSet() {\n            threadLocal.set(\"controller set\");\n            return \"设置成功！\";\n        }\n\n        @GetMapping\n        public String threadLocalGet() {\n            return \"获取到的threadLocal：为\" + threadLocal.get();\n        }\n    }\n\n    class HttpFilter implements Filter {\n        @Override\n        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n            HttpServletRequest request = (HttpServletRequest) servletRequest;\n            log.info(\"do filter {} {} {}\", Thread.currentThread().getId(), request.getServletPath(), threadLocal.get());\n            filterChain.doFilter(request, servletResponse);\n        }\n    }\n\n    class HttpInterceptor extends HandlerInterceptorAdapter {\n        @Override\n        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n            threadLocal.set(\"interceptor set\");\n            log.info(\"pre handle , threadLocal:\" + threadLocal.get());\n            return true;\n        }\n\n        @Override\n        public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n            log.info(\"after completion, threadLocal:\" + threadLocal.get());\n            threadLocal.remove();\n        }\n    }\n\n\n    @Bean\n    public FilterRegistrationBean httpFilter() {\n        FilterRegistrationBean<Filter> registrationBean = new FilterRegistrationBean<>();\n        registrationBean.setFilter(new HttpFilter());\n        registrationBean.addUrlPatterns(\"/thread-local/*\");\n        return registrationBean;\n    }\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new HttpInterceptor()).addPathPatterns(\"/**\");\n    }\n}\n```\n\n#### 结果验证\n\n当请求`GET /thread-local` 时，由于未设置threadlocal filter打印结果为null，在interceptor 前设置了threadlocal，故打印 interceptor set，在controller中也为设置，返回值为interceptor set，interceptor 后同理为 interceptor set。\n\n请求：\n\n![](https://cdn.guohezuzi.cn/public/img/threadlocal-get-postman.png)\n\n日志：\n\n![](https://cdn.guohezuzi.cn/public/img/threadlocal-get-log.png)\n\n当请求`POST /thread-local`时，类似，结果如下：\n\n请求：\n\n![](https://cdn.guohezuzi.cn/public/img/threadlocal-post-postman.png)\n\n日志：\n\n![](https://cdn.guohezuzi.cn/public/img/threadlocal-post-log.png)\n\n### 通过加锁\n\n当同步对象的属性在多线程中共享时使用，参考: [Java多线程 - 锁机制](https://www.guohezuzi.cn/article/java-multithread-lock)\n","slug":"多线程/Java多线程 - Spring中的线程安全","published":1,"updated":"2019-11-13T10:09:11.267Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxr000s1w2eixrglc8e","content":"<h1 id=\"Java多线程-Spring中的线程安全\"><a href=\"#Java多线程-Spring中的线程安全\" class=\"headerlink\" title=\"Java多线程 - Spring中的线程安全\"></a>Java多线程 - Spring中的线程安全</h1><h2 id=\"为什么我们一般使用的Spring-bean是线程安全？\"><a href=\"#为什么我们一般使用的Spring-bean是线程安全？\" class=\"headerlink\" title=\"为什么我们一般使用的Spring bean是线程安全？\"></a>为什么我们一般使用的Spring bean是线程安全？</h2><p>在spring中bean的默认创建scope是singleton的，即创建的对象是<strong>单例</strong>的，并且当我们使用这些bean时，如我们经常使用的Service、DAO和Controller，大多数情况下都是以类似工具类的形式使用，只是调用这些bean的方法，而不会对bean的属性、状态进行改变，故不存在多线程竞争，即线程安全。</p>\n<h2 id=\"如果我们要对这些bean的属性改变如何保证线程安全？\"><a href=\"#如果我们要对这些bean的属性改变如何保证线程安全？\" class=\"headerlink\" title=\"如果我们要对这些bean的属性改变如何保证线程安全？\"></a>如果我们要对这些bean的属性改变如何保证线程安全？</h2><h3 id=\"通过将scope设置为prototype\"><a href=\"#通过将scope设置为prototype\" class=\"headerlink\" title=\"通过将scope设置为prototype\"></a>通过将scope设置为prototype</h3><p>当将scope设置为prototype时，每次使用该对象是都会重新构造这个对象，故对象的属性(成员变量)都是线程独有的，是线程安全的。不过，这么多对象的创建和销毁会大量占用内存和消耗系统资源，更推荐使用下面的threadlocal。</p>\n<h3 id=\"通过使用ThreadLocal\"><a href=\"#通过使用ThreadLocal\" class=\"headerlink\" title=\"通过使用ThreadLocal\"></a>通过使用ThreadLocal</h3><p>当同步对象的属性不需要与其他线程共享，只需要保证在<strong>自身线程封闭</strong>，而不被其他线程修改时使用</p>\n<h4 id=\"Threadloca原理\"><a href=\"#Threadloca原理\" class=\"headerlink\" title=\"Threadloca原理\"></a>Threadloca原理</h4><p>参考:  <a href=\"https://www.guohezuzi.cn/article/java-multithread-threadlocal\" target=\"_blank\" rel=\"noopener\">Java多线程 - ThreadLocal</a></p>\n<h4 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo:\"></a>Demo:</h4><p> 在每次请求中通过threadlocal类共享变量，通过filter、interceptor验证共享成功。在filter中打印threadlocal的值，在interceptor前设置threadlocal的值并打印，在interceptor后删除threadlocal的值，避免内存泄露。(ps:为了讲解方便，故将所有代码发到一个class文件，实现使用时需要分开)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.handler.HandlerInterceptorAdapter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Created with IntelliJ IDEA.</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* <span class=\"doctag\">@author</span>: zuzi</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Date: 2019-06-11</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Time: 下午12:06</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Description:</span></span><br><span class=\"line\"><span class=\"comment\"> * \\</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JavaStudyApplication</span> <span class=\"keyword\">implements</span> <span class=\"title\">WebMvcConfigurer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(JavaStudyApplication<span class=\"class\">.<span class=\"keyword\">class</span>, <span class=\"title\">args</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;String&gt; threadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RestController</span>(<span class=\"string\">\"thread-local\"</span>)</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadLocalController</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@PostMapping</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">threadLocalSet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            threadLocal.set(<span class=\"string\">\"controller set\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"设置成功！\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@GetMapping</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">threadLocalGet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"获取到的threadLocal：为\"</span> + threadLocal.get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HttpFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Filter</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">            HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class=\"line\">            log.info(<span class=\"string\">\"do filter &#123;&#125; &#123;&#125; &#123;&#125;\"</span>, Thread.currentThread().getId(), request.getServletPath(), threadLocal.get());</span><br><span class=\"line\">            filterChain.doFilter(request, servletResponse);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HttpInterceptor</span> <span class=\"keyword\">extends</span> <span class=\"title\">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">preHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            threadLocal.set(<span class=\"string\">\"interceptor set\"</span>);</span><br><span class=\"line\">            log.info(<span class=\"string\">\"pre handle , threadLocal:\"</span> + threadLocal.get());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterCompletion</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">\"after completion, threadLocal:\"</span> + threadLocal.get());</span><br><span class=\"line\">            threadLocal.remove();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> FilterRegistrationBean <span class=\"title\">httpFilter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        FilterRegistrationBean&lt;Filter&gt; registrationBean = <span class=\"keyword\">new</span> FilterRegistrationBean&lt;&gt;();</span><br><span class=\"line\">        registrationBean.setFilter(<span class=\"keyword\">new</span> HttpFilter());</span><br><span class=\"line\">        registrationBean.addUrlPatterns(<span class=\"string\">\"/thread-local/*\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> registrationBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addInterceptors</span><span class=\"params\">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">        registry.addInterceptor(<span class=\"keyword\">new</span> HttpInterceptor()).addPathPatterns(<span class=\"string\">\"/**\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"结果验证\"><a href=\"#结果验证\" class=\"headerlink\" title=\"结果验证\"></a>结果验证</h4><p>当请求<code>GET /thread-local</code> 时，由于未设置threadlocal filter打印结果为null，在interceptor 前设置了threadlocal，故打印 interceptor set，在controller中也为设置，返回值为interceptor set，interceptor 后同理为 interceptor set。</p>\n<p>请求：</p>\n<p><img src=\"https://cdn.guohezuzi.cn/public/img/threadlocal-get-postman.png\" alt></p>\n<p>日志：</p>\n<p><img src=\"https://cdn.guohezuzi.cn/public/img/threadlocal-get-log.png\" alt></p>\n<p>当请求<code>POST /thread-local</code>时，类似，结果如下：</p>\n<p>请求：</p>\n<p><img src=\"https://cdn.guohezuzi.cn/public/img/threadlocal-post-postman.png\" alt></p>\n<p>日志：</p>\n<p><img src=\"https://cdn.guohezuzi.cn/public/img/threadlocal-post-log.png\" alt></p>\n<h3 id=\"通过加锁\"><a href=\"#通过加锁\" class=\"headerlink\" title=\"通过加锁\"></a>通过加锁</h3><p>当同步对象的属性在多线程中共享时使用，参考: <a href=\"https://www.guohezuzi.cn/article/java-multithread-lock\" target=\"_blank\" rel=\"noopener\">Java多线程 - 锁机制</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java多线程-Spring中的线程安全\"><a href=\"#Java多线程-Spring中的线程安全\" class=\"headerlink\" title=\"Java多线程 - Spring中的线程安全\"></a>Java多线程 - Spring中的线程安全</h1><h2 id=\"为什么我们一般使用的Spring-bean是线程安全？\"><a href=\"#为什么我们一般使用的Spring-bean是线程安全？\" class=\"headerlink\" title=\"为什么我们一般使用的Spring bean是线程安全？\"></a>为什么我们一般使用的Spring bean是线程安全？</h2><p>在spring中bean的默认创建scope是singleton的，即创建的对象是<strong>单例</strong>的，并且当我们使用这些bean时，如我们经常使用的Service、DAO和Controller，大多数情况下都是以类似工具类的形式使用，只是调用这些bean的方法，而不会对bean的属性、状态进行改变，故不存在多线程竞争，即线程安全。</p>\n<h2 id=\"如果我们要对这些bean的属性改变如何保证线程安全？\"><a href=\"#如果我们要对这些bean的属性改变如何保证线程安全？\" class=\"headerlink\" title=\"如果我们要对这些bean的属性改变如何保证线程安全？\"></a>如果我们要对这些bean的属性改变如何保证线程安全？</h2><h3 id=\"通过将scope设置为prototype\"><a href=\"#通过将scope设置为prototype\" class=\"headerlink\" title=\"通过将scope设置为prototype\"></a>通过将scope设置为prototype</h3><p>当将scope设置为prototype时，每次使用该对象是都会重新构造这个对象，故对象的属性(成员变量)都是线程独有的，是线程安全的。不过，这么多对象的创建和销毁会大量占用内存和消耗系统资源，更推荐使用下面的threadlocal。</p>\n<h3 id=\"通过使用ThreadLocal\"><a href=\"#通过使用ThreadLocal\" class=\"headerlink\" title=\"通过使用ThreadLocal\"></a>通过使用ThreadLocal</h3><p>当同步对象的属性不需要与其他线程共享，只需要保证在<strong>自身线程封闭</strong>，而不被其他线程修改时使用</p>\n<h4 id=\"Threadloca原理\"><a href=\"#Threadloca原理\" class=\"headerlink\" title=\"Threadloca原理\"></a>Threadloca原理</h4><p>参考:  <a href=\"https://www.guohezuzi.cn/article/java-multithread-threadlocal\" target=\"_blank\" rel=\"noopener\">Java多线程 - ThreadLocal</a></p>\n<h4 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo:\"></a>Demo:</h4><p> 在每次请求中通过threadlocal类共享变量，通过filter、interceptor验证共享成功。在filter中打印threadlocal的值，在interceptor前设置threadlocal的值并打印，在interceptor后删除threadlocal的值，避免内存泄露。(ps:为了讲解方便，故将所有代码发到一个class文件，实现使用时需要分开)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.handler.HandlerInterceptorAdapter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Created with IntelliJ IDEA.</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* <span class=\"doctag\">@author</span>: zuzi</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Date: 2019-06-11</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Time: 下午12:06</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Description:</span></span><br><span class=\"line\"><span class=\"comment\"> * \\</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JavaStudyApplication</span> <span class=\"keyword\">implements</span> <span class=\"title\">WebMvcConfigurer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(JavaStudyApplication<span class=\"class\">.<span class=\"keyword\">class</span>, <span class=\"title\">args</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;String&gt; threadLocal = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RestController</span>(<span class=\"string\">\"thread-local\"</span>)</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadLocalController</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@PostMapping</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">threadLocalSet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            threadLocal.set(<span class=\"string\">\"controller set\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"设置成功！\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@GetMapping</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">threadLocalGet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"获取到的threadLocal：为\"</span> + threadLocal.get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HttpFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Filter</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">            HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class=\"line\">            log.info(<span class=\"string\">\"do filter &#123;&#125; &#123;&#125; &#123;&#125;\"</span>, Thread.currentThread().getId(), request.getServletPath(), threadLocal.get());</span><br><span class=\"line\">            filterChain.doFilter(request, servletResponse);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HttpInterceptor</span> <span class=\"keyword\">extends</span> <span class=\"title\">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">preHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            threadLocal.set(<span class=\"string\">\"interceptor set\"</span>);</span><br><span class=\"line\">            log.info(<span class=\"string\">\"pre handle , threadLocal:\"</span> + threadLocal.get());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">afterCompletion</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            log.info(<span class=\"string\">\"after completion, threadLocal:\"</span> + threadLocal.get());</span><br><span class=\"line\">            threadLocal.remove();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> FilterRegistrationBean <span class=\"title\">httpFilter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        FilterRegistrationBean&lt;Filter&gt; registrationBean = <span class=\"keyword\">new</span> FilterRegistrationBean&lt;&gt;();</span><br><span class=\"line\">        registrationBean.setFilter(<span class=\"keyword\">new</span> HttpFilter());</span><br><span class=\"line\">        registrationBean.addUrlPatterns(<span class=\"string\">\"/thread-local/*\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> registrationBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addInterceptors</span><span class=\"params\">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class=\"line\">        registry.addInterceptor(<span class=\"keyword\">new</span> HttpInterceptor()).addPathPatterns(<span class=\"string\">\"/**\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"结果验证\"><a href=\"#结果验证\" class=\"headerlink\" title=\"结果验证\"></a>结果验证</h4><p>当请求<code>GET /thread-local</code> 时，由于未设置threadlocal filter打印结果为null，在interceptor 前设置了threadlocal，故打印 interceptor set，在controller中也为设置，返回值为interceptor set，interceptor 后同理为 interceptor set。</p>\n<p>请求：</p>\n<p><img src=\"https://cdn.guohezuzi.cn/public/img/threadlocal-get-postman.png\" alt></p>\n<p>日志：</p>\n<p><img src=\"https://cdn.guohezuzi.cn/public/img/threadlocal-get-log.png\" alt></p>\n<p>当请求<code>POST /thread-local</code>时，类似，结果如下：</p>\n<p>请求：</p>\n<p><img src=\"https://cdn.guohezuzi.cn/public/img/threadlocal-post-postman.png\" alt></p>\n<p>日志：</p>\n<p><img src=\"https://cdn.guohezuzi.cn/public/img/threadlocal-post-log.png\" alt></p>\n<h3 id=\"通过加锁\"><a href=\"#通过加锁\" class=\"headerlink\" title=\"通过加锁\"></a>通过加锁</h3><p>当同步对象的属性在多线程中共享时使用，参考: <a href=\"https://www.guohezuzi.cn/article/java-multithread-lock\" target=\"_blank\" rel=\"noopener\">Java多线程 - 锁机制</a></p>\n"},{"title":"Java多线程 - AQS详解","date":"2019-06-10T09:19:04.000Z","_content":"\n# Java多线程 - AQS详解\n\n## 介绍\n\nAQS是java.util.concurrent.locks下类AbstractQueuedSynchronizer的简称，是用于    通过Java源码来构建多线程的锁和同步器的一系列框架，用于Java多线程之间的同步，它的类及类结构图如下:\n\n<center>    \n<img src=\"https://cdn.guohezuzi.cn/public/img/aqs-class.png\" width=\"60%\" /> \n</center>\n\n<center>\n <img src=\"https://cdn.guohezuzi.cn/public/img/aqs-diagram.png\" width=\"60%\" />\n </center>\n\n## 原理\n\n在AQS类中维护了一个使用双向链表Node实现的FIFO队列，用于保存等待的线程，同时利用一个int类型的state来表示状态，使用时通过继承AQS类并实现它的acquire和release方法来操作状态，来实现线程的同步。\n\n以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。\n\n再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。\n\n## 不同组件的使用\n\n### CountDownLatch\n\n主要用于等待线程等待其他线程执行后再执行，其实现是通过控制计数器是否递减到0来判别，其他的每一个线程执行完毕后，调用countDown()方法让计数器减一，等待线程调用await()方法，直到计数器为1在执行。\n\ndemo 主线程等待200个线程执行完毕后再执行：\n\n```java\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * \\* Created with IntelliJ IDEA.\n * \\* @author: guohezuzi\n * \\* Date: 2019-06-08\n * \\* Time: 下午4:14\n * \\* Description: ContDownLatch用法：通过引入CountDownLatch计数器,来等待其他线程执行完毕\n * \\\n */\n@Slf4j\npublic class CountDownLatchExample {\n    private static int threadCount = 200;\n\n    public static void test(int threadNum) throws InterruptedException {\n        Thread.sleep(100);\n        log.info(\"{}\",threadNum);\n        Thread.sleep(100);\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        ExecutorService pool= Executors.newCachedThreadPool();\n\n        final CountDownLatch countDownLatch=new CountDownLatch(200);\n        for (int i = 0; i < threadCount; i++) {\n            final int threadNum=i;\n            pool.execute(()->{\n                try {\n                    Thread.sleep(1);\n                    test(threadNum);\n                }catch (Exception e){\n                    log.error(\"exception\",e);\n                }finally {\n                    countDownLatch.countDown();\n                }\n            });\n        }\n        countDownLatch.await();\n        log.info(\"finish\");\n        pool.shutdown();\n    }\n}\n```\n\n### CyclicBarrier\n\n用于等待多个线程都准备好再进行，每一个线程准备好后，计数器加1，加到指定值后全部开始\n\ndemo 一个20个线程每等待5个线程进行一次\n\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.*;\n\n/**\n * \\* Created with IntelliJ IDEA.\n * \\* @author: guohezuzi\n * \\* Date: 2019-06-08\n * \\* Time: 下午5:20\n * \\* Description:\n * 用于等待多个线程都准备好\n * 每一个线程准备好后 计数器加1 加到指定值后全部开始\n * \\\n */\npublic class CyclicBarrierExample {\n    private static final Logger logger = LoggerFactory.getLogger(CountDownLatchExample.class);\n    private static CyclicBarrier cyclicBarrier=new CyclicBarrier(5);\n\n    public static void race(int threadNum) throws InterruptedException{\n        Thread.sleep(1000);\n        logger.info(\"{} is ready\",threadNum);\n        try {\n            //等待指定数量的其他线程执行 无参一直等待不抛异常 有参数表示等待指定时间若数量还未等到抛出异常\n            cyclicBarrier.await(2000, TimeUnit.MILLISECONDS);\n        } catch (BrokenBarrierException | TimeoutException e) {\n            logger.error(\"exception\",e);\n        }\n        logger.info(\"{} is continue\");\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        ExecutorService executorService= Executors.newCachedThreadPool();\n        for (int i = 0; i < 20; i++) {\n            Thread.sleep(1000);\n            final int threadNum=i;\n            executorService.execute(() -> {\n                try {\n                    race(threadNum);\n                } catch (InterruptedException e) {\n                    logger.error(\"exception\",e);\n                }\n            });\n        }\n        executorService.shutdown();\n    }\n\n}\n```\n\n### Semaphore\n\n英译信号量，用于控制某个资源同时可被访问的个数，如控制数据库资源可以同时并发数量为20\n\ndemo:\n\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.*;\n\n/**\n * \\* Created with IntelliJ IDEA.\n * \\* @author: guohezuzi\n * \\* Date: 2019-06-08\n * \\* Time: 下午3:39\n * \\* Description: 信号量学习例子 控制某个资源同时可被访问的个数 如控制数据库资源可以同时并发数量为20\n * \\\n */\npublic class SemaphoreExample {\n    private static final Logger logger = LoggerFactory.getLogger(CountDownLatchExample.class);\n    private static int threadCount = 200;\n\n    public static void test(int threadNum) throws InterruptedException {\n        Thread.sleep(100);\n        logger.info(\"{}\",threadNum);\n        Thread.sleep(1000);\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        ExecutorService pool= Executors.newCachedThreadPool();\n        //定义允许并发的信号量m\n        final Semaphore semaphore=new Semaphore(20);\n        for (int i = 0; i < threadCount; i++) {\n            final int threadNum=i;\n            //该线程的最大并发数为m/n\n            pool.execute(()->{\n                try {\n                    //获取n个信号量 无参为一个\n                    semaphore.acquire(4);\n                    test(threadNum);\n                    //释放n个信号量 无参为一个\n                    semaphore.release(4);\n                }catch (Exception e){\n                    logger.error(\"exception\",e);\n                }\n            });\n        }\n        pool.shutdown();\n    }\n}\n```\n\n### ReentrantReadWriteLock\n\n读写锁，用于需要同步资源时在前后加锁/解锁，当一个线程获取读锁后其他线程可以继续获取读锁，当一个线程获取写锁后其他线程都需等待，因此，可能造成写锁饥饿，就是写锁一直无法获取。\n\ndemo: 一个基于aqs锁实现的部分线程安全的map\n\n```java\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * \\* Created with IntelliJ IDEA.\n * \\* @author: guohezuzi\n * \\* Date: 2019-06-08\n * \\* Time: 下午11:58\n * \\* Description: 读写锁 当一个线程获取读锁后其他线程可以继续获取读锁 当一个线程获取写锁后其他线程都需等待\n * \\\n */\npublic class ReentrantReadWriteLockExample {\n    final Map<String, Data> map = new TreeMap<>();\n\n    private final static ReentrantLock lock = new ReentrantLock();\n\n    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n    private final Lock readLock = readWriteLock.readLock();\n\n    private final Lock writeLock = readWriteLock.writeLock();\n\n    public Data get(String key) {\n        readLock.lock();\n        try {\n            return map.get(key);\n        } finally {\n            readLock.unlock();\n        }\n    }\n\n    public Set<String> getAllkeys() {\n        readLock.lock();\n        try {\n            return map.keySet();\n        } finally {\n            readLock.unlock();\n        }\n    }\n\n    public Data put(String key, Data vlaue) {\n        writeLock.lock();\n        try {\n            return map.put(key, vlaue);\n        } finally {\n            writeLock.unlock();\n        }\n    }\n\n    class Data {\n\n    }\n}\n```\n\n### StampLock\n\n类似读写锁的功能和使用方法，不过有以下两点不同\n\n1. 每次获取锁会得到一个long类型的stamp所为返回值，解锁是需要将其回传。\n\n2. 有乐观读操作，适合于读多写少情况，指当资源被读锁锁定时，会根据资源是否被变更，进行读取操作，而不是不允许读操作。\n\ndemo:\n\n```java\nimport java.util.concurrent.locks.StampedLock;\n\n/**\n * \\* Created with IntelliJ IDEA.\n * \\* @author: guohezuzi\n * \\* Date: 2019-06-09\n * \\* Time: 下午1:08\n * \\* Description:\n * 使用是每次获取锁会得到一个long类型的stamp所为返回值，解锁是需要将其回传\n * 该类有 写 读 乐观读：指当资源被读锁锁定时，会根据资源是否被变更，进行读取操作\n */\npublic class StampLockExample {\n    private int count = 0;\n    private final StampedLock lock = new StampedLock();\n\n    class AddHundredNum extends Thread {\n        @Override\n        public void run() {\n//            synchronized (addHundredNum.class) {\n            long stamp = lock.writeLock();\n            try {\n                for (int i = 0; i < 1000; i++) {\n                    count++;\n                }\n            } finally {\n                lock.unlock(stamp);\n            }\n//            }\n        }\n    }\n\n    public void test() throws InterruptedException {\n        StampLockExample.AddHundredNum[] addHundredNums = new StampLockExample.AddHundredNum[100];\n        for (int i = 0; i < addHundredNums.length; i++) {\n            addHundredNums[i] = new StampLockExample.AddHundredNum();\n        }\n\n        for (StampLockExample.AddHundredNum addHundredNum : addHundredNums) {\n            addHundredNum.start();\n        }\n\n        for (StampLockExample.AddHundredNum addHundredNum : addHundredNums) {\n            addHundredNum.join();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        StampLockExample example = new StampLockExample();\n        example.test();\n        System.out.println(example.count);\n    }\n}\n```\n\n### Condition\n\n配合AQS锁实现的线程中断/等待机制，将等待的线程移入condition维护的队列，并通过condition控制中断/等待。\n\n```java\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * \\* Created with IntelliJ IDEA.\n * \\* @author: guohezuzi\n * \\* Date: 2019-06-09\n * \\* Time: 下午1:26\n * \\* Description:\n * \\\n */\n@Slf4j\npublic class ConditionExample {\n    public static void main(String[] args){\n        final ReentrantLock lock=new ReentrantLock();\n        Condition condition=lock.newCondition();\n        new Thread(()->{\n            lock.lock();\n            log.info(\"wait signal\");\n            try {\n                condition.await();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            log.info(\"get signal\");\n            lock.unlock();\n        }).start();\n\n        new Thread(() -> {\n            lock.lock();\n            log.info(\"get lock\");\n            try {\n                Thread.sleep(3000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            condition.signalAll();\n            log.info(\"send signal ~\");\n            lock.unlock();\n        }).start();\n    }\n}\n```\n\n### \n","source":"_posts/多线程/Java多线程 - AQS详解.md","raw":"---\ntitle: Java多线程 - AQS详解\ndate: 2019-06-10 17:19:04\ntags:\n---\n\n# Java多线程 - AQS详解\n\n## 介绍\n\nAQS是java.util.concurrent.locks下类AbstractQueuedSynchronizer的简称，是用于    通过Java源码来构建多线程的锁和同步器的一系列框架，用于Java多线程之间的同步，它的类及类结构图如下:\n\n<center>    \n<img src=\"https://cdn.guohezuzi.cn/public/img/aqs-class.png\" width=\"60%\" /> \n</center>\n\n<center>\n <img src=\"https://cdn.guohezuzi.cn/public/img/aqs-diagram.png\" width=\"60%\" />\n </center>\n\n## 原理\n\n在AQS类中维护了一个使用双向链表Node实现的FIFO队列，用于保存等待的线程，同时利用一个int类型的state来表示状态，使用时通过继承AQS类并实现它的acquire和release方法来操作状态，来实现线程的同步。\n\n以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。\n\n再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。\n\n## 不同组件的使用\n\n### CountDownLatch\n\n主要用于等待线程等待其他线程执行后再执行，其实现是通过控制计数器是否递减到0来判别，其他的每一个线程执行完毕后，调用countDown()方法让计数器减一，等待线程调用await()方法，直到计数器为1在执行。\n\ndemo 主线程等待200个线程执行完毕后再执行：\n\n```java\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * \\* Created with IntelliJ IDEA.\n * \\* @author: guohezuzi\n * \\* Date: 2019-06-08\n * \\* Time: 下午4:14\n * \\* Description: ContDownLatch用法：通过引入CountDownLatch计数器,来等待其他线程执行完毕\n * \\\n */\n@Slf4j\npublic class CountDownLatchExample {\n    private static int threadCount = 200;\n\n    public static void test(int threadNum) throws InterruptedException {\n        Thread.sleep(100);\n        log.info(\"{}\",threadNum);\n        Thread.sleep(100);\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        ExecutorService pool= Executors.newCachedThreadPool();\n\n        final CountDownLatch countDownLatch=new CountDownLatch(200);\n        for (int i = 0; i < threadCount; i++) {\n            final int threadNum=i;\n            pool.execute(()->{\n                try {\n                    Thread.sleep(1);\n                    test(threadNum);\n                }catch (Exception e){\n                    log.error(\"exception\",e);\n                }finally {\n                    countDownLatch.countDown();\n                }\n            });\n        }\n        countDownLatch.await();\n        log.info(\"finish\");\n        pool.shutdown();\n    }\n}\n```\n\n### CyclicBarrier\n\n用于等待多个线程都准备好再进行，每一个线程准备好后，计数器加1，加到指定值后全部开始\n\ndemo 一个20个线程每等待5个线程进行一次\n\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.*;\n\n/**\n * \\* Created with IntelliJ IDEA.\n * \\* @author: guohezuzi\n * \\* Date: 2019-06-08\n * \\* Time: 下午5:20\n * \\* Description:\n * 用于等待多个线程都准备好\n * 每一个线程准备好后 计数器加1 加到指定值后全部开始\n * \\\n */\npublic class CyclicBarrierExample {\n    private static final Logger logger = LoggerFactory.getLogger(CountDownLatchExample.class);\n    private static CyclicBarrier cyclicBarrier=new CyclicBarrier(5);\n\n    public static void race(int threadNum) throws InterruptedException{\n        Thread.sleep(1000);\n        logger.info(\"{} is ready\",threadNum);\n        try {\n            //等待指定数量的其他线程执行 无参一直等待不抛异常 有参数表示等待指定时间若数量还未等到抛出异常\n            cyclicBarrier.await(2000, TimeUnit.MILLISECONDS);\n        } catch (BrokenBarrierException | TimeoutException e) {\n            logger.error(\"exception\",e);\n        }\n        logger.info(\"{} is continue\");\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        ExecutorService executorService= Executors.newCachedThreadPool();\n        for (int i = 0; i < 20; i++) {\n            Thread.sleep(1000);\n            final int threadNum=i;\n            executorService.execute(() -> {\n                try {\n                    race(threadNum);\n                } catch (InterruptedException e) {\n                    logger.error(\"exception\",e);\n                }\n            });\n        }\n        executorService.shutdown();\n    }\n\n}\n```\n\n### Semaphore\n\n英译信号量，用于控制某个资源同时可被访问的个数，如控制数据库资源可以同时并发数量为20\n\ndemo:\n\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.*;\n\n/**\n * \\* Created with IntelliJ IDEA.\n * \\* @author: guohezuzi\n * \\* Date: 2019-06-08\n * \\* Time: 下午3:39\n * \\* Description: 信号量学习例子 控制某个资源同时可被访问的个数 如控制数据库资源可以同时并发数量为20\n * \\\n */\npublic class SemaphoreExample {\n    private static final Logger logger = LoggerFactory.getLogger(CountDownLatchExample.class);\n    private static int threadCount = 200;\n\n    public static void test(int threadNum) throws InterruptedException {\n        Thread.sleep(100);\n        logger.info(\"{}\",threadNum);\n        Thread.sleep(1000);\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        ExecutorService pool= Executors.newCachedThreadPool();\n        //定义允许并发的信号量m\n        final Semaphore semaphore=new Semaphore(20);\n        for (int i = 0; i < threadCount; i++) {\n            final int threadNum=i;\n            //该线程的最大并发数为m/n\n            pool.execute(()->{\n                try {\n                    //获取n个信号量 无参为一个\n                    semaphore.acquire(4);\n                    test(threadNum);\n                    //释放n个信号量 无参为一个\n                    semaphore.release(4);\n                }catch (Exception e){\n                    logger.error(\"exception\",e);\n                }\n            });\n        }\n        pool.shutdown();\n    }\n}\n```\n\n### ReentrantReadWriteLock\n\n读写锁，用于需要同步资源时在前后加锁/解锁，当一个线程获取读锁后其他线程可以继续获取读锁，当一个线程获取写锁后其他线程都需等待，因此，可能造成写锁饥饿，就是写锁一直无法获取。\n\ndemo: 一个基于aqs锁实现的部分线程安全的map\n\n```java\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\n/**\n * \\* Created with IntelliJ IDEA.\n * \\* @author: guohezuzi\n * \\* Date: 2019-06-08\n * \\* Time: 下午11:58\n * \\* Description: 读写锁 当一个线程获取读锁后其他线程可以继续获取读锁 当一个线程获取写锁后其他线程都需等待\n * \\\n */\npublic class ReentrantReadWriteLockExample {\n    final Map<String, Data> map = new TreeMap<>();\n\n    private final static ReentrantLock lock = new ReentrantLock();\n\n    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n    private final Lock readLock = readWriteLock.readLock();\n\n    private final Lock writeLock = readWriteLock.writeLock();\n\n    public Data get(String key) {\n        readLock.lock();\n        try {\n            return map.get(key);\n        } finally {\n            readLock.unlock();\n        }\n    }\n\n    public Set<String> getAllkeys() {\n        readLock.lock();\n        try {\n            return map.keySet();\n        } finally {\n            readLock.unlock();\n        }\n    }\n\n    public Data put(String key, Data vlaue) {\n        writeLock.lock();\n        try {\n            return map.put(key, vlaue);\n        } finally {\n            writeLock.unlock();\n        }\n    }\n\n    class Data {\n\n    }\n}\n```\n\n### StampLock\n\n类似读写锁的功能和使用方法，不过有以下两点不同\n\n1. 每次获取锁会得到一个long类型的stamp所为返回值，解锁是需要将其回传。\n\n2. 有乐观读操作，适合于读多写少情况，指当资源被读锁锁定时，会根据资源是否被变更，进行读取操作，而不是不允许读操作。\n\ndemo:\n\n```java\nimport java.util.concurrent.locks.StampedLock;\n\n/**\n * \\* Created with IntelliJ IDEA.\n * \\* @author: guohezuzi\n * \\* Date: 2019-06-09\n * \\* Time: 下午1:08\n * \\* Description:\n * 使用是每次获取锁会得到一个long类型的stamp所为返回值，解锁是需要将其回传\n * 该类有 写 读 乐观读：指当资源被读锁锁定时，会根据资源是否被变更，进行读取操作\n */\npublic class StampLockExample {\n    private int count = 0;\n    private final StampedLock lock = new StampedLock();\n\n    class AddHundredNum extends Thread {\n        @Override\n        public void run() {\n//            synchronized (addHundredNum.class) {\n            long stamp = lock.writeLock();\n            try {\n                for (int i = 0; i < 1000; i++) {\n                    count++;\n                }\n            } finally {\n                lock.unlock(stamp);\n            }\n//            }\n        }\n    }\n\n    public void test() throws InterruptedException {\n        StampLockExample.AddHundredNum[] addHundredNums = new StampLockExample.AddHundredNum[100];\n        for (int i = 0; i < addHundredNums.length; i++) {\n            addHundredNums[i] = new StampLockExample.AddHundredNum();\n        }\n\n        for (StampLockExample.AddHundredNum addHundredNum : addHundredNums) {\n            addHundredNum.start();\n        }\n\n        for (StampLockExample.AddHundredNum addHundredNum : addHundredNums) {\n            addHundredNum.join();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        StampLockExample example = new StampLockExample();\n        example.test();\n        System.out.println(example.count);\n    }\n}\n```\n\n### Condition\n\n配合AQS锁实现的线程中断/等待机制，将等待的线程移入condition维护的队列，并通过condition控制中断/等待。\n\n```java\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * \\* Created with IntelliJ IDEA.\n * \\* @author: guohezuzi\n * \\* Date: 2019-06-09\n * \\* Time: 下午1:26\n * \\* Description:\n * \\\n */\n@Slf4j\npublic class ConditionExample {\n    public static void main(String[] args){\n        final ReentrantLock lock=new ReentrantLock();\n        Condition condition=lock.newCondition();\n        new Thread(()->{\n            lock.lock();\n            log.info(\"wait signal\");\n            try {\n                condition.await();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            log.info(\"get signal\");\n            lock.unlock();\n        }).start();\n\n        new Thread(() -> {\n            lock.lock();\n            log.info(\"get lock\");\n            try {\n                Thread.sleep(3000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            condition.signalAll();\n            log.info(\"send signal ~\");\n            lock.unlock();\n        }).start();\n    }\n}\n```\n\n### \n","slug":"多线程/Java多线程 - AQS详解","published":1,"updated":"2019-11-13T10:07:50.475Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxr000t1w2e8u5rg5ae","content":"<h1 id=\"Java多线程-AQS详解\"><a href=\"#Java多线程-AQS详解\" class=\"headerlink\" title=\"Java多线程 - AQS详解\"></a>Java多线程 - AQS详解</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>AQS是java.util.concurrent.locks下类AbstractQueuedSynchronizer的简称，是用于    通过Java源码来构建多线程的锁和同步器的一系列框架，用于Java多线程之间的同步，它的类及类结构图如下:</p>\n<center><br><img src=\"https://cdn.guohezuzi.cn/public/img/aqs-class.png\" width=\"60%\"><br></center>\n\n<center><br> <img src=\"https://cdn.guohezuzi.cn/public/img/aqs-diagram.png\" width=\"60%\"><br> </center>\n\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>在AQS类中维护了一个使用双向链表Node实现的FIFO队列，用于保存等待的线程，同时利用一个int类型的state来表示状态，使用时通过继承AQS类并实现它的acquire和release方法来操作状态，来实现线程的同步。</p>\n<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>\n<p>再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p>\n<h2 id=\"不同组件的使用\"><a href=\"#不同组件的使用\" class=\"headerlink\" title=\"不同组件的使用\"></a>不同组件的使用</h2><h3 id=\"CountDownLatch\"><a href=\"#CountDownLatch\" class=\"headerlink\" title=\"CountDownLatch\"></a>CountDownLatch</h3><p>主要用于等待线程等待其他线程执行后再执行，其实现是通过控制计数器是否递减到0来判别，其他的每一个线程执行完毕后，调用countDown()方法让计数器减一，等待线程调用await()方法，直到计数器为1在执行。</p>\n<p>demo 主线程等待200个线程执行完毕后再执行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.CountDownLatch;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutorService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Created with IntelliJ IDEA.</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* <span class=\"doctag\">@author</span>: guohezuzi</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Date: 2019-06-08</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Time: 下午4:14</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Description: ContDownLatch用法：通过引入CountDownLatch计数器,来等待其他线程执行完毕</span></span><br><span class=\"line\"><span class=\"comment\"> * \\</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CountDownLatchExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> threadCount = <span class=\"number\">200</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> threadNum)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">        log.info(<span class=\"string\">\"&#123;&#125;\"</span>,threadNum);</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        ExecutorService pool= Executors.newCachedThreadPool();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> CountDownLatch countDownLatch=<span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">200</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadNum=i;</span><br><span class=\"line\">            pool.execute(()-&gt;&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">                    test(threadNum);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">                    log.error(<span class=\"string\">\"exception\"</span>,e);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    countDownLatch.countDown();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        countDownLatch.await();</span><br><span class=\"line\">        log.info(<span class=\"string\">\"finish\"</span>);</span><br><span class=\"line\">        pool.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"CyclicBarrier\"><a href=\"#CyclicBarrier\" class=\"headerlink\" title=\"CyclicBarrier\"></a>CyclicBarrier</h3><p>用于等待多个线程都准备好再进行，每一个线程准备好后，计数器加1，加到指定值后全部开始</p>\n<p>demo 一个20个线程每等待5个线程进行一次</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Created with IntelliJ IDEA.</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* <span class=\"doctag\">@author</span>: guohezuzi</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Date: 2019-06-08</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Time: 下午5:20</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Description:</span></span><br><span class=\"line\"><span class=\"comment\"> * 用于等待多个线程都准备好</span></span><br><span class=\"line\"><span class=\"comment\"> * 每一个线程准备好后 计数器加1 加到指定值后全部开始</span></span><br><span class=\"line\"><span class=\"comment\"> * \\</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CyclicBarrierExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(CountDownLatchExample<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> CyclicBarrier cyclicBarrier=<span class=\"keyword\">new</span> CyclicBarrier(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">race</span><span class=\"params\">(<span class=\"keyword\">int</span> threadNum)</span> <span class=\"keyword\">throws</span> InterruptedException</span>&#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"&#123;&#125; is ready\"</span>,threadNum);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//等待指定数量的其他线程执行 无参一直等待不抛异常 有参数表示等待指定时间若数量还未等到抛出异常</span></span><br><span class=\"line\">            cyclicBarrier.await(<span class=\"number\">2000</span>, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException | TimeoutException e) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"exception\"</span>,e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"&#123;&#125; is continue\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        ExecutorService executorService= Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadNum=i;</span><br><span class=\"line\">            executorService.execute(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    race(threadNum);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    logger.error(<span class=\"string\">\"exception\"</span>,e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        executorService.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h3><p>英译信号量，用于控制某个资源同时可被访问的个数，如控制数据库资源可以同时并发数量为20</p>\n<p>demo:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Created with IntelliJ IDEA.</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* <span class=\"doctag\">@author</span>: guohezuzi</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Date: 2019-06-08</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Time: 下午3:39</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Description: 信号量学习例子 控制某个资源同时可被访问的个数 如控制数据库资源可以同时并发数量为20</span></span><br><span class=\"line\"><span class=\"comment\"> * \\</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SemaphoreExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(CountDownLatchExample<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> threadCount = <span class=\"number\">200</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> threadNum)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"&#123;&#125;\"</span>,threadNum);</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        ExecutorService pool= Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"comment\">//定义允许并发的信号量m</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Semaphore semaphore=<span class=\"keyword\">new</span> Semaphore(<span class=\"number\">20</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadNum=i;</span><br><span class=\"line\">            <span class=\"comment\">//该线程的最大并发数为m/n</span></span><br><span class=\"line\">            pool.execute(()-&gt;&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//获取n个信号量 无参为一个</span></span><br><span class=\"line\">                    semaphore.acquire(<span class=\"number\">4</span>);</span><br><span class=\"line\">                    test(threadNum);</span><br><span class=\"line\">                    <span class=\"comment\">//释放n个信号量 无参为一个</span></span><br><span class=\"line\">                    semaphore.release(<span class=\"number\">4</span>);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">                    logger.error(<span class=\"string\">\"exception\"</span>,e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pool.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ReentrantReadWriteLock\"><a href=\"#ReentrantReadWriteLock\" class=\"headerlink\" title=\"ReentrantReadWriteLock\"></a>ReentrantReadWriteLock</h3><p>读写锁，用于需要同步资源时在前后加锁/解锁，当一个线程获取读锁后其他线程可以继续获取读锁，当一个线程获取写锁后其他线程都需等待，因此，可能造成写锁饥饿，就是写锁一直无法获取。</p>\n<p>demo: 一个基于aqs锁实现的部分线程安全的map</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.TreeMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.Lock;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Created with IntelliJ IDEA.</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* <span class=\"doctag\">@author</span>: guohezuzi</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Date: 2019-06-08</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Time: 下午11:58</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Description: 读写锁 当一个线程获取读锁后其他线程可以继续获取读锁 当一个线程获取写锁后其他线程都需等待</span></span><br><span class=\"line\"><span class=\"comment\"> * \\</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReentrantReadWriteLockExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Map&lt;String, Data&gt; map = <span class=\"keyword\">new</span> TreeMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReentrantReadWriteLock readWriteLock = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock readLock = readWriteLock.readLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock writeLock = readWriteLock.writeLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Data <span class=\"title\">get</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        readLock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> map.get(key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            readLock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title\">getAllkeys</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        readLock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> map.keySet();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            readLock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Data <span class=\"title\">put</span><span class=\"params\">(String key, Data vlaue)</span> </span>&#123;</span><br><span class=\"line\">        writeLock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> map.put(key, vlaue);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            writeLock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Data</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"StampLock\"><a href=\"#StampLock\" class=\"headerlink\" title=\"StampLock\"></a>StampLock</h3><p>类似读写锁的功能和使用方法，不过有以下两点不同</p>\n<ol>\n<li><p>每次获取锁会得到一个long类型的stamp所为返回值，解锁是需要将其回传。</p>\n</li>\n<li><p>有乐观读操作，适合于读多写少情况，指当资源被读锁锁定时，会根据资源是否被变更，进行读取操作，而不是不允许读操作。</p>\n</li>\n</ol>\n<p>demo:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.StampedLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Created with IntelliJ IDEA.</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* <span class=\"doctag\">@author</span>: guohezuzi</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Date: 2019-06-09</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Time: 下午1:08</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Description:</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用是每次获取锁会得到一个long类型的stamp所为返回值，解锁是需要将其回传</span></span><br><span class=\"line\"><span class=\"comment\"> * 该类有 写 读 乐观读：指当资源被读锁锁定时，会根据资源是否被变更，进行读取操作</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StampLockExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StampedLock lock = <span class=\"keyword\">new</span> StampedLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AddHundredNum</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//            synchronized (addHundredNum.class) &#123;</span></span><br><span class=\"line\">            <span class=\"keyword\">long</span> stamp = lock.writeLock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                lock.unlock(stamp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"><span class=\"comment\">//            &#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        StampLockExample.AddHundredNum[] addHundredNums = <span class=\"keyword\">new</span> StampLockExample.AddHundredNum[<span class=\"number\">100</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; addHundredNums.length; i++) &#123;</span><br><span class=\"line\">            addHundredNums[i] = <span class=\"keyword\">new</span> StampLockExample.AddHundredNum();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (StampLockExample.AddHundredNum addHundredNum : addHundredNums) &#123;</span><br><span class=\"line\">            addHundredNum.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (StampLockExample.AddHundredNum addHundredNum : addHundredNums) &#123;</span><br><span class=\"line\">            addHundredNum.join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        StampLockExample example = <span class=\"keyword\">new</span> StampLockExample();</span><br><span class=\"line\">        example.test();</span><br><span class=\"line\">        System.out.println(example.count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Condition\"><a href=\"#Condition\" class=\"headerlink\" title=\"Condition\"></a>Condition</h3><p>配合AQS锁实现的线程中断/等待机制，将等待的线程移入condition维护的队列，并通过condition控制中断/等待。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.Condition;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Created with IntelliJ IDEA.</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* <span class=\"doctag\">@author</span>: guohezuzi</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Date: 2019-06-09</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Time: 下午1:26</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Description:</span></span><br><span class=\"line\"><span class=\"comment\"> * \\</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConditionExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock lock=<span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">        Condition condition=lock.newCondition();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            log.info(<span class=\"string\">\"wait signal\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                condition.await();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            log.info(<span class=\"string\">\"get signal\"</span>);</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            log.info(<span class=\"string\">\"get lock\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            condition.signalAll();</span><br><span class=\"line\">            log.info(<span class=\"string\">\"send signal ~\"</span>);</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>### </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java多线程-AQS详解\"><a href=\"#Java多线程-AQS详解\" class=\"headerlink\" title=\"Java多线程 - AQS详解\"></a>Java多线程 - AQS详解</h1><h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>AQS是java.util.concurrent.locks下类AbstractQueuedSynchronizer的简称，是用于    通过Java源码来构建多线程的锁和同步器的一系列框架，用于Java多线程之间的同步，它的类及类结构图如下:</p>\n<center><br><img src=\"https://cdn.guohezuzi.cn/public/img/aqs-class.png\" width=\"60%\"><br></center>\n\n<center><br> <img src=\"https://cdn.guohezuzi.cn/public/img/aqs-diagram.png\" width=\"60%\"><br> </center>\n\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>在AQS类中维护了一个使用双向链表Node实现的FIFO队列，用于保存等待的线程，同时利用一个int类型的state来表示状态，使用时通过继承AQS类并实现它的acquire和release方法来操作状态，来实现线程的同步。</p>\n<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>\n<p>再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p>\n<h2 id=\"不同组件的使用\"><a href=\"#不同组件的使用\" class=\"headerlink\" title=\"不同组件的使用\"></a>不同组件的使用</h2><h3 id=\"CountDownLatch\"><a href=\"#CountDownLatch\" class=\"headerlink\" title=\"CountDownLatch\"></a>CountDownLatch</h3><p>主要用于等待线程等待其他线程执行后再执行，其实现是通过控制计数器是否递减到0来判别，其他的每一个线程执行完毕后，调用countDown()方法让计数器减一，等待线程调用await()方法，直到计数器为1在执行。</p>\n<p>demo 主线程等待200个线程执行完毕后再执行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.CountDownLatch;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.ExecutorService;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.Executors;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Created with IntelliJ IDEA.</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* <span class=\"doctag\">@author</span>: guohezuzi</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Date: 2019-06-08</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Time: 下午4:14</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Description: ContDownLatch用法：通过引入CountDownLatch计数器,来等待其他线程执行完毕</span></span><br><span class=\"line\"><span class=\"comment\"> * \\</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CountDownLatchExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> threadCount = <span class=\"number\">200</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> threadNum)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">        log.info(<span class=\"string\">\"&#123;&#125;\"</span>,threadNum);</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        ExecutorService pool= Executors.newCachedThreadPool();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> CountDownLatch countDownLatch=<span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">200</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadNum=i;</span><br><span class=\"line\">            pool.execute(()-&gt;&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">                    test(threadNum);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">                    log.error(<span class=\"string\">\"exception\"</span>,e);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    countDownLatch.countDown();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        countDownLatch.await();</span><br><span class=\"line\">        log.info(<span class=\"string\">\"finish\"</span>);</span><br><span class=\"line\">        pool.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"CyclicBarrier\"><a href=\"#CyclicBarrier\" class=\"headerlink\" title=\"CyclicBarrier\"></a>CyclicBarrier</h3><p>用于等待多个线程都准备好再进行，每一个线程准备好后，计数器加1，加到指定值后全部开始</p>\n<p>demo 一个20个线程每等待5个线程进行一次</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Created with IntelliJ IDEA.</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* <span class=\"doctag\">@author</span>: guohezuzi</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Date: 2019-06-08</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Time: 下午5:20</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Description:</span></span><br><span class=\"line\"><span class=\"comment\"> * 用于等待多个线程都准备好</span></span><br><span class=\"line\"><span class=\"comment\"> * 每一个线程准备好后 计数器加1 加到指定值后全部开始</span></span><br><span class=\"line\"><span class=\"comment\"> * \\</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CyclicBarrierExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(CountDownLatchExample<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> CyclicBarrier cyclicBarrier=<span class=\"keyword\">new</span> CyclicBarrier(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">race</span><span class=\"params\">(<span class=\"keyword\">int</span> threadNum)</span> <span class=\"keyword\">throws</span> InterruptedException</span>&#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"&#123;&#125; is ready\"</span>,threadNum);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//等待指定数量的其他线程执行 无参一直等待不抛异常 有参数表示等待指定时间若数量还未等到抛出异常</span></span><br><span class=\"line\">            cyclicBarrier.await(<span class=\"number\">2000</span>, TimeUnit.MILLISECONDS);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException | TimeoutException e) &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">\"exception\"</span>,e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"&#123;&#125; is continue\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        ExecutorService executorService= Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadNum=i;</span><br><span class=\"line\">            executorService.execute(() -&gt; &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    race(threadNum);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    logger.error(<span class=\"string\">\"exception\"</span>,e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        executorService.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Semaphore\"><a href=\"#Semaphore\" class=\"headerlink\" title=\"Semaphore\"></a>Semaphore</h3><p>英译信号量，用于控制某个资源同时可被访问的个数，如控制数据库资源可以同时并发数量为20</p>\n<p>demo:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Created with IntelliJ IDEA.</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* <span class=\"doctag\">@author</span>: guohezuzi</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Date: 2019-06-08</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Time: 下午3:39</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Description: 信号量学习例子 控制某个资源同时可被访问的个数 如控制数据库资源可以同时并发数量为20</span></span><br><span class=\"line\"><span class=\"comment\"> * \\</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SemaphoreExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(CountDownLatchExample<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> threadCount = <span class=\"number\">200</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> threadNum)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">        logger.info(<span class=\"string\">\"&#123;&#125;\"</span>,threadNum);</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        ExecutorService pool= Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"comment\">//定义允许并发的信号量m</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Semaphore semaphore=<span class=\"keyword\">new</span> Semaphore(<span class=\"number\">20</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> threadNum=i;</span><br><span class=\"line\">            <span class=\"comment\">//该线程的最大并发数为m/n</span></span><br><span class=\"line\">            pool.execute(()-&gt;&#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//获取n个信号量 无参为一个</span></span><br><span class=\"line\">                    semaphore.acquire(<span class=\"number\">4</span>);</span><br><span class=\"line\">                    test(threadNum);</span><br><span class=\"line\">                    <span class=\"comment\">//释放n个信号量 无参为一个</span></span><br><span class=\"line\">                    semaphore.release(<span class=\"number\">4</span>);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">                    logger.error(<span class=\"string\">\"exception\"</span>,e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pool.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ReentrantReadWriteLock\"><a href=\"#ReentrantReadWriteLock\" class=\"headerlink\" title=\"ReentrantReadWriteLock\"></a>ReentrantReadWriteLock</h3><p>读写锁，用于需要同步资源时在前后加锁/解锁，当一个线程获取读锁后其他线程可以继续获取读锁，当一个线程获取写锁后其他线程都需等待，因此，可能造成写锁饥饿，就是写锁一直无法获取。</p>\n<p>demo: 一个基于aqs锁实现的部分线程安全的map</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.TreeMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.Lock;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Created with IntelliJ IDEA.</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* <span class=\"doctag\">@author</span>: guohezuzi</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Date: 2019-06-08</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Time: 下午11:58</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Description: 读写锁 当一个线程获取读锁后其他线程可以继续获取读锁 当一个线程获取写锁后其他线程都需等待</span></span><br><span class=\"line\"><span class=\"comment\"> * \\</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReentrantReadWriteLockExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Map&lt;String, Data&gt; map = <span class=\"keyword\">new</span> TreeMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> ReentrantLock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReentrantReadWriteLock readWriteLock = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock readLock = readWriteLock.readLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock writeLock = readWriteLock.writeLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Data <span class=\"title\">get</span><span class=\"params\">(String key)</span> </span>&#123;</span><br><span class=\"line\">        readLock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> map.get(key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            readLock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title\">getAllkeys</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        readLock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> map.keySet();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            readLock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Data <span class=\"title\">put</span><span class=\"params\">(String key, Data vlaue)</span> </span>&#123;</span><br><span class=\"line\">        writeLock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> map.put(key, vlaue);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            writeLock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Data</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"StampLock\"><a href=\"#StampLock\" class=\"headerlink\" title=\"StampLock\"></a>StampLock</h3><p>类似读写锁的功能和使用方法，不过有以下两点不同</p>\n<ol>\n<li><p>每次获取锁会得到一个long类型的stamp所为返回值，解锁是需要将其回传。</p>\n</li>\n<li><p>有乐观读操作，适合于读多写少情况，指当资源被读锁锁定时，会根据资源是否被变更，进行读取操作，而不是不允许读操作。</p>\n</li>\n</ol>\n<p>demo:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.StampedLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Created with IntelliJ IDEA.</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* <span class=\"doctag\">@author</span>: guohezuzi</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Date: 2019-06-09</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Time: 下午1:08</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Description:</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用是每次获取锁会得到一个long类型的stamp所为返回值，解锁是需要将其回传</span></span><br><span class=\"line\"><span class=\"comment\"> * 该类有 写 读 乐观读：指当资源被读锁锁定时，会根据资源是否被变更，进行读取操作</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StampLockExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StampedLock lock = <span class=\"keyword\">new</span> StampedLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AddHundredNum</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//            synchronized (addHundredNum.class) &#123;</span></span><br><span class=\"line\">            <span class=\"keyword\">long</span> stamp = lock.writeLock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                lock.unlock(stamp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"><span class=\"comment\">//            &#125;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        StampLockExample.AddHundredNum[] addHundredNums = <span class=\"keyword\">new</span> StampLockExample.AddHundredNum[<span class=\"number\">100</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; addHundredNums.length; i++) &#123;</span><br><span class=\"line\">            addHundredNums[i] = <span class=\"keyword\">new</span> StampLockExample.AddHundredNum();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (StampLockExample.AddHundredNum addHundredNum : addHundredNums) &#123;</span><br><span class=\"line\">            addHundredNum.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (StampLockExample.AddHundredNum addHundredNum : addHundredNums) &#123;</span><br><span class=\"line\">            addHundredNum.join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        StampLockExample example = <span class=\"keyword\">new</span> StampLockExample();</span><br><span class=\"line\">        example.test();</span><br><span class=\"line\">        System.out.println(example.count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Condition\"><a href=\"#Condition\" class=\"headerlink\" title=\"Condition\"></a>Condition</h3><p>配合AQS锁实现的线程中断/等待机制，将等待的线程移入condition维护的队列，并通过condition控制中断/等待。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.Condition;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Created with IntelliJ IDEA.</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* <span class=\"doctag\">@author</span>: guohezuzi</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Date: 2019-06-09</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Time: 下午1:26</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Description:</span></span><br><span class=\"line\"><span class=\"comment\"> * \\</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConditionExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> ReentrantLock lock=<span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">        Condition condition=lock.newCondition();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            log.info(<span class=\"string\">\"wait signal\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                condition.await();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            log.info(<span class=\"string\">\"get signal\"</span>);</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            log.info(<span class=\"string\">\"get lock\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            condition.signalAll();</span><br><span class=\"line\">            log.info(<span class=\"string\">\"send signal ~\"</span>);</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>### </p>\n"},{"title":"Java多线程-线程安全的单例模式的实现","date":"2019-06-08T09:19:04.000Z","_content":"\n# Java多线程-线程安全的单例模式的实现\n\n## 加锁的实现\n\n### 简易版\n\n直接加锁无判断来同步类的创建\n\n```java\npublic class Singleton0 {\n    private Singleton0(){}\n    private static Singleton0 instance;\n    public static Singleton0 getInstance(){\n        synchronized (Singleton0.class){\n            if (instance!=null){\n                instance=new Singleton0();\n            }\n        }\n        return instance;\n    }\n}\n```\n\n缺点：在多个线程调用`getInstance`方法时，都会加锁后判断，效率低，时间较长。\n\n### 进阶版\n\n在进行同步之前，会对是否对象已经创建进行判断，减少`syschronized`过程\n\n```java\npublic class Singleton1 {\n    private volatile static Singleton1 uniqueInstance;\n    private Singleton1() { }\n    public static Singleton1 getInstance() {\n        if (uniqueInstance == null) {\n            synchronized(Singleton0.class) {\n                if (uniqueInstance == null) {\n                    uniqueInstance = new Singleton1();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n}\n```\n\n##### 为什么uniqueInstance变量要用volatele关键字？\n\n防止new对象时，发生指令重排\n\nuniqueInstance = new Singleton(); 这段代码其实是分为三步执行：\n\n1. 为 uniqueInstance 分配内存空间\n2. 初始化 uniqueInstance\n3. 将 uniqueInstance 指向分配的内存地址\n\n但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。\n\n使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。\n\n## 利用final关键字的实现\n\nfinal关键字限制了实例对象的唯一\n\n```java\npublic class Singleton {\n    private Singleton(){}\n    private static final Singleton INSTANSE =new Singleton();\n    public static Singleton getInstance() {\n        return INSTANSE;\n    }\n}\n```\n\n## 利用final+静态内部类实现\n\n优点：\n\n1. 通过内部类，实现更好的封装\n2. 在一定程度上实现了懒加载，当外部类加载时，内部类不会加载，不过一般我们在使用，不会加载外部类，而是直接调用`getInstance`方法\n\n```java\npublic class Singleton {\n    private Singleton (){}\n    public static Singleton getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n\n    private static class SingletonHolder {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n\n}\n```\n","source":"_posts/多线程/Java多线程-单例模式的实现.md","raw":"---\ntitle: Java多线程-线程安全的单例模式的实现\ndate: 2019-06-08 17:19:04\ntags:\n---\n\n# Java多线程-线程安全的单例模式的实现\n\n## 加锁的实现\n\n### 简易版\n\n直接加锁无判断来同步类的创建\n\n```java\npublic class Singleton0 {\n    private Singleton0(){}\n    private static Singleton0 instance;\n    public static Singleton0 getInstance(){\n        synchronized (Singleton0.class){\n            if (instance!=null){\n                instance=new Singleton0();\n            }\n        }\n        return instance;\n    }\n}\n```\n\n缺点：在多个线程调用`getInstance`方法时，都会加锁后判断，效率低，时间较长。\n\n### 进阶版\n\n在进行同步之前，会对是否对象已经创建进行判断，减少`syschronized`过程\n\n```java\npublic class Singleton1 {\n    private volatile static Singleton1 uniqueInstance;\n    private Singleton1() { }\n    public static Singleton1 getInstance() {\n        if (uniqueInstance == null) {\n            synchronized(Singleton0.class) {\n                if (uniqueInstance == null) {\n                    uniqueInstance = new Singleton1();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n}\n```\n\n##### 为什么uniqueInstance变量要用volatele关键字？\n\n防止new对象时，发生指令重排\n\nuniqueInstance = new Singleton(); 这段代码其实是分为三步执行：\n\n1. 为 uniqueInstance 分配内存空间\n2. 初始化 uniqueInstance\n3. 将 uniqueInstance 指向分配的内存地址\n\n但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。\n\n使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。\n\n## 利用final关键字的实现\n\nfinal关键字限制了实例对象的唯一\n\n```java\npublic class Singleton {\n    private Singleton(){}\n    private static final Singleton INSTANSE =new Singleton();\n    public static Singleton getInstance() {\n        return INSTANSE;\n    }\n}\n```\n\n## 利用final+静态内部类实现\n\n优点：\n\n1. 通过内部类，实现更好的封装\n2. 在一定程度上实现了懒加载，当外部类加载时，内部类不会加载，不过一般我们在使用，不会加载外部类，而是直接调用`getInstance`方法\n\n```java\npublic class Singleton {\n    private Singleton (){}\n    public static Singleton getInstance() {\n        return SingletonHolder.INSTANCE;\n    }\n\n    private static class SingletonHolder {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n\n}\n```\n","slug":"多线程/Java多线程-单例模式的实现","published":1,"updated":"2019-11-13T10:09:11.271Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxs000u1w2e0ub9qhqg","content":"<h1 id=\"Java多线程-线程安全的单例模式的实现\"><a href=\"#Java多线程-线程安全的单例模式的实现\" class=\"headerlink\" title=\"Java多线程-线程安全的单例模式的实现\"></a>Java多线程-线程安全的单例模式的实现</h1><h2 id=\"加锁的实现\"><a href=\"#加锁的实现\" class=\"headerlink\" title=\"加锁的实现\"></a>加锁的实现</h2><h3 id=\"简易版\"><a href=\"#简易版\" class=\"headerlink\" title=\"简易版\"></a>简易版</h3><p>直接加锁无判断来同步类的创建</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton0</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton0</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton0 instance;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton0 <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton0<span class=\"class\">.<span class=\"keyword\">class</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (instance!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                instance=<span class=\"keyword\">new</span> Singleton0();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缺点：在多个线程调用<code>getInstance</code>方法时，都会加锁后判断，效率低，时间较长。</p>\n<h3 id=\"进阶版\"><a href=\"#进阶版\" class=\"headerlink\" title=\"进阶版\"></a>进阶版</h3><p>在进行同步之前，会对是否对象已经创建进行判断，减少<code>syschronized</code>过程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton1 uniqueInstance;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton1</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton1 <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span>(Singleton0<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    uniqueInstance = <span class=\"keyword\">new</span> Singleton1();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uniqueInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"为什么uniqueInstance变量要用volatele关键字？\"><a href=\"#为什么uniqueInstance变量要用volatele关键字？\" class=\"headerlink\" title=\"为什么uniqueInstance变量要用volatele关键字？\"></a>为什么uniqueInstance变量要用volatele关键字？</h5><p>防止new对象时，发生指令重排</p>\n<p>uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</p>\n<ol>\n<li>为 uniqueInstance 分配内存空间</li>\n<li>初始化 uniqueInstance</li>\n<li>将 uniqueInstance 指向分配的内存地址</li>\n</ol>\n<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p>\n<p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>\n<h2 id=\"利用final关键字的实现\"><a href=\"#利用final关键字的实现\" class=\"headerlink\" title=\"利用final关键字的实现\"></a>利用final关键字的实现</h2><p>final关键字限制了实例对象的唯一</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANSE =<span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> INSTANSE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"利用final-静态内部类实现\"><a href=\"#利用final-静态内部类实现\" class=\"headerlink\" title=\"利用final+静态内部类实现\"></a>利用final+静态内部类实现</h2><p>优点：</p>\n<ol>\n<li>通过内部类，实现更好的封装</li>\n<li>在一定程度上实现了懒加载，当外部类加载时，内部类不会加载，不过一般我们在使用，不会加载外部类，而是直接调用<code>getInstance</code>方法</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java多线程-线程安全的单例模式的实现\"><a href=\"#Java多线程-线程安全的单例模式的实现\" class=\"headerlink\" title=\"Java多线程-线程安全的单例模式的实现\"></a>Java多线程-线程安全的单例模式的实现</h1><h2 id=\"加锁的实现\"><a href=\"#加锁的实现\" class=\"headerlink\" title=\"加锁的实现\"></a>加锁的实现</h2><h3 id=\"简易版\"><a href=\"#简易版\" class=\"headerlink\" title=\"简易版\"></a>简易版</h3><p>直接加锁无判断来同步类的创建</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton0</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton0</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton0 instance;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton0 <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton0<span class=\"class\">.<span class=\"keyword\">class</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (instance!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                instance=<span class=\"keyword\">new</span> Singleton0();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缺点：在多个线程调用<code>getInstance</code>方法时，都会加锁后判断，效率低，时间较长。</p>\n<h3 id=\"进阶版\"><a href=\"#进阶版\" class=\"headerlink\" title=\"进阶版\"></a>进阶版</h3><p>在进行同步之前，会对是否对象已经创建进行判断，减少<code>syschronized</code>过程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton1 uniqueInstance;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton1</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton1 <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span>(Singleton0<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    uniqueInstance = <span class=\"keyword\">new</span> Singleton1();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uniqueInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"为什么uniqueInstance变量要用volatele关键字？\"><a href=\"#为什么uniqueInstance变量要用volatele关键字？\" class=\"headerlink\" title=\"为什么uniqueInstance变量要用volatele关键字？\"></a>为什么uniqueInstance变量要用volatele关键字？</h5><p>防止new对象时，发生指令重排</p>\n<p>uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</p>\n<ol>\n<li>为 uniqueInstance 分配内存空间</li>\n<li>初始化 uniqueInstance</li>\n<li>将 uniqueInstance 指向分配的内存地址</li>\n</ol>\n<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p>\n<p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>\n<h2 id=\"利用final关键字的实现\"><a href=\"#利用final关键字的实现\" class=\"headerlink\" title=\"利用final关键字的实现\"></a>利用final关键字的实现</h2><p>final关键字限制了实例对象的唯一</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANSE =<span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> INSTANSE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"利用final-静态内部类实现\"><a href=\"#利用final-静态内部类实现\" class=\"headerlink\" title=\"利用final+静态内部类实现\"></a>利用final+静态内部类实现</h2><p>优点：</p>\n<ol>\n<li>通过内部类，实现更好的封装</li>\n<li>在一定程度上实现了懒加载，当外部类加载时，内部类不会加载，不过一般我们在使用，不会加载外部类，而是直接调用<code>getInstance</code>方法</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span> <span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonHolder.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Java多线程 - 从JVM角度理解多线程","date":"2019-06-05T09:19:04.000Z","_content":"\n# Java多线程 - 从JVM角度理解多线程\n\n在JVM中，多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**\n\n<center>\n\n<img src=\"https://cdn.guohezuzi.cn/public/img/jvm.png\" width=\"80%\" />\n\n</center>\n\n### 什么是堆\n\nJava虚拟机所管理的内存中最大的一块，java堆是所有线程共享到的一块内存区域，在虚拟机启动时创建，**用于存放对象实例，几乎所有的对象实例以及数组都在这里分配内存**。\n\nJava 堆是垃圾收集器管理的主要区域，因此也被称作**GC 堆（Garbage Collected Heap）**.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**\n\n<center>\n\n<img src=\"https://cdn.guohezuzi.cn/public/img/javaHeap.png\" width=\"80%\" />\n\n</center>\n\n上图所示的 eden 区、s0 区、s1 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。\n\n### 什么是方法区\n\n在JDK1.8之前,方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\n\n同时运行时常量池也是方法区的一部分。已知，运用在string赋值时(非new)，以及包装类**Byte,Short,Integer,Long,Character,Boolean**在-128~127范围内赋值时都是使用常量池\n\n在JDK1.8之后,方法区发生了改变,常量池移进了堆中,使用 元空间(MetaSpace)来保存类加载之后的类信息,元空间并不存在jvm内存中,而是在系统的直接内存中(Native Head)\n\n### 什么是虚拟机栈\n\n**Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。** （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）\n\n**局部变量表主要存放了编译器可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。\n\n### 什么是本地方法栈\n\n和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。\n\n本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。\n\n### 什么是程序计数器\n\n程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。**\n\n另外，**为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。**\n\n## Ref:\n\n1. [可能是把Java内存区域讲的最清楚的一篇文章](https://juejin.im/post/5b7d69e4e51d4538ca5730cb)\n","source":"_posts/多线程/Java多线程 - 从JVM角度理解多线程.md","raw":"---\ntitle: Java多线程 - 从JVM角度理解多线程\ndate: 2019-06-05 17:19:04\ntags:\n---\n\n# Java多线程 - 从JVM角度理解多线程\n\n在JVM中，多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**\n\n<center>\n\n<img src=\"https://cdn.guohezuzi.cn/public/img/jvm.png\" width=\"80%\" />\n\n</center>\n\n### 什么是堆\n\nJava虚拟机所管理的内存中最大的一块，java堆是所有线程共享到的一块内存区域，在虚拟机启动时创建，**用于存放对象实例，几乎所有的对象实例以及数组都在这里分配内存**。\n\nJava 堆是垃圾收集器管理的主要区域，因此也被称作**GC 堆（Garbage Collected Heap）**.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**\n\n<center>\n\n<img src=\"https://cdn.guohezuzi.cn/public/img/javaHeap.png\" width=\"80%\" />\n\n</center>\n\n上图所示的 eden 区、s0 区、s1 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。\n\n### 什么是方法区\n\n在JDK1.8之前,方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\n\n同时运行时常量池也是方法区的一部分。已知，运用在string赋值时(非new)，以及包装类**Byte,Short,Integer,Long,Character,Boolean**在-128~127范围内赋值时都是使用常量池\n\n在JDK1.8之后,方法区发生了改变,常量池移进了堆中,使用 元空间(MetaSpace)来保存类加载之后的类信息,元空间并不存在jvm内存中,而是在系统的直接内存中(Native Head)\n\n### 什么是虚拟机栈\n\n**Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。** （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）\n\n**局部变量表主要存放了编译器可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。\n\n### 什么是本地方法栈\n\n和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。\n\n本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。\n\n### 什么是程序计数器\n\n程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。**\n\n另外，**为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。**\n\n## Ref:\n\n1. [可能是把Java内存区域讲的最清楚的一篇文章](https://juejin.im/post/5b7d69e4e51d4538ca5730cb)\n","slug":"多线程/Java多线程 - 从JVM角度理解多线程","published":1,"updated":"2019-11-13T10:05:51.543Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxs000v1w2e5ma2vnei","content":"<h1 id=\"Java多线程-从JVM角度理解多线程\"><a href=\"#Java多线程-从JVM角度理解多线程\" class=\"headerlink\" title=\"Java多线程 - 从JVM角度理解多线程\"></a>Java多线程 - 从JVM角度理解多线程</h1><p>在JVM中，多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong></p>\n<center><br><br><img src=\"https://cdn.guohezuzi.cn/public/img/jvm.png\" width=\"80%\"><br><br></center>\n\n<h3 id=\"什么是堆\"><a href=\"#什么是堆\" class=\"headerlink\" title=\"什么是堆\"></a>什么是堆</h3><p>Java虚拟机所管理的内存中最大的一块，java堆是所有线程共享到的一块内存区域，在虚拟机启动时创建，<strong>用于存放对象实例，几乎所有的对象实例以及数组都在这里分配内存</strong>。</p>\n<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>\n<center><br><br><img src=\"https://cdn.guohezuzi.cn/public/img/javaHeap.png\" width=\"80%\"><br><br></center>\n\n<p>上图所示的 eden 区、s0 区、s1 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>\n<h3 id=\"什么是方法区\"><a href=\"#什么是方法区\" class=\"headerlink\" title=\"什么是方法区\"></a>什么是方法区</h3><p>在JDK1.8之前,方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>\n<p>同时运行时常量池也是方法区的一部分。已知，运用在string赋值时(非new)，以及包装类<strong>Byte,Short,Integer,Long,Character,Boolean</strong>在-128~127范围内赋值时都是使用常量池</p>\n<p>在JDK1.8之后,方法区发生了改变,常量池移进了堆中,使用 元空间(MetaSpace)来保存类加载之后的类信息,元空间并不存在jvm内存中,而是在系统的直接内存中(Native Head)</p>\n<h3 id=\"什么是虚拟机栈\"><a href=\"#什么是虚拟机栈\" class=\"headerlink\" title=\"什么是虚拟机栈\"></a>什么是虚拟机栈</h3><p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p>\n<p><strong>局部变量表主要存放了编译器可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>\n<h3 id=\"什么是本地方法栈\"><a href=\"#什么是本地方法栈\" class=\"headerlink\" title=\"什么是本地方法栈\"></a>什么是本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>\n<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>\n<h3 id=\"什么是程序计数器\"><a href=\"#什么是程序计数器\" class=\"headerlink\" title=\"什么是程序计数器\"></a>什么是程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。</strong></p>\n<p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref:\"></a>Ref:</h2><ol>\n<li><a href=\"https://juejin.im/post/5b7d69e4e51d4538ca5730cb\" target=\"_blank\" rel=\"noopener\">可能是把Java内存区域讲的最清楚的一篇文章</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java多线程-从JVM角度理解多线程\"><a href=\"#Java多线程-从JVM角度理解多线程\" class=\"headerlink\" title=\"Java多线程 - 从JVM角度理解多线程\"></a>Java多线程 - 从JVM角度理解多线程</h1><p>在JVM中，多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong></p>\n<center><br><br><img src=\"https://cdn.guohezuzi.cn/public/img/jvm.png\" width=\"80%\"><br><br></center>\n\n<h3 id=\"什么是堆\"><a href=\"#什么是堆\" class=\"headerlink\" title=\"什么是堆\"></a>什么是堆</h3><p>Java虚拟机所管理的内存中最大的一块，java堆是所有线程共享到的一块内存区域，在虚拟机启动时创建，<strong>用于存放对象实例，几乎所有的对象实例以及数组都在这里分配内存</strong>。</p>\n<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>\n<center><br><br><img src=\"https://cdn.guohezuzi.cn/public/img/javaHeap.png\" width=\"80%\"><br><br></center>\n\n<p>上图所示的 eden 区、s0 区、s1 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>\n<h3 id=\"什么是方法区\"><a href=\"#什么是方法区\" class=\"headerlink\" title=\"什么是方法区\"></a>什么是方法区</h3><p>在JDK1.8之前,方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>\n<p>同时运行时常量池也是方法区的一部分。已知，运用在string赋值时(非new)，以及包装类<strong>Byte,Short,Integer,Long,Character,Boolean</strong>在-128~127范围内赋值时都是使用常量池</p>\n<p>在JDK1.8之后,方法区发生了改变,常量池移进了堆中,使用 元空间(MetaSpace)来保存类加载之后的类信息,元空间并不存在jvm内存中,而是在系统的直接内存中(Native Head)</p>\n<h3 id=\"什么是虚拟机栈\"><a href=\"#什么是虚拟机栈\" class=\"headerlink\" title=\"什么是虚拟机栈\"></a>什么是虚拟机栈</h3><p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p>\n<p><strong>局部变量表主要存放了编译器可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>\n<h3 id=\"什么是本地方法栈\"><a href=\"#什么是本地方法栈\" class=\"headerlink\" title=\"什么是本地方法栈\"></a>什么是本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>\n<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>\n<h3 id=\"什么是程序计数器\"><a href=\"#什么是程序计数器\" class=\"headerlink\" title=\"什么是程序计数器\"></a>什么是程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。</strong></p>\n<p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref:\"></a>Ref:</h2><ol>\n<li><a href=\"https://juejin.im/post/5b7d69e4e51d4538ca5730cb\" target=\"_blank\" rel=\"noopener\">可能是把Java内存区域讲的最清楚的一篇文章</a></li>\n</ol>\n"},{"title":"Java多线程 - ThreadLocal详解","date":"2019-06-16T09:19:04.000Z","_content":"\n# Java多线程 - ThreadLocal详解\n\n## 简介\n\nThreadLocal是一个为线程提供线程本地变量的工具类。它的思想也十分简单，就是**为线程提供一个线程私有的变量副本**，这样多个线程都可以随意更改自己线程的变量，不会影响到其他线程。\n\n## 代码实现\n\n### 整体实现\n\nThreadlocal通过一个内部类ThreadLocalMap实现对不同线程中不同值的映射，key为ThreadLocal，value为Object即要保存的对象。其ThreadLocalMap中值的存储，和java中其他map类似，通过定义一个内部类Entry来实现。不过，这里的Entry时一个WeakReference对象，为了防止内存泄露，一旦线程结束，key:Threadlocal对象就变为一个不可达的对象，这个Entry就可以被GC了。\n\n```java\n   public class ThreadLocal<T> {\n        ...省略一些成员变量和方法\n        static class ThreadLocalMap {\n        ...省略一些成员变量和方法\n            static class Entry extends WeakReference<ThreadLocal<?>> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal<?> k, Object v) {\n                super(k);\n                value = v;\n            }\n            ...省略一些成员变量和方法\n        }\n     }    \n\n}\n```\n\n### Get方法\n\n```java\n/**\n     * Returns the value in the current thread's copy of this\n     * thread-local variable.  If the variable has no value for the\n     * current thread, it is first initialized to the value returned\n     * by an invocation of the {@link #initialValue} method.\n     *\n     * @return the current thread's value of this thread-local\n     */\n    public T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null) {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T)e.value;\n                return result;\n            }\n        }\n        return setInitialValue();\n    }    \n```\n\n在这里实现的get方法逻辑还是比较简单的，其中ThreadLocalMap中的get方法和hashmap类似。就是有一点需要注意，`ThreadLocalMap map = getMap(t);`时，是通过在每个Thread中有一个`ThreadLocal.ThreadLocalMap threadLocals = null;`的成员变量，在set时，我们通过该线程的这个成员变量，找到对应的ThreadLocalMap。\n\n### Set方法\n\n```java\n    public void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n```\n\n这里的put方法也和hashmap中类似，注意点看上面get方法的说明就好了。\n\nThreadLocalMap中的set方法:\n\n```java\n   /**\n         * Set the value associated with key.\n         *\n         * @param key the thread local object\n         * @param value the value to be set\n         */\n        private void set(ThreadLocal<?> key, Object value) {\n            Entry[] tab = table;\n            int len = tab.length;\n            int i = key.threadLocalHashCode & (len-1);\n\n            for (Entry e = tab[i];\n                 e != null;\n                 e = tab[i = nextIndex(i, len)]) {\n                ThreadLocal<?> k = e.get();\n\n                if (k == key) {\n                    e.value = value;\n                    return;\n                }\n\n                if (k == null) {\n                    replaceStaleEntry(key, value, i);\n                    return;\n                }\n            }\n\n            tab[i] = new Entry(key, value);\n            int sz = ++size;\n            if (!cleanSomeSlots(i, sz) && sz >= threshold)\n                rehash();\n        }\n```\n\n   其中与hashmap相同都是将map的length设置为2^n，计算hash时，通过`key.threadLocalHashCode & (len-1)`代替取模运算。不同的时，在rehash时threadlocal使用的是**线性探测法**，而hashmap使用的是**链地址法**\n\n```java\n/**\n* Increment i modulo len.\n*/\nprivate static int nextIndex(int i, int len) {\n    return ((i + 1 < len) ? i + 1 : 0);\n}\n```\n\n### Remove方法\n\n```java\npublic void remove() {\n         ThreadLocalMap m = getMap(Thread.currentThread());\n         if (m != null)\n             m.remove(this);\n     }\n```\n\n  threadlocalmap中的remove:\n\n```java\n/**\n * Remove the entry for key.\n */\nprivate void remove(ThreadLocal<?> key) {\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode & (len-1);\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        if (e.get() == key) {\n            e.clear();\n            expungeStaleEntry(i);\n            return;\n        }\n    }\n}\n```\n\n其中主要是会在将需要移除的元素置为空后，会调用`expungeStaleEntry(i);`方法，将需要移除的元素key、value清除之后，对当前位置当做 staleSlot 并调用 `expungeStaleEntry` 方法进行整理 (rehashing) 的操作，清除key为null的Entry。\n\n```java\n/**\n * Expunge a stale entry by rehashing any possibly colliding entries\n * lying between staleSlot and the next null slot.  This also expunges\n * any other stale entries encountered before the trailing null.  See\n * Knuth, Section 6.4\n *\n * @param staleSlot index of slot known to have null key\n * @return the index of the next null slot after staleSlot\n * (all between staleSlot and this slot will have been checked\n * for expunging).\n */\nprivate int expungeStaleEntry(int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n    // expunge entry at staleSlot\n    tab[staleSlot].value = null;\n    tab[staleSlot] = null;\n    size--;\n    // Rehash until we encounter null\n    Entry e;\n    int i;\n    for (i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal<?> k = e.get();\n        if (k == null) {\n            e.value = null;\n            tab[i] = null;\n            size--;\n        } else {\n            int h = k.threadLocalHashCode & (len - 1);\n            if (h != i) {\n                tab[i] = null;\n                // Unlike Knuth 6.4 Algorithm R, we must scan until\n                // null because multiple entries could have been stale.\n                while (tab[h] != null)\n                    h = nextIndex(h, len);\n                tab[h] = e;\n            }\n        }\n    }\n    return i;\n}\n```\n\n#### 拓展-调用remove方法的必要性\n\n总结一下什么时候无用的 Entry 会被清理：\n\n- Thread 结束的时候\n- 插入元素时，发现 staled entry，则会进行替换并清理\n- 插入元素时，`ThreadLocalMap`  的  `size`  达到  `threshold`，并且没有任何 staled entries 的时候，会调用  `rehash`  方法清理并扩容\n- 调用  `ThreadLocalMap`  的  `remove`  方法或`set(null)`  时\n\n尽管不会造成内存泄露，但是可以看到无用的 Entry 只会在以上四种情况下才会被清理，这就可能导致一些 Entry 虽然无用但还占内存的情况。因此，我们在使用完 ThreadLocal 后一定要`remove`一下，保证及时回收掉无用的 Entry。\n\n特别地，当应用线程池的时候，由于线程池的线程一般会复用，Thread 不结束，这时候用完更需要  `remove`  了。\n\n## 具体使用\n\n参考:[ Java多线程 - Spring中的线程安全](https://www.guohezuzi.cn/article/java-multithread-spring)\n\n## Ref\n\n[ 并发编程 | ThreadLocal 源码深入分析](https://www.sczyh30.com/posts/Java/java-concurrent-threadlocal/)\n","source":"_posts/多线程/Java多线程 - ThreadLocal详解.md","raw":"---\ntitle: Java多线程 - ThreadLocal详解\ndate: 2019-06-16 17:19:04\ntags:\n---\n\n# Java多线程 - ThreadLocal详解\n\n## 简介\n\nThreadLocal是一个为线程提供线程本地变量的工具类。它的思想也十分简单，就是**为线程提供一个线程私有的变量副本**，这样多个线程都可以随意更改自己线程的变量，不会影响到其他线程。\n\n## 代码实现\n\n### 整体实现\n\nThreadlocal通过一个内部类ThreadLocalMap实现对不同线程中不同值的映射，key为ThreadLocal，value为Object即要保存的对象。其ThreadLocalMap中值的存储，和java中其他map类似，通过定义一个内部类Entry来实现。不过，这里的Entry时一个WeakReference对象，为了防止内存泄露，一旦线程结束，key:Threadlocal对象就变为一个不可达的对象，这个Entry就可以被GC了。\n\n```java\n   public class ThreadLocal<T> {\n        ...省略一些成员变量和方法\n        static class ThreadLocalMap {\n        ...省略一些成员变量和方法\n            static class Entry extends WeakReference<ThreadLocal<?>> {\n            /** The value associated with this ThreadLocal. */\n            Object value;\n\n            Entry(ThreadLocal<?> k, Object v) {\n                super(k);\n                value = v;\n            }\n            ...省略一些成员变量和方法\n        }\n     }    \n\n}\n```\n\n### Get方法\n\n```java\n/**\n     * Returns the value in the current thread's copy of this\n     * thread-local variable.  If the variable has no value for the\n     * current thread, it is first initialized to the value returned\n     * by an invocation of the {@link #initialValue} method.\n     *\n     * @return the current thread's value of this thread-local\n     */\n    public T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null) {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T)e.value;\n                return result;\n            }\n        }\n        return setInitialValue();\n    }    \n```\n\n在这里实现的get方法逻辑还是比较简单的，其中ThreadLocalMap中的get方法和hashmap类似。就是有一点需要注意，`ThreadLocalMap map = getMap(t);`时，是通过在每个Thread中有一个`ThreadLocal.ThreadLocalMap threadLocals = null;`的成员变量，在set时，我们通过该线程的这个成员变量，找到对应的ThreadLocalMap。\n\n### Set方法\n\n```java\n    public void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n```\n\n这里的put方法也和hashmap中类似，注意点看上面get方法的说明就好了。\n\nThreadLocalMap中的set方法:\n\n```java\n   /**\n         * Set the value associated with key.\n         *\n         * @param key the thread local object\n         * @param value the value to be set\n         */\n        private void set(ThreadLocal<?> key, Object value) {\n            Entry[] tab = table;\n            int len = tab.length;\n            int i = key.threadLocalHashCode & (len-1);\n\n            for (Entry e = tab[i];\n                 e != null;\n                 e = tab[i = nextIndex(i, len)]) {\n                ThreadLocal<?> k = e.get();\n\n                if (k == key) {\n                    e.value = value;\n                    return;\n                }\n\n                if (k == null) {\n                    replaceStaleEntry(key, value, i);\n                    return;\n                }\n            }\n\n            tab[i] = new Entry(key, value);\n            int sz = ++size;\n            if (!cleanSomeSlots(i, sz) && sz >= threshold)\n                rehash();\n        }\n```\n\n   其中与hashmap相同都是将map的length设置为2^n，计算hash时，通过`key.threadLocalHashCode & (len-1)`代替取模运算。不同的时，在rehash时threadlocal使用的是**线性探测法**，而hashmap使用的是**链地址法**\n\n```java\n/**\n* Increment i modulo len.\n*/\nprivate static int nextIndex(int i, int len) {\n    return ((i + 1 < len) ? i + 1 : 0);\n}\n```\n\n### Remove方法\n\n```java\npublic void remove() {\n         ThreadLocalMap m = getMap(Thread.currentThread());\n         if (m != null)\n             m.remove(this);\n     }\n```\n\n  threadlocalmap中的remove:\n\n```java\n/**\n * Remove the entry for key.\n */\nprivate void remove(ThreadLocal<?> key) {\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode & (len-1);\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        if (e.get() == key) {\n            e.clear();\n            expungeStaleEntry(i);\n            return;\n        }\n    }\n}\n```\n\n其中主要是会在将需要移除的元素置为空后，会调用`expungeStaleEntry(i);`方法，将需要移除的元素key、value清除之后，对当前位置当做 staleSlot 并调用 `expungeStaleEntry` 方法进行整理 (rehashing) 的操作，清除key为null的Entry。\n\n```java\n/**\n * Expunge a stale entry by rehashing any possibly colliding entries\n * lying between staleSlot and the next null slot.  This also expunges\n * any other stale entries encountered before the trailing null.  See\n * Knuth, Section 6.4\n *\n * @param staleSlot index of slot known to have null key\n * @return the index of the next null slot after staleSlot\n * (all between staleSlot and this slot will have been checked\n * for expunging).\n */\nprivate int expungeStaleEntry(int staleSlot) {\n    Entry[] tab = table;\n    int len = tab.length;\n    // expunge entry at staleSlot\n    tab[staleSlot].value = null;\n    tab[staleSlot] = null;\n    size--;\n    // Rehash until we encounter null\n    Entry e;\n    int i;\n    for (i = nextIndex(staleSlot, len);\n         (e = tab[i]) != null;\n         i = nextIndex(i, len)) {\n        ThreadLocal<?> k = e.get();\n        if (k == null) {\n            e.value = null;\n            tab[i] = null;\n            size--;\n        } else {\n            int h = k.threadLocalHashCode & (len - 1);\n            if (h != i) {\n                tab[i] = null;\n                // Unlike Knuth 6.4 Algorithm R, we must scan until\n                // null because multiple entries could have been stale.\n                while (tab[h] != null)\n                    h = nextIndex(h, len);\n                tab[h] = e;\n            }\n        }\n    }\n    return i;\n}\n```\n\n#### 拓展-调用remove方法的必要性\n\n总结一下什么时候无用的 Entry 会被清理：\n\n- Thread 结束的时候\n- 插入元素时，发现 staled entry，则会进行替换并清理\n- 插入元素时，`ThreadLocalMap`  的  `size`  达到  `threshold`，并且没有任何 staled entries 的时候，会调用  `rehash`  方法清理并扩容\n- 调用  `ThreadLocalMap`  的  `remove`  方法或`set(null)`  时\n\n尽管不会造成内存泄露，但是可以看到无用的 Entry 只会在以上四种情况下才会被清理，这就可能导致一些 Entry 虽然无用但还占内存的情况。因此，我们在使用完 ThreadLocal 后一定要`remove`一下，保证及时回收掉无用的 Entry。\n\n特别地，当应用线程池的时候，由于线程池的线程一般会复用，Thread 不结束，这时候用完更需要  `remove`  了。\n\n## 具体使用\n\n参考:[ Java多线程 - Spring中的线程安全](https://www.guohezuzi.cn/article/java-multithread-spring)\n\n## Ref\n\n[ 并发编程 | ThreadLocal 源码深入分析](https://www.sczyh30.com/posts/Java/java-concurrent-threadlocal/)\n","slug":"多线程/Java多线程 - ThreadLocal详解","published":1,"updated":"2019-11-13T10:09:11.271Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxt000w1w2e5ye39az2","content":"<h1 id=\"Java多线程-ThreadLocal详解\"><a href=\"#Java多线程-ThreadLocal详解\" class=\"headerlink\" title=\"Java多线程 - ThreadLocal详解\"></a>Java多线程 - ThreadLocal详解</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>ThreadLocal是一个为线程提供线程本地变量的工具类。它的思想也十分简单，就是<strong>为线程提供一个线程私有的变量副本</strong>，这样多个线程都可以随意更改自己线程的变量，不会影响到其他线程。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"整体实现\"><a href=\"#整体实现\" class=\"headerlink\" title=\"整体实现\"></a>整体实现</h3><p>Threadlocal通过一个内部类ThreadLocalMap实现对不同线程中不同值的映射，key为ThreadLocal，value为Object即要保存的对象。其ThreadLocalMap中值的存储，和java中其他map类似，通过定义一个内部类Entry来实现。不过，这里的Entry时一个WeakReference对象，为了防止内存泄露，一旦线程结束，key:Threadlocal对象就变为一个不可达的对象，这个Entry就可以被GC了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadLocal</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">        ...省略一些成员变量和方法</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadLocalMap</span> </span>&#123;</span><br><span class=\"line\">        ...省略一些成员变量和方法</span><br><span class=\"line\">            <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">            Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">                value = v;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ...省略一些成员变量和方法</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     &#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Get方法\"><a href=\"#Get方法\" class=\"headerlink\" title=\"Get方法\"></a>Get方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns the value in the current thread's copy of this</span></span><br><span class=\"line\"><span class=\"comment\">     * thread-local variable.  If the variable has no value for the</span></span><br><span class=\"line\"><span class=\"comment\">     * current thread, it is first initialized to the value returned</span></span><br><span class=\"line\"><span class=\"comment\">     * by an invocation of the &#123;<span class=\"doctag\">@link</span> #initialValue&#125; method.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> the current thread's value of this thread-local</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">                T result = (T)e.value;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在这里实现的get方法逻辑还是比较简单的，其中ThreadLocalMap中的get方法和hashmap类似。就是有一点需要注意，<code>ThreadLocalMap map = getMap(t);</code>时，是通过在每个Thread中有一个<code>ThreadLocal.ThreadLocalMap threadLocals = null;</code>的成员变量，在set时，我们通过该线程的这个成员变量，找到对应的ThreadLocalMap。</p>\n<h3 id=\"Set方法\"><a href=\"#Set方法\" class=\"headerlink\" title=\"Set方法\"></a>Set方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的put方法也和hashmap中类似，注意点看上面get方法的说明就好了。</p>\n<p>ThreadLocalMap中的set方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * Set the value associated with key.</span></span><br><span class=\"line\"><span class=\"comment\">      *</span></span><br><span class=\"line\"><span class=\"comment\">      * <span class=\"doctag\">@param</span> key the thread local object</span></span><br><span class=\"line\"><span class=\"comment\">      * <span class=\"doctag\">@param</span> value the value to be set</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class=\"line\">         Entry[] tab = table;</span><br><span class=\"line\">         <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">         <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (len-<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">for</span> (Entry e = tab[i];</span><br><span class=\"line\">              e != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">              e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">             ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\"></span><br><span class=\"line\">             <span class=\"keyword\">if</span> (k == key) &#123;</span><br><span class=\"line\">                 e.value = value;</span><br><span class=\"line\">                 <span class=\"keyword\">return</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">             <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                 replaceStaleEntry(key, value, i);</span><br><span class=\"line\">                 <span class=\"keyword\">return</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         tab[i] = <span class=\"keyword\">new</span> Entry(key, value);</span><br><span class=\"line\">         <span class=\"keyword\">int</span> sz = ++size;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class=\"line\">             rehash();</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n<p>   其中与hashmap相同都是将map的length设置为2^n，计算hash时，通过<code>key.threadLocalHashCode &amp; (len-1)</code>代替取模运算。不同的时，在rehash时threadlocal使用的是<strong>线性探测法</strong>，而hashmap使用的是<strong>链地址法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Increment i modulo len.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">nextIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((i + <span class=\"number\">1</span> &lt; len) ? i + <span class=\"number\">1</span> : <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Remove方法\"><a href=\"#Remove方法\" class=\"headerlink\" title=\"Remove方法\"></a>Remove方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (m != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">             m.remove(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n<p>  threadlocalmap中的remove:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Remove the entry for key.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (len-<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry e = tab[i];</span><br><span class=\"line\">         e != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.get() == key) &#123;</span><br><span class=\"line\">            e.clear();</span><br><span class=\"line\">            expungeStaleEntry(i);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中主要是会在将需要移除的元素置为空后，会调用<code>expungeStaleEntry(i);</code>方法，将需要移除的元素key、value清除之后，对当前位置当做 staleSlot 并调用 <code>expungeStaleEntry</code> 方法进行整理 (rehashing) 的操作，清除key为null的Entry。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Expunge a stale entry by rehashing any possibly colliding entries</span></span><br><span class=\"line\"><span class=\"comment\"> * lying between staleSlot and the next null slot.  This also expunges</span></span><br><span class=\"line\"><span class=\"comment\"> * any other stale entries encountered before the trailing null.  See</span></span><br><span class=\"line\"><span class=\"comment\"> * Knuth, Section 6.4</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> staleSlot index of slot known to have null key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the index of the next null slot after staleSlot</span></span><br><span class=\"line\"><span class=\"comment\"> * (all between staleSlot and this slot will have been checked</span></span><br><span class=\"line\"><span class=\"comment\"> * for expunging).</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">expungeStaleEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> staleSlot)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"comment\">// expunge entry at staleSlot</span></span><br><span class=\"line\">    tab[staleSlot].value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    tab[staleSlot] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    size--;</span><br><span class=\"line\">    <span class=\"comment\">// Rehash until we encounter null</span></span><br><span class=\"line\">    Entry e;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = nextIndex(staleSlot, len);</span><br><span class=\"line\">         (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         i = nextIndex(i, len)) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            e.value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            size--;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> h = k.threadLocalHashCode &amp; (len - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (h != i) &#123;</span><br><span class=\"line\">                tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"comment\">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class=\"line\">                <span class=\"comment\">// null because multiple entries could have been stale.</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (tab[h] != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    h = nextIndex(h, len);</span><br><span class=\"line\">                tab[h] = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"拓展-调用remove方法的必要性\"><a href=\"#拓展-调用remove方法的必要性\" class=\"headerlink\" title=\"拓展-调用remove方法的必要性\"></a>拓展-调用remove方法的必要性</h4><p>总结一下什么时候无用的 Entry 会被清理：</p>\n<ul>\n<li>Thread 结束的时候</li>\n<li>插入元素时，发现 staled entry，则会进行替换并清理</li>\n<li>插入元素时，<code>ThreadLocalMap</code>  的  <code>size</code>  达到  <code>threshold</code>，并且没有任何 staled entries 的时候，会调用  <code>rehash</code>  方法清理并扩容</li>\n<li>调用  <code>ThreadLocalMap</code>  的  <code>remove</code>  方法或<code>set(null)</code>  时</li>\n</ul>\n<p>尽管不会造成内存泄露，但是可以看到无用的 Entry 只会在以上四种情况下才会被清理，这就可能导致一些 Entry 虽然无用但还占内存的情况。因此，我们在使用完 ThreadLocal 后一定要<code>remove</code>一下，保证及时回收掉无用的 Entry。</p>\n<p>特别地，当应用线程池的时候，由于线程池的线程一般会复用，Thread 不结束，这时候用完更需要  <code>remove</code>  了。</p>\n<h2 id=\"具体使用\"><a href=\"#具体使用\" class=\"headerlink\" title=\"具体使用\"></a>具体使用</h2><p>参考:<a href=\"https://www.guohezuzi.cn/article/java-multithread-spring\" target=\"_blank\" rel=\"noopener\"> Java多线程 - Spring中的线程安全</a></p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><p><a href=\"https://www.sczyh30.com/posts/Java/java-concurrent-threadlocal/\" target=\"_blank\" rel=\"noopener\"> 并发编程 | ThreadLocal 源码深入分析</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java多线程-ThreadLocal详解\"><a href=\"#Java多线程-ThreadLocal详解\" class=\"headerlink\" title=\"Java多线程 - ThreadLocal详解\"></a>Java多线程 - ThreadLocal详解</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>ThreadLocal是一个为线程提供线程本地变量的工具类。它的思想也十分简单，就是<strong>为线程提供一个线程私有的变量副本</strong>，这样多个线程都可以随意更改自己线程的变量，不会影响到其他线程。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"整体实现\"><a href=\"#整体实现\" class=\"headerlink\" title=\"整体实现\"></a>整体实现</h3><p>Threadlocal通过一个内部类ThreadLocalMap实现对不同线程中不同值的映射，key为ThreadLocal，value为Object即要保存的对象。其ThreadLocalMap中值的存储，和java中其他map类似，通过定义一个内部类Entry来实现。不过，这里的Entry时一个WeakReference对象，为了防止内存泄露，一旦线程结束，key:Threadlocal对象就变为一个不可达的对象，这个Entry就可以被GC了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadLocal</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">        ...省略一些成员变量和方法</span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadLocalMap</span> </span>&#123;</span><br><span class=\"line\">        ...省略一些成员变量和方法</span><br><span class=\"line\">            <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span> <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">/** The value associated with this ThreadLocal. */</span></span><br><span class=\"line\">            Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">super</span>(k);</span><br><span class=\"line\">                value = v;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ...省略一些成员变量和方法</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     &#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Get方法\"><a href=\"#Get方法\" class=\"headerlink\" title=\"Get方法\"></a>Get方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Returns the value in the current thread's copy of this</span></span><br><span class=\"line\"><span class=\"comment\">     * thread-local variable.  If the variable has no value for the</span></span><br><span class=\"line\"><span class=\"comment\">     * current thread, it is first initialized to the value returned</span></span><br><span class=\"line\"><span class=\"comment\">     * by an invocation of the &#123;<span class=\"doctag\">@link</span> #initialValue&#125; method.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> the current thread's value of this thread-local</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread t = Thread.currentThread();</span><br><span class=\"line\">        ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">                T result = (T)e.value;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>在这里实现的get方法逻辑还是比较简单的，其中ThreadLocalMap中的get方法和hashmap类似。就是有一点需要注意，<code>ThreadLocalMap map = getMap(t);</code>时，是通过在每个Thread中有一个<code>ThreadLocal.ThreadLocalMap threadLocals = null;</code>的成员变量，在set时，我们通过该线程的这个成员变量，找到对应的ThreadLocalMap。</p>\n<h3 id=\"Set方法\"><a href=\"#Set方法\" class=\"headerlink\" title=\"Set方法\"></a>Set方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的put方法也和hashmap中类似，注意点看上面get方法的说明就好了。</p>\n<p>ThreadLocalMap中的set方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * Set the value associated with key.</span></span><br><span class=\"line\"><span class=\"comment\">      *</span></span><br><span class=\"line\"><span class=\"comment\">      * <span class=\"doctag\">@param</span> key the thread local object</span></span><br><span class=\"line\"><span class=\"comment\">      * <span class=\"doctag\">@param</span> value the value to be set</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class=\"line\">         Entry[] tab = table;</span><br><span class=\"line\">         <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">         <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (len-<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">for</span> (Entry e = tab[i];</span><br><span class=\"line\">              e != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">              e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">             ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\"></span><br><span class=\"line\">             <span class=\"keyword\">if</span> (k == key) &#123;</span><br><span class=\"line\">                 e.value = value;</span><br><span class=\"line\">                 <span class=\"keyword\">return</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">             <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                 replaceStaleEntry(key, value, i);</span><br><span class=\"line\">                 <span class=\"keyword\">return</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         tab[i] = <span class=\"keyword\">new</span> Entry(key, value);</span><br><span class=\"line\">         <span class=\"keyword\">int</span> sz = ++size;</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class=\"line\">             rehash();</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n<p>   其中与hashmap相同都是将map的length设置为2^n，计算hash时，通过<code>key.threadLocalHashCode &amp; (len-1)</code>代替取模运算。不同的时，在rehash时threadlocal使用的是<strong>线性探测法</strong>，而hashmap使用的是<strong>链地址法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Increment i modulo len.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">nextIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((i + <span class=\"number\">1</span> &lt; len) ? i + <span class=\"number\">1</span> : <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Remove方法\"><a href=\"#Remove方法\" class=\"headerlink\" title=\"Remove方法\"></a>Remove方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (m != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">             m.remove(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n<p>  threadlocalmap中的remove:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Remove the entry for key.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = key.threadLocalHashCode &amp; (len-<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry e = tab[i];</span><br><span class=\"line\">         e != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.get() == key) &#123;</span><br><span class=\"line\">            e.clear();</span><br><span class=\"line\">            expungeStaleEntry(i);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中主要是会在将需要移除的元素置为空后，会调用<code>expungeStaleEntry(i);</code>方法，将需要移除的元素key、value清除之后，对当前位置当做 staleSlot 并调用 <code>expungeStaleEntry</code> 方法进行整理 (rehashing) 的操作，清除key为null的Entry。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Expunge a stale entry by rehashing any possibly colliding entries</span></span><br><span class=\"line\"><span class=\"comment\"> * lying between staleSlot and the next null slot.  This also expunges</span></span><br><span class=\"line\"><span class=\"comment\"> * any other stale entries encountered before the trailing null.  See</span></span><br><span class=\"line\"><span class=\"comment\"> * Knuth, Section 6.4</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> staleSlot index of slot known to have null key</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the index of the next null slot after staleSlot</span></span><br><span class=\"line\"><span class=\"comment\"> * (all between staleSlot and this slot will have been checked</span></span><br><span class=\"line\"><span class=\"comment\"> * for expunging).</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">expungeStaleEntry</span><span class=\"params\">(<span class=\"keyword\">int</span> staleSlot)</span> </span>&#123;</span><br><span class=\"line\">    Entry[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"comment\">// expunge entry at staleSlot</span></span><br><span class=\"line\">    tab[staleSlot].value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    tab[staleSlot] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    size--;</span><br><span class=\"line\">    <span class=\"comment\">// Rehash until we encounter null</span></span><br><span class=\"line\">    Entry e;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = nextIndex(staleSlot, len);</span><br><span class=\"line\">         (e = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         i = nextIndex(i, len)) &#123;</span><br><span class=\"line\">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            e.value = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            size--;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> h = k.threadLocalHashCode &amp; (len - <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (h != i) &#123;</span><br><span class=\"line\">                tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"comment\">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class=\"line\">                <span class=\"comment\">// null because multiple entries could have been stale.</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (tab[h] != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    h = nextIndex(h, len);</span><br><span class=\"line\">                tab[h] = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"拓展-调用remove方法的必要性\"><a href=\"#拓展-调用remove方法的必要性\" class=\"headerlink\" title=\"拓展-调用remove方法的必要性\"></a>拓展-调用remove方法的必要性</h4><p>总结一下什么时候无用的 Entry 会被清理：</p>\n<ul>\n<li>Thread 结束的时候</li>\n<li>插入元素时，发现 staled entry，则会进行替换并清理</li>\n<li>插入元素时，<code>ThreadLocalMap</code>  的  <code>size</code>  达到  <code>threshold</code>，并且没有任何 staled entries 的时候，会调用  <code>rehash</code>  方法清理并扩容</li>\n<li>调用  <code>ThreadLocalMap</code>  的  <code>remove</code>  方法或<code>set(null)</code>  时</li>\n</ul>\n<p>尽管不会造成内存泄露，但是可以看到无用的 Entry 只会在以上四种情况下才会被清理，这就可能导致一些 Entry 虽然无用但还占内存的情况。因此，我们在使用完 ThreadLocal 后一定要<code>remove</code>一下，保证及时回收掉无用的 Entry。</p>\n<p>特别地，当应用线程池的时候，由于线程池的线程一般会复用，Thread 不结束，这时候用完更需要  <code>remove</code>  了。</p>\n<h2 id=\"具体使用\"><a href=\"#具体使用\" class=\"headerlink\" title=\"具体使用\"></a>具体使用</h2><p>参考:<a href=\"https://www.guohezuzi.cn/article/java-multithread-spring\" target=\"_blank\" rel=\"noopener\"> Java多线程 - Spring中的线程安全</a></p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><p><a href=\"https://www.sczyh30.com/posts/Java/java-concurrent-threadlocal/\" target=\"_blank\" rel=\"noopener\"> 并发编程 | ThreadLocal 源码深入分析</a></p>\n"},{"title":"Java多线程 - 锁机制","date":"2019-06-07T09:19:04.000Z","_content":"\n# Java多线程 - 锁机制\n\n## 锁的作用\n\n在不同线程中，对同一变量、方法或代码块进行同步访问\n\n## 锁的实现方式\n\n我们通过一个例子了解锁的不同实现，开启100个线程对同一`int`变量进行`++`操作1000次，在这个过程中如何对这个变量进行同步\n\n未同步代码：\n\n```java\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * \\* Created with IntelliJ IDEA.\n * \\* User: guohezuzi\n * \\* Date: 2018-04-30\n * \\* Time: 上午11:26\n * \\* Description:自己编写的多线程的栗子(多个线程添加元素到数组中)\n * \\\n *\n * @author guohezuzi\n */\npublic class MyExample {\n    private int count = 0;\n\n    class addHundredNum extends Thread {\n        @Override\n        public void run() {\n            //...执行其他操作\n            for (int i = 0; i < 1000; i++) {\n                    count++;\n            }\n            //...执行其他操作\n        }\n    }\n\n    public void test() throws InterruptedException {\n        addHundredNum[] addHundredNums = new addHundredNum[100];\n        for (int i = 0; i < addHundredNums.length; i++) {\n            addHundredNums[i] = new addHundredNum();\n        }\n\n        for (addHundredNum addHundredNum : addHundredNums) {\n            addHundredNum.start();\n        }\n        // 等待所有addHundredNum线程执行完毕\n        for (addHundredNum addHundredNum : addHundredNums) {\n            addHundredNum.join();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        MyExample example = new MyExample();\n        example.test();\n        System.out.println(example.count);\n    }\n}\n```\n\n### synchronized\n\n通过`synchronized(addHundredNum.class)`给当前对象加锁**而不是**`synchronized(this)`给对象实例加锁\n\n```java\npublic class MyExample {\n    private int count = 0;\n\n    class addHundredNum extends Thread {\n        @Override\n        public void run() {\n            //...执行其他操作\n            synchronized (addHundredNum.class) {\n            for (int i = 0; i < 1000; i++) {\n                    count++;\n            }\n            }\n            //...执行其他操作\n        }\n    }\n\n    public void test() throws InterruptedException {\n        addHundredNum[] addHundredNums = new addHundredNum[100];\n        for (int i = 0; i < addHundredNums.length; i++) {\n            addHundredNums[i] = new addHundredNum();\n        }\n\n        for (addHundredNum addHundredNum : addHundredNums) {\n            addHundredNum.start();\n        }\n\n        for (addHundredNum addHundredNum : addHundredNums) {\n            addHundredNum.join();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        MyExample example = new MyExample();\n        example.test();\n        System.out.println(example.count);\n    }\n}\n```\n\n#### 拓展\n\n##### synchronized的不同加锁方式\n\n- 给对象加锁\n  - 修饰静态方法\n  - 修饰代码块时使用synchronized(class)\n- 给对象实例加锁\n  - 修饰非静态方法\n  - 修饰代码块时使用synchronized(this) 或 synchronized(Object)\n\n##### JVM角度理解synchronized关键字\n\n   synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。\n   根据虚拟机规范的要求，在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应地，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放了。如果获取对象锁失败了，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。\n\n##### JDK1.6后对sysnchronized的优化\n\n在JDK1.6之前，使用sysnchronized同步时，如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高\n\nJDK1.6之后，JVM对sysnchronized进行了大量优化，从原来的重量级锁到现在的锁的不同阶段升级 无锁 -> 偏向锁 -> 轻量级锁及自旋锁 -> 重量级锁\n\n- 偏向锁 \n  \n    当进行同步时，偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步\n  \n    但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，此时，偏向锁会升级为轻量级锁\n\n- 轻量级锁\n  \n    是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过CAS自旋的形式尝试获取锁，不会阻塞，从而提高性能。\n  \n    但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！\n\n- 自旋锁和自适应自旋锁\n  \n    轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。让线程自旋的方式等待一段时间\n  \n    自适应的自旋锁：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定。\n\n- 锁消除\n  \n    指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。\n\n- 锁粗化\n  \n    如果一系列的连续操作都对同一个对象反复加锁和解锁，会带来很多不必要的性能消耗，通过对连续操作的一次加锁和解锁(及锁的粗化)来节省时间\n\n### 显式锁\n\n通过JDK层面AQS实现的锁，需要我们通过编程实现，如调用lock()、unlock()\n\n```java\npublic class MyExample {\n\n    private int count = 0;\n    private final Lock lock = new ReentrantLock();\n\n    class addHundredNum extends Thread {\n        @Override\n        public void run() {\n            lock.lock();\n            try {\n                for (int i = 0; i < 1000; i++) {\n                    count++;\n                }\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n\n    public void test() throws InterruptedException {\n        addHundredNum[] addHundredNums = new addHundredNum[100];\n        for (int i = 0; i < addHundredNums.length; i++) {\n            addHundredNums[i] = new addHundredNum();\n        }\n\n        for (addHundredNum addHundredNum : addHundredNums) {\n            addHundredNum.start();\n        }\n\n        for (addHundredNum addHundredNum : addHundredNums) {\n            addHundredNum.join();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        MyExample example = new MyExample();\n        example.test();\n        System.out.println(example.count);\n    }\n}\n```\n\nAQS详解参考:[JAVA多线程 - AQS详解](https://www.guohezuzi.cn/article/java-multithread-aqs)\n\n### CAS操作\n\n通过使用原子类的CAS方法来实现\n\n```java\npublic class MyExample {\n    private AtomicInteger count = new AtomicInteger(0);\n\n    class addHundredNum extends Thread {\n        @Override\n        public void run() {\n                for (int i = 0; i < 1000; i++) {\n                    count.getAndAdd(1);\n                }\n        }\n    }\n\n    public void test() throws InterruptedException {\n        addHundredNum[] addHundredNums = new addHundredNum[100];\n        for (int i = 0; i < addHundredNums.length; i++) {\n            addHundredNums[i] = new addHundredNum();\n        }\n\n        for (addHundredNum addHundredNum : addHundredNums) {\n            addHundredNum.start();\n        }\n\n        for (addHundredNum addHundredNum : addHundredNums) {\n            addHundredNum.join();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        MyExample example = new MyExample();\n        example.test();\n        System.out.println(example.count);\n    }\n}\n```\n\nJDK8可以使用新增LongAdder类实现，该类本身会分成多个区域，多线程写入时，写入对应区域，读取会将整个区域统计输入。\n\n#### 拓展\n\n##### 什么是CAS操作\n\nCAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。\n\nCAS算法涉及到三个操作数：\n\n- 需要读写的内存值 V。\n- 进行比较的值 A。\n- 要写入的新值 B。\n\n当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。\n\n##### CAS操作存在的问题\n\n1. **ABA问题**。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。\n   - JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。\n2. **循环时间长开销大**。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。\n3. **只能保证一个共享变量的原子操作**。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。\n   - Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。\n\n### volatile\n\nvolatile关键字使用时，只能作用于变量，且并不能保证不同线程中的同步，故无法实现上面的同步的例子，接下来我们来介绍一下`volatile`关键字的作用:\n\n1. 保证不同线程中变量的可见性\n   \n   volatile英译易挥发的，表示修饰的变量是不稳定的，易改变，故采用volatile修饰后，会将变量放到主内存中，不会放到每个线程的cpu高速缓存后在读取，而是直接所用线程都通过到主内存去读取，以保证变量在每个线程的可见性。\n   \n   然而，这并不意味着变量的线程安全，不同线程cpu进行运算存在时间差，如当多个线程同时对该变量进行`++`操作时，可能其中一个线程读取时变量值为1，这时另外一个线程也读取变量值为1，第一个线程cpu进行`+1`操作运行完毕并已经写回内存，而另一个线程cpu才进行+1操作运算并写入内存，此时一个线程的结果被覆盖，导致线程不安全。\n\n2. 防止新建对象的重排序现象\n   \n    当变量采用volatile修饰后，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。如保守策略的JMM内存屏障插入策略：\n- 在每个volatile写操作的前面插入一个StoreStore屏障。\n\n- 在每个volatile写操作的后面插入一个StoreLoad屏障。\n\n- 在每个volatile读操作的后面插入一个LoadLoad屏障。\n\n- 在每个volatile读操作的后面插入一个LoadStore屏障。\n\n具体例子可参考文章[双重校验锁实现的单例模式](https://www.guohezuzi.cn/article/java-multithead-singleton)中的volatile关键字的作用\n\n## Ref\n\n1. 《深入理解Java虚拟机：JVM高级特性与最佳实践》第十三章\n\n2. [不可不说的Java“锁”事](https://tech.meituan.com/2018/11/15/java-lock.html)\n\n3. [Java并发：volatile内存可见性和指令重排](http://www.importnew.com/23535.html)\n","source":"_posts/多线程/Java多线程 - 锁机制.md","raw":"---\ntitle: Java多线程 - 锁机制\ndate: 2019-06-07 17:19:04\ntags:\n---\n\n# Java多线程 - 锁机制\n\n## 锁的作用\n\n在不同线程中，对同一变量、方法或代码块进行同步访问\n\n## 锁的实现方式\n\n我们通过一个例子了解锁的不同实现，开启100个线程对同一`int`变量进行`++`操作1000次，在这个过程中如何对这个变量进行同步\n\n未同步代码：\n\n```java\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * \\* Created with IntelliJ IDEA.\n * \\* User: guohezuzi\n * \\* Date: 2018-04-30\n * \\* Time: 上午11:26\n * \\* Description:自己编写的多线程的栗子(多个线程添加元素到数组中)\n * \\\n *\n * @author guohezuzi\n */\npublic class MyExample {\n    private int count = 0;\n\n    class addHundredNum extends Thread {\n        @Override\n        public void run() {\n            //...执行其他操作\n            for (int i = 0; i < 1000; i++) {\n                    count++;\n            }\n            //...执行其他操作\n        }\n    }\n\n    public void test() throws InterruptedException {\n        addHundredNum[] addHundredNums = new addHundredNum[100];\n        for (int i = 0; i < addHundredNums.length; i++) {\n            addHundredNums[i] = new addHundredNum();\n        }\n\n        for (addHundredNum addHundredNum : addHundredNums) {\n            addHundredNum.start();\n        }\n        // 等待所有addHundredNum线程执行完毕\n        for (addHundredNum addHundredNum : addHundredNums) {\n            addHundredNum.join();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        MyExample example = new MyExample();\n        example.test();\n        System.out.println(example.count);\n    }\n}\n```\n\n### synchronized\n\n通过`synchronized(addHundredNum.class)`给当前对象加锁**而不是**`synchronized(this)`给对象实例加锁\n\n```java\npublic class MyExample {\n    private int count = 0;\n\n    class addHundredNum extends Thread {\n        @Override\n        public void run() {\n            //...执行其他操作\n            synchronized (addHundredNum.class) {\n            for (int i = 0; i < 1000; i++) {\n                    count++;\n            }\n            }\n            //...执行其他操作\n        }\n    }\n\n    public void test() throws InterruptedException {\n        addHundredNum[] addHundredNums = new addHundredNum[100];\n        for (int i = 0; i < addHundredNums.length; i++) {\n            addHundredNums[i] = new addHundredNum();\n        }\n\n        for (addHundredNum addHundredNum : addHundredNums) {\n            addHundredNum.start();\n        }\n\n        for (addHundredNum addHundredNum : addHundredNums) {\n            addHundredNum.join();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        MyExample example = new MyExample();\n        example.test();\n        System.out.println(example.count);\n    }\n}\n```\n\n#### 拓展\n\n##### synchronized的不同加锁方式\n\n- 给对象加锁\n  - 修饰静态方法\n  - 修饰代码块时使用synchronized(class)\n- 给对象实例加锁\n  - 修饰非静态方法\n  - 修饰代码块时使用synchronized(this) 或 synchronized(Object)\n\n##### JVM角度理解synchronized关键字\n\n   synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。\n   根据虚拟机规范的要求，在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应地，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放了。如果获取对象锁失败了，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。\n\n##### JDK1.6后对sysnchronized的优化\n\n在JDK1.6之前，使用sysnchronized同步时，如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高\n\nJDK1.6之后，JVM对sysnchronized进行了大量优化，从原来的重量级锁到现在的锁的不同阶段升级 无锁 -> 偏向锁 -> 轻量级锁及自旋锁 -> 重量级锁\n\n- 偏向锁 \n  \n    当进行同步时，偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步\n  \n    但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，此时，偏向锁会升级为轻量级锁\n\n- 轻量级锁\n  \n    是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过CAS自旋的形式尝试获取锁，不会阻塞，从而提高性能。\n  \n    但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！\n\n- 自旋锁和自适应自旋锁\n  \n    轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。让线程自旋的方式等待一段时间\n  \n    自适应的自旋锁：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定。\n\n- 锁消除\n  \n    指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。\n\n- 锁粗化\n  \n    如果一系列的连续操作都对同一个对象反复加锁和解锁，会带来很多不必要的性能消耗，通过对连续操作的一次加锁和解锁(及锁的粗化)来节省时间\n\n### 显式锁\n\n通过JDK层面AQS实现的锁，需要我们通过编程实现，如调用lock()、unlock()\n\n```java\npublic class MyExample {\n\n    private int count = 0;\n    private final Lock lock = new ReentrantLock();\n\n    class addHundredNum extends Thread {\n        @Override\n        public void run() {\n            lock.lock();\n            try {\n                for (int i = 0; i < 1000; i++) {\n                    count++;\n                }\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n\n    public void test() throws InterruptedException {\n        addHundredNum[] addHundredNums = new addHundredNum[100];\n        for (int i = 0; i < addHundredNums.length; i++) {\n            addHundredNums[i] = new addHundredNum();\n        }\n\n        for (addHundredNum addHundredNum : addHundredNums) {\n            addHundredNum.start();\n        }\n\n        for (addHundredNum addHundredNum : addHundredNums) {\n            addHundredNum.join();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        MyExample example = new MyExample();\n        example.test();\n        System.out.println(example.count);\n    }\n}\n```\n\nAQS详解参考:[JAVA多线程 - AQS详解](https://www.guohezuzi.cn/article/java-multithread-aqs)\n\n### CAS操作\n\n通过使用原子类的CAS方法来实现\n\n```java\npublic class MyExample {\n    private AtomicInteger count = new AtomicInteger(0);\n\n    class addHundredNum extends Thread {\n        @Override\n        public void run() {\n                for (int i = 0; i < 1000; i++) {\n                    count.getAndAdd(1);\n                }\n        }\n    }\n\n    public void test() throws InterruptedException {\n        addHundredNum[] addHundredNums = new addHundredNum[100];\n        for (int i = 0; i < addHundredNums.length; i++) {\n            addHundredNums[i] = new addHundredNum();\n        }\n\n        for (addHundredNum addHundredNum : addHundredNums) {\n            addHundredNum.start();\n        }\n\n        for (addHundredNum addHundredNum : addHundredNums) {\n            addHundredNum.join();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        MyExample example = new MyExample();\n        example.test();\n        System.out.println(example.count);\n    }\n}\n```\n\nJDK8可以使用新增LongAdder类实现，该类本身会分成多个区域，多线程写入时，写入对应区域，读取会将整个区域统计输入。\n\n#### 拓展\n\n##### 什么是CAS操作\n\nCAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。\n\nCAS算法涉及到三个操作数：\n\n- 需要读写的内存值 V。\n- 进行比较的值 A。\n- 要写入的新值 B。\n\n当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。\n\n##### CAS操作存在的问题\n\n1. **ABA问题**。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。\n   - JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。\n2. **循环时间长开销大**。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。\n3. **只能保证一个共享变量的原子操作**。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。\n   - Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。\n\n### volatile\n\nvolatile关键字使用时，只能作用于变量，且并不能保证不同线程中的同步，故无法实现上面的同步的例子，接下来我们来介绍一下`volatile`关键字的作用:\n\n1. 保证不同线程中变量的可见性\n   \n   volatile英译易挥发的，表示修饰的变量是不稳定的，易改变，故采用volatile修饰后，会将变量放到主内存中，不会放到每个线程的cpu高速缓存后在读取，而是直接所用线程都通过到主内存去读取，以保证变量在每个线程的可见性。\n   \n   然而，这并不意味着变量的线程安全，不同线程cpu进行运算存在时间差，如当多个线程同时对该变量进行`++`操作时，可能其中一个线程读取时变量值为1，这时另外一个线程也读取变量值为1，第一个线程cpu进行`+1`操作运行完毕并已经写回内存，而另一个线程cpu才进行+1操作运算并写入内存，此时一个线程的结果被覆盖，导致线程不安全。\n\n2. 防止新建对象的重排序现象\n   \n    当变量采用volatile修饰后，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。如保守策略的JMM内存屏障插入策略：\n- 在每个volatile写操作的前面插入一个StoreStore屏障。\n\n- 在每个volatile写操作的后面插入一个StoreLoad屏障。\n\n- 在每个volatile读操作的后面插入一个LoadLoad屏障。\n\n- 在每个volatile读操作的后面插入一个LoadStore屏障。\n\n具体例子可参考文章[双重校验锁实现的单例模式](https://www.guohezuzi.cn/article/java-multithead-singleton)中的volatile关键字的作用\n\n## Ref\n\n1. 《深入理解Java虚拟机：JVM高级特性与最佳实践》第十三章\n\n2. [不可不说的Java“锁”事](https://tech.meituan.com/2018/11/15/java-lock.html)\n\n3. [Java并发：volatile内存可见性和指令重排](http://www.importnew.com/23535.html)\n","slug":"多线程/Java多线程 - 锁机制","published":1,"updated":"2019-11-13T10:07:05.227Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxt000x1w2eq15dhjdu","content":"<h1 id=\"Java多线程-锁机制\"><a href=\"#Java多线程-锁机制\" class=\"headerlink\" title=\"Java多线程 - 锁机制\"></a>Java多线程 - 锁机制</h1><h2 id=\"锁的作用\"><a href=\"#锁的作用\" class=\"headerlink\" title=\"锁的作用\"></a>锁的作用</h2><p>在不同线程中，对同一变量、方法或代码块进行同步访问</p>\n<h2 id=\"锁的实现方式\"><a href=\"#锁的实现方式\" class=\"headerlink\" title=\"锁的实现方式\"></a>锁的实现方式</h2><p>我们通过一个例子了解锁的不同实现，开启100个线程对同一<code>int</code>变量进行<code>++</code>操作1000次，在这个过程中如何对这个变量进行同步</p>\n<p>未同步代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.Lock;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Created with IntelliJ IDEA.</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* User: guohezuzi</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Date: 2018-04-30</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Time: 上午11:26</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Description:自己编写的多线程的栗子(多个线程添加元素到数组中)</span></span><br><span class=\"line\"><span class=\"comment\"> * \\</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> guohezuzi</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">addHundredNum</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//...执行其他操作</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//...执行其他操作</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        addHundredNum[] addHundredNums = <span class=\"keyword\">new</span> addHundredNum[<span class=\"number\">100</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; addHundredNums.length; i++) &#123;</span><br><span class=\"line\">            addHundredNums[i] = <span class=\"keyword\">new</span> addHundredNum();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (addHundredNum addHundredNum : addHundredNums) &#123;</span><br><span class=\"line\">            addHundredNum.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 等待所有addHundredNum线程执行完毕</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (addHundredNum addHundredNum : addHundredNums) &#123;</span><br><span class=\"line\">            addHundredNum.join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        MyExample example = <span class=\"keyword\">new</span> MyExample();</span><br><span class=\"line\">        example.test();</span><br><span class=\"line\">        System.out.println(example.count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h3><p>通过<code>synchronized(addHundredNum.class)</code>给当前对象加锁<strong>而不是</strong><code>synchronized(this)</code>给对象实例加锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">addHundredNum</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//...执行其他操作</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (addHundredNum<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//...执行其他操作</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        addHundredNum[] addHundredNums = <span class=\"keyword\">new</span> addHundredNum[<span class=\"number\">100</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; addHundredNums.length; i++) &#123;</span><br><span class=\"line\">            addHundredNums[i] = <span class=\"keyword\">new</span> addHundredNum();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (addHundredNum addHundredNum : addHundredNums) &#123;</span><br><span class=\"line\">            addHundredNum.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (addHundredNum addHundredNum : addHundredNums) &#123;</span><br><span class=\"line\">            addHundredNum.join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        MyExample example = <span class=\"keyword\">new</span> MyExample();</span><br><span class=\"line\">        example.test();</span><br><span class=\"line\">        System.out.println(example.count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h4><h5 id=\"synchronized的不同加锁方式\"><a href=\"#synchronized的不同加锁方式\" class=\"headerlink\" title=\"synchronized的不同加锁方式\"></a>synchronized的不同加锁方式</h5><ul>\n<li>给对象加锁<ul>\n<li>修饰静态方法</li>\n<li>修饰代码块时使用synchronized(class)</li>\n</ul>\n</li>\n<li>给对象实例加锁<ul>\n<li>修饰非静态方法</li>\n<li>修饰代码块时使用synchronized(this) 或 synchronized(Object)</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"JVM角度理解synchronized关键字\"><a href=\"#JVM角度理解synchronized关键字\" class=\"headerlink\" title=\"JVM角度理解synchronized关键字\"></a>JVM角度理解synchronized关键字</h5><p>   synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。<br>   根据虚拟机规范的要求，在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应地，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放了。如果获取对象锁失败了，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。</p>\n<h5 id=\"JDK1-6后对sysnchronized的优化\"><a href=\"#JDK1-6后对sysnchronized的优化\" class=\"headerlink\" title=\"JDK1.6后对sysnchronized的优化\"></a>JDK1.6后对sysnchronized的优化</h5><p>在JDK1.6之前，使用sysnchronized同步时，如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高</p>\n<p>JDK1.6之后，JVM对sysnchronized进行了大量优化，从原来的重量级锁到现在的锁的不同阶段升级 无锁 -&gt; 偏向锁 -&gt; 轻量级锁及自旋锁 -&gt; 重量级锁</p>\n<ul>\n<li><p>偏向锁 </p>\n<p>  当进行同步时，偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步</p>\n<p>  但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，此时，偏向锁会升级为轻量级锁</p>\n</li>\n<li><p>轻量级锁</p>\n<p>  是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过CAS自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>\n<p>  但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！</p>\n</li>\n<li><p>自旋锁和自适应自旋锁</p>\n<p>  轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。让线程自旋的方式等待一段时间</p>\n<p>  自适应的自旋锁：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定。</p>\n</li>\n<li><p>锁消除</p>\n<p>  指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。</p>\n</li>\n<li><p>锁粗化</p>\n<p>  如果一系列的连续操作都对同一个对象反复加锁和解锁，会带来很多不必要的性能消耗，通过对连续操作的一次加锁和解锁(及锁的粗化)来节省时间</p>\n</li>\n</ul>\n<h3 id=\"显式锁\"><a href=\"#显式锁\" class=\"headerlink\" title=\"显式锁\"></a>显式锁</h3><p>通过JDK层面AQS实现的锁，需要我们通过编程实现，如调用lock()、unlock()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyExample</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">addHundredNum</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        addHundredNum[] addHundredNums = <span class=\"keyword\">new</span> addHundredNum[<span class=\"number\">100</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; addHundredNums.length; i++) &#123;</span><br><span class=\"line\">            addHundredNums[i] = <span class=\"keyword\">new</span> addHundredNum();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (addHundredNum addHundredNum : addHundredNums) &#123;</span><br><span class=\"line\">            addHundredNum.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (addHundredNum addHundredNum : addHundredNums) &#123;</span><br><span class=\"line\">            addHundredNum.join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        MyExample example = <span class=\"keyword\">new</span> MyExample();</span><br><span class=\"line\">        example.test();</span><br><span class=\"line\">        System.out.println(example.count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AQS详解参考:<a href=\"https://www.guohezuzi.cn/article/java-multithread-aqs\" target=\"_blank\" rel=\"noopener\">JAVA多线程 - AQS详解</a></p>\n<h3 id=\"CAS操作\"><a href=\"#CAS操作\" class=\"headerlink\" title=\"CAS操作\"></a>CAS操作</h3><p>通过使用原子类的CAS方法来实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicInteger count = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">addHundredNum</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">                    count.getAndAdd(<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        addHundredNum[] addHundredNums = <span class=\"keyword\">new</span> addHundredNum[<span class=\"number\">100</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; addHundredNums.length; i++) &#123;</span><br><span class=\"line\">            addHundredNums[i] = <span class=\"keyword\">new</span> addHundredNum();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (addHundredNum addHundredNum : addHundredNums) &#123;</span><br><span class=\"line\">            addHundredNum.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (addHundredNum addHundredNum : addHundredNums) &#123;</span><br><span class=\"line\">            addHundredNum.join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        MyExample example = <span class=\"keyword\">new</span> MyExample();</span><br><span class=\"line\">        example.test();</span><br><span class=\"line\">        System.out.println(example.count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>JDK8可以使用新增LongAdder类实现，该类本身会分成多个区域，多线程写入时，写入对应区域，读取会将整个区域统计输入。</p>\n<h4 id=\"拓展-1\"><a href=\"#拓展-1\" class=\"headerlink\" title=\"拓展\"></a>拓展</h4><h5 id=\"什么是CAS操作\"><a href=\"#什么是CAS操作\" class=\"headerlink\" title=\"什么是CAS操作\"></a>什么是CAS操作</h5><p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。</p>\n<p>CAS算法涉及到三个操作数：</p>\n<ul>\n<li>需要读写的内存值 V。</li>\n<li>进行比较的值 A。</li>\n<li>要写入的新值 B。</li>\n</ul>\n<p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p>\n<h5 id=\"CAS操作存在的问题\"><a href=\"#CAS操作存在的问题\" class=\"headerlink\" title=\"CAS操作存在的问题\"></a>CAS操作存在的问题</h5><ol>\n<li><strong>ABA问题</strong>。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。<ul>\n<li>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</li>\n</ul>\n</li>\n<li><strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</li>\n<li><strong>只能保证一个共享变量的原子操作</strong>。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。<ul>\n<li>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3><p>volatile关键字使用时，只能作用于变量，且并不能保证不同线程中的同步，故无法实现上面的同步的例子，接下来我们来介绍一下<code>volatile</code>关键字的作用:</p>\n<ol>\n<li><p>保证不同线程中变量的可见性</p>\n<p>volatile英译易挥发的，表示修饰的变量是不稳定的，易改变，故采用volatile修饰后，会将变量放到主内存中，不会放到每个线程的cpu高速缓存后在读取，而是直接所用线程都通过到主内存去读取，以保证变量在每个线程的可见性。</p>\n<p>然而，这并不意味着变量的线程安全，不同线程cpu进行运算存在时间差，如当多个线程同时对该变量进行<code>++</code>操作时，可能其中一个线程读取时变量值为1，这时另外一个线程也读取变量值为1，第一个线程cpu进行<code>+1</code>操作运行完毕并已经写回内存，而另一个线程cpu才进行+1操作运算并写入内存，此时一个线程的结果被覆盖，导致线程不安全。</p>\n</li>\n<li><p>防止新建对象的重排序现象</p>\n<p> 当变量采用volatile修饰后，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。如保守策略的JMM内存屏障插入策略：</p>\n</li>\n</ol>\n<ul>\n<li><p>在每个volatile写操作的前面插入一个StoreStore屏障。</p>\n</li>\n<li><p>在每个volatile写操作的后面插入一个StoreLoad屏障。</p>\n</li>\n<li><p>在每个volatile读操作的后面插入一个LoadLoad屏障。</p>\n</li>\n<li><p>在每个volatile读操作的后面插入一个LoadStore屏障。</p>\n</li>\n</ul>\n<p>具体例子可参考文章<a href=\"https://www.guohezuzi.cn/article/java-multithead-singleton\" target=\"_blank\" rel=\"noopener\">双重校验锁实现的单例模式</a>中的volatile关键字的作用</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ol>\n<li><p>《深入理解Java虚拟机：JVM高级特性与最佳实践》第十三章</p>\n</li>\n<li><p><a href=\"https://tech.meituan.com/2018/11/15/java-lock.html\" target=\"_blank\" rel=\"noopener\">不可不说的Java“锁”事</a></p>\n</li>\n<li><p><a href=\"http://www.importnew.com/23535.html\" target=\"_blank\" rel=\"noopener\">Java并发：volatile内存可见性和指令重排</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java多线程-锁机制\"><a href=\"#Java多线程-锁机制\" class=\"headerlink\" title=\"Java多线程 - 锁机制\"></a>Java多线程 - 锁机制</h1><h2 id=\"锁的作用\"><a href=\"#锁的作用\" class=\"headerlink\" title=\"锁的作用\"></a>锁的作用</h2><p>在不同线程中，对同一变量、方法或代码块进行同步访问</p>\n<h2 id=\"锁的实现方式\"><a href=\"#锁的实现方式\" class=\"headerlink\" title=\"锁的实现方式\"></a>锁的实现方式</h2><p>我们通过一个例子了解锁的不同实现，开启100个线程对同一<code>int</code>变量进行<code>++</code>操作1000次，在这个过程中如何对这个变量进行同步</p>\n<p>未同步代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.Lock;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Created with IntelliJ IDEA.</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* User: guohezuzi</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Date: 2018-04-30</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Time: 上午11:26</span></span><br><span class=\"line\"><span class=\"comment\"> * \\* Description:自己编写的多线程的栗子(多个线程添加元素到数组中)</span></span><br><span class=\"line\"><span class=\"comment\"> * \\</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> guohezuzi</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">addHundredNum</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//...执行其他操作</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//...执行其他操作</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        addHundredNum[] addHundredNums = <span class=\"keyword\">new</span> addHundredNum[<span class=\"number\">100</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; addHundredNums.length; i++) &#123;</span><br><span class=\"line\">            addHundredNums[i] = <span class=\"keyword\">new</span> addHundredNum();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (addHundredNum addHundredNum : addHundredNums) &#123;</span><br><span class=\"line\">            addHundredNum.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 等待所有addHundredNum线程执行完毕</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (addHundredNum addHundredNum : addHundredNums) &#123;</span><br><span class=\"line\">            addHundredNum.join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        MyExample example = <span class=\"keyword\">new</span> MyExample();</span><br><span class=\"line\">        example.test();</span><br><span class=\"line\">        System.out.println(example.count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h3><p>通过<code>synchronized(addHundredNum.class)</code>给当前对象加锁<strong>而不是</strong><code>synchronized(this)</code>给对象实例加锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">addHundredNum</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//...执行其他操作</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (addHundredNum<span class=\"class\">.<span class=\"keyword\">class</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//...执行其他操作</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        addHundredNum[] addHundredNums = <span class=\"keyword\">new</span> addHundredNum[<span class=\"number\">100</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; addHundredNums.length; i++) &#123;</span><br><span class=\"line\">            addHundredNums[i] = <span class=\"keyword\">new</span> addHundredNum();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (addHundredNum addHundredNum : addHundredNums) &#123;</span><br><span class=\"line\">            addHundredNum.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (addHundredNum addHundredNum : addHundredNums) &#123;</span><br><span class=\"line\">            addHundredNum.join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        MyExample example = <span class=\"keyword\">new</span> MyExample();</span><br><span class=\"line\">        example.test();</span><br><span class=\"line\">        System.out.println(example.count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"拓展\"><a href=\"#拓展\" class=\"headerlink\" title=\"拓展\"></a>拓展</h4><h5 id=\"synchronized的不同加锁方式\"><a href=\"#synchronized的不同加锁方式\" class=\"headerlink\" title=\"synchronized的不同加锁方式\"></a>synchronized的不同加锁方式</h5><ul>\n<li>给对象加锁<ul>\n<li>修饰静态方法</li>\n<li>修饰代码块时使用synchronized(class)</li>\n</ul>\n</li>\n<li>给对象实例加锁<ul>\n<li>修饰非静态方法</li>\n<li>修饰代码块时使用synchronized(this) 或 synchronized(Object)</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"JVM角度理解synchronized关键字\"><a href=\"#JVM角度理解synchronized关键字\" class=\"headerlink\" title=\"JVM角度理解synchronized关键字\"></a>JVM角度理解synchronized关键字</h5><p>   synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。<br>   根据虚拟机规范的要求，在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应地，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放了。如果获取对象锁失败了，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。</p>\n<h5 id=\"JDK1-6后对sysnchronized的优化\"><a href=\"#JDK1-6后对sysnchronized的优化\" class=\"headerlink\" title=\"JDK1.6后对sysnchronized的优化\"></a>JDK1.6后对sysnchronized的优化</h5><p>在JDK1.6之前，使用sysnchronized同步时，如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高</p>\n<p>JDK1.6之后，JVM对sysnchronized进行了大量优化，从原来的重量级锁到现在的锁的不同阶段升级 无锁 -&gt; 偏向锁 -&gt; 轻量级锁及自旋锁 -&gt; 重量级锁</p>\n<ul>\n<li><p>偏向锁 </p>\n<p>  当进行同步时，偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步</p>\n<p>  但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，此时，偏向锁会升级为轻量级锁</p>\n</li>\n<li><p>轻量级锁</p>\n<p>  是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过CAS自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>\n<p>  但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！</p>\n</li>\n<li><p>自旋锁和自适应自旋锁</p>\n<p>  轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。让线程自旋的方式等待一段时间</p>\n<p>  自适应的自旋锁：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定。</p>\n</li>\n<li><p>锁消除</p>\n<p>  指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。</p>\n</li>\n<li><p>锁粗化</p>\n<p>  如果一系列的连续操作都对同一个对象反复加锁和解锁，会带来很多不必要的性能消耗，通过对连续操作的一次加锁和解锁(及锁的粗化)来节省时间</p>\n</li>\n</ul>\n<h3 id=\"显式锁\"><a href=\"#显式锁\" class=\"headerlink\" title=\"显式锁\"></a>显式锁</h3><p>通过JDK层面AQS实现的锁，需要我们通过编程实现，如调用lock()、unlock()</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyExample</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">addHundredNum</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            lock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                lock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        addHundredNum[] addHundredNums = <span class=\"keyword\">new</span> addHundredNum[<span class=\"number\">100</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; addHundredNums.length; i++) &#123;</span><br><span class=\"line\">            addHundredNums[i] = <span class=\"keyword\">new</span> addHundredNum();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (addHundredNum addHundredNum : addHundredNums) &#123;</span><br><span class=\"line\">            addHundredNum.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (addHundredNum addHundredNum : addHundredNums) &#123;</span><br><span class=\"line\">            addHundredNum.join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        MyExample example = <span class=\"keyword\">new</span> MyExample();</span><br><span class=\"line\">        example.test();</span><br><span class=\"line\">        System.out.println(example.count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AQS详解参考:<a href=\"https://www.guohezuzi.cn/article/java-multithread-aqs\" target=\"_blank\" rel=\"noopener\">JAVA多线程 - AQS详解</a></p>\n<h3 id=\"CAS操作\"><a href=\"#CAS操作\" class=\"headerlink\" title=\"CAS操作\"></a>CAS操作</h3><p>通过使用原子类的CAS方法来实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> AtomicInteger count = <span class=\"keyword\">new</span> AtomicInteger(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">addHundredNum</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">                    count.getAndAdd(<span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        addHundredNum[] addHundredNums = <span class=\"keyword\">new</span> addHundredNum[<span class=\"number\">100</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; addHundredNums.length; i++) &#123;</span><br><span class=\"line\">            addHundredNums[i] = <span class=\"keyword\">new</span> addHundredNum();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (addHundredNum addHundredNum : addHundredNums) &#123;</span><br><span class=\"line\">            addHundredNum.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (addHundredNum addHundredNum : addHundredNums) &#123;</span><br><span class=\"line\">            addHundredNum.join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        MyExample example = <span class=\"keyword\">new</span> MyExample();</span><br><span class=\"line\">        example.test();</span><br><span class=\"line\">        System.out.println(example.count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>JDK8可以使用新增LongAdder类实现，该类本身会分成多个区域，多线程写入时，写入对应区域，读取会将整个区域统计输入。</p>\n<h4 id=\"拓展-1\"><a href=\"#拓展-1\" class=\"headerlink\" title=\"拓展\"></a>拓展</h4><h5 id=\"什么是CAS操作\"><a href=\"#什么是CAS操作\" class=\"headerlink\" title=\"什么是CAS操作\"></a>什么是CAS操作</h5><p>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。</p>\n<p>CAS算法涉及到三个操作数：</p>\n<ul>\n<li>需要读写的内存值 V。</li>\n<li>进行比较的值 A。</li>\n<li>要写入的新值 B。</li>\n</ul>\n<p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p>\n<h5 id=\"CAS操作存在的问题\"><a href=\"#CAS操作存在的问题\" class=\"headerlink\" title=\"CAS操作存在的问题\"></a>CAS操作存在的问题</h5><ol>\n<li><strong>ABA问题</strong>。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。<ul>\n<li>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</li>\n</ul>\n</li>\n<li><strong>循环时间长开销大</strong>。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</li>\n<li><strong>只能保证一个共享变量的原子操作</strong>。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。<ul>\n<li>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h3><p>volatile关键字使用时，只能作用于变量，且并不能保证不同线程中的同步，故无法实现上面的同步的例子，接下来我们来介绍一下<code>volatile</code>关键字的作用:</p>\n<ol>\n<li><p>保证不同线程中变量的可见性</p>\n<p>volatile英译易挥发的，表示修饰的变量是不稳定的，易改变，故采用volatile修饰后，会将变量放到主内存中，不会放到每个线程的cpu高速缓存后在读取，而是直接所用线程都通过到主内存去读取，以保证变量在每个线程的可见性。</p>\n<p>然而，这并不意味着变量的线程安全，不同线程cpu进行运算存在时间差，如当多个线程同时对该变量进行<code>++</code>操作时，可能其中一个线程读取时变量值为1，这时另外一个线程也读取变量值为1，第一个线程cpu进行<code>+1</code>操作运行完毕并已经写回内存，而另一个线程cpu才进行+1操作运算并写入内存，此时一个线程的结果被覆盖，导致线程不安全。</p>\n</li>\n<li><p>防止新建对象的重排序现象</p>\n<p> 当变量采用volatile修饰后，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。如保守策略的JMM内存屏障插入策略：</p>\n</li>\n</ol>\n<ul>\n<li><p>在每个volatile写操作的前面插入一个StoreStore屏障。</p>\n</li>\n<li><p>在每个volatile写操作的后面插入一个StoreLoad屏障。</p>\n</li>\n<li><p>在每个volatile读操作的后面插入一个LoadLoad屏障。</p>\n</li>\n<li><p>在每个volatile读操作的后面插入一个LoadStore屏障。</p>\n</li>\n</ul>\n<p>具体例子可参考文章<a href=\"https://www.guohezuzi.cn/article/java-multithead-singleton\" target=\"_blank\" rel=\"noopener\">双重校验锁实现的单例模式</a>中的volatile关键字的作用</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><ol>\n<li><p>《深入理解Java虚拟机：JVM高级特性与最佳实践》第十三章</p>\n</li>\n<li><p><a href=\"https://tech.meituan.com/2018/11/15/java-lock.html\" target=\"_blank\" rel=\"noopener\">不可不说的Java“锁”事</a></p>\n</li>\n<li><p><a href=\"http://www.importnew.com/23535.html\" target=\"_blank\" rel=\"noopener\">Java并发：volatile内存可见性和指令重排</a></p>\n</li>\n</ol>\n"},{"title":"Java多线程 - 线程的使用","date":"2019-06-10T09:19:04.000Z","_content":"\n# Java多线程 - 线程的使用\n\n## 线程的创建\n\n#### 通过实现Runnable接口\n\n```java\nclass RunnableDemo implements Runnable {\n    private String threadName;\n\n    private RunnableDemo(String name) {\n        this.threadName = name;\n        System.out.println(\"creating thread:\" + threadName);\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"Running \" + threadName);\n\n        try {\n            for (int i = 0; i < 10; i++) {\n                System.out.println(\"Thread:\" + threadName + \",\" + i);\n                Thread.sleep(50);\n            }\n        } catch (InterruptedException e) {\n            System.out.println(\"Thread \" + threadName + \"interrupter\");\n        }\n        System.out.println(\"Thread \" + threadName + \" exiting\");\n    }\n    // run\n    public static void main(String[] args) {\n        RunnableDemo r = new RunnableDemo(\"MyThread\");\n        r.run();\n    }\n}\n```\n\n#### 通过继承Thread类本身\n\n```java\npublic class ThreadDemo extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"thread\" + Thread.currentThread().getId() + \" running...\");\n    }\n    // run 10 thread\n    public static void main(String[] args) throws InterruptedException {\n        ThreadDemo[] threadDemos = new ThreadDemo[10];\n        for (int i = 0; i < threadDemos.length; i++) {\n            threadDemos[i] = new ThreadDemo();\n        }\n        for (ThreadDemo threadDemo : threadDemos) {\n            threadDemo.start();\n        }\n        // wait other thread complete\n        for (ThreadDemo threadDemo : threadDemos) {\n            threadDemo.join();\n        }\n        System.out.println(\"completing\");\n    }\n}\n```\n\n#### 通过实现Callable创建线程(可以对线程返回值处理)\n\n通过`FutureTask`包装一个`Callable`的实例，再通过`Thread`包装`FutureTask`的实例，然后调用`Thread`的`start()`方法\n\n```java\npublic class CallableDemo implements Callable<String> {\n    @Override\n    public String call() throws Exception {\n        return \"yo!\";\n    }\n\n    @Test\n    public void callUse() throws Exception {\n        CallableDemo callableDemo = new CallableDemo();\n        System.out.println(callableDemo.call());\n    }\n\n    @Test\n    public void threadUse() throws ExecutionException, InterruptedException {\n        FutureTask<String> futureTask= new FutureTask<>(new CallableDemo());\n        Thread thread=new Thread(futureTask);\n        thread.start();\n        System.out.println(futureTask.get());\n    }\n}\n```\n\nFutureTask继承关系\n\n<center>\n\n<img src=\"https://cdn.guohezuzi.cn/public/img/futureTask.png\" width=\"70%\" />\n\n</center>\n\n\n## 线程池执行线程\n\n#### 线程池的创建\n\n一般通过ThreadPoolExecutor类来创建线程\n\n```java\nThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(\n                          int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler\n                          )\n```\n\n##### 变量说明\n\n- corePoolSize 线程池的基本大小\n\n- maximumPoolSize 线程池的最大大小\n\n- keepAliveTime 空闲线程(超出基本大小的线程)的存活时间\n\n- unit 空闲线程存活时间的单位(毫秒,秒...)\n\n- workQueue 任务队列，提交的任务的阻塞队列(`BlockingQueue`)。more: [Java多线程 - 阻塞队列详解](https://www.guohezuzi.cn/article/java-multhread-blockingqueue)\n\n- threadFactory 线程工产，线程的创建策略，有默认实现，可以通过定制线程工厂来监听线程信息 \n\n- handler 饱和策略，当线程由于任务队列满了，或者某个任务被提交到一个已被关闭的线程的处理方式\n\n  - AbortPolicy 中止策略，**默认策略** ，该策略会抛出RejectExecutionException异常，调用者可以根据这个异常编写自己的处理代码\n\n  - DiscardRunsPolicy 抛弃策略，悄悄抛弃该任务，不抛异常\n\n  - DiscardOldestPolicy 抛弃最久任务策略 将工作队列中最老的（也就是下一个要执行的）任务抛弃。**优先队列将会是优先级最高的**\n\n  - CallerRunsPolicy 调用者执行策略，将线程添加到添加工作队列的线程去执行\n\nps: 构造器参考下表\n\n##### 继承关系\n\n<center>\n\n<img src=\"https://cdn.guohezuzi.cn/public/img/thread.png\" width=\"70%\" />\n\n</center>\n\n#### 线程池的使用\n\n##### Runable接口\n\n```java\npublic static void main(String[] args) throws InterruptedException, ExecutionException {\n        ExecutorService pool=Executors.newFixedThreadPool(2);\n        pool.execute(() -> System.out.println(\"yo!\"));\n        pool.shutdown();\n}\n```\n\n##### Callable接口\n\n通过调用submit方法\n\n在`ExecutorService`中提供了重载的`submit()`方法，该方法既可以接收`Runnable`实例又能接收`Callable`实例。对于实现`Callable`接口的类，需要覆写`call()`方法，并且只能通过`ExecutorService`的`submit()`方法来启动`call()`方法\n\n```java\npublic static void main(String[] args) throws InterruptedException, ExecutionException {\n        ExecutorService pool=Executors.newFixedThreadPool(2);\n        Future future=pool.submit(() -> {\n            Thread.sleep(100);\n            return \"yo!\";\n        });\n        System.out.println(future.get());\n        pool.shutdown();\n}\n```\n\n##### 延时任务与周期任务的使用\n\n定义：延时任务(\"在100ms后执行的任务\") 周期任务(\"每10ms执行一次的任务\")\n\n使用：通过new ScheduledThreadPoolExector()对象\n\n<center>\n\n<img src=\"https://cdn.guohezuzi.cn/public/img/ScheduleExecutor.png\" width=\"80%\" />\n\n</center>\n\nDemo:\n\n```java\npublic class ScheduleExecutorDemo implements Runnable {\n    private String name;\n\n    public ScheduleExecutorDemo(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(name + \" 运行\");\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        ScheduledExecutorService executorService1 = Executors.newScheduledThreadPool(2);\n        // after 10s run\n        executorService1.schedule(new ScheduleExecutorDemo(\"task1\"), 10, TimeUnit.SECONDS);\n        executorService1.shutdown();\n\n        ScheduledExecutorService executorService2 = Executors.newScheduledThreadPool(2);\n        // run per 1s\n        executorService2.scheduleAtFixedRate(new ScheduleExecutorDemo(\"task1\"), \n                0, 1, TimeUnit.SECONDS);\n        // run per 2s\n        executorService2.scheduleWithFixedDelay(new ScheduleExecutorDemo(\"task2\"), \n                0, 2, TimeUnit.SECONDS);\n    }\n}\n```\n\n##### 使用tips\n\n来源：[阿里巴巴Java开发手册](https://github.com/alibaba/p3c)\n\n- 线程资源必须通过线程池提供,不允许在应用中自行显式创建线程。\n\n  说明: 使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销,解决资源不足的问题。如果不使用线程池,有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。\n\n- 线程池不允许使用 Executors 去创建,而是通过 ThreadPoolExecutor 的方式,这样的处理方式让写的同学更加明确线程池运行规则,规避资源耗尽的风险。\n\n  说明: Executors 返回的线程池对象的弊端如下:\n\n  - FixedThreadPool 和 SingleThreadPool :允许的请求队列长度为 Integer.MAX_VALUE ,可能会堆积大量的请求,从而导致 OOM 。\n\n  - CachedThreadPool 和 ScheduledThreadPool :允许的创建线程数量为 Integer.MAX_VALUE ,可能会创建大量的线程,从而导致 OOM 。\n\n- 多线程并行处理定时任务时, Timer 运行多个 TimeTask 时,只要其中之一没有捕获抛出的异常,其它任务便会自动终止运行,使用 ScheduledExecutorService 则没有这个问题。\n\n## Ref:\n\n1. JDK1.8.0 源码\n\n2. [Java多线程之Callable接口及线程池](http://codepub.cn/2016/02/01/Java-multi-thread-Callable-interface-and-thread-pool/)\n\n3. [《Java并发编程实战》](https://book.douban.com/subject/10484692/)\n\n4. [《Java多线程编程实战指南(核心篇)》](https://book.douban.com/subject/27034721/)\n","source":"_posts/多线程/Java多线程-线程的使用.md","raw":"---\ntitle: Java多线程 - 线程的使用\ndate: 2019-06-10 17:19:04\ntags:\n---\n\n# Java多线程 - 线程的使用\n\n## 线程的创建\n\n#### 通过实现Runnable接口\n\n```java\nclass RunnableDemo implements Runnable {\n    private String threadName;\n\n    private RunnableDemo(String name) {\n        this.threadName = name;\n        System.out.println(\"creating thread:\" + threadName);\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"Running \" + threadName);\n\n        try {\n            for (int i = 0; i < 10; i++) {\n                System.out.println(\"Thread:\" + threadName + \",\" + i);\n                Thread.sleep(50);\n            }\n        } catch (InterruptedException e) {\n            System.out.println(\"Thread \" + threadName + \"interrupter\");\n        }\n        System.out.println(\"Thread \" + threadName + \" exiting\");\n    }\n    // run\n    public static void main(String[] args) {\n        RunnableDemo r = new RunnableDemo(\"MyThread\");\n        r.run();\n    }\n}\n```\n\n#### 通过继承Thread类本身\n\n```java\npublic class ThreadDemo extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"thread\" + Thread.currentThread().getId() + \" running...\");\n    }\n    // run 10 thread\n    public static void main(String[] args) throws InterruptedException {\n        ThreadDemo[] threadDemos = new ThreadDemo[10];\n        for (int i = 0; i < threadDemos.length; i++) {\n            threadDemos[i] = new ThreadDemo();\n        }\n        for (ThreadDemo threadDemo : threadDemos) {\n            threadDemo.start();\n        }\n        // wait other thread complete\n        for (ThreadDemo threadDemo : threadDemos) {\n            threadDemo.join();\n        }\n        System.out.println(\"completing\");\n    }\n}\n```\n\n#### 通过实现Callable创建线程(可以对线程返回值处理)\n\n通过`FutureTask`包装一个`Callable`的实例，再通过`Thread`包装`FutureTask`的实例，然后调用`Thread`的`start()`方法\n\n```java\npublic class CallableDemo implements Callable<String> {\n    @Override\n    public String call() throws Exception {\n        return \"yo!\";\n    }\n\n    @Test\n    public void callUse() throws Exception {\n        CallableDemo callableDemo = new CallableDemo();\n        System.out.println(callableDemo.call());\n    }\n\n    @Test\n    public void threadUse() throws ExecutionException, InterruptedException {\n        FutureTask<String> futureTask= new FutureTask<>(new CallableDemo());\n        Thread thread=new Thread(futureTask);\n        thread.start();\n        System.out.println(futureTask.get());\n    }\n}\n```\n\nFutureTask继承关系\n\n<center>\n\n<img src=\"https://cdn.guohezuzi.cn/public/img/futureTask.png\" width=\"70%\" />\n\n</center>\n\n\n## 线程池执行线程\n\n#### 线程池的创建\n\n一般通过ThreadPoolExecutor类来创建线程\n\n```java\nThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(\n                          int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler\n                          )\n```\n\n##### 变量说明\n\n- corePoolSize 线程池的基本大小\n\n- maximumPoolSize 线程池的最大大小\n\n- keepAliveTime 空闲线程(超出基本大小的线程)的存活时间\n\n- unit 空闲线程存活时间的单位(毫秒,秒...)\n\n- workQueue 任务队列，提交的任务的阻塞队列(`BlockingQueue`)。more: [Java多线程 - 阻塞队列详解](https://www.guohezuzi.cn/article/java-multhread-blockingqueue)\n\n- threadFactory 线程工产，线程的创建策略，有默认实现，可以通过定制线程工厂来监听线程信息 \n\n- handler 饱和策略，当线程由于任务队列满了，或者某个任务被提交到一个已被关闭的线程的处理方式\n\n  - AbortPolicy 中止策略，**默认策略** ，该策略会抛出RejectExecutionException异常，调用者可以根据这个异常编写自己的处理代码\n\n  - DiscardRunsPolicy 抛弃策略，悄悄抛弃该任务，不抛异常\n\n  - DiscardOldestPolicy 抛弃最久任务策略 将工作队列中最老的（也就是下一个要执行的）任务抛弃。**优先队列将会是优先级最高的**\n\n  - CallerRunsPolicy 调用者执行策略，将线程添加到添加工作队列的线程去执行\n\nps: 构造器参考下表\n\n##### 继承关系\n\n<center>\n\n<img src=\"https://cdn.guohezuzi.cn/public/img/thread.png\" width=\"70%\" />\n\n</center>\n\n#### 线程池的使用\n\n##### Runable接口\n\n```java\npublic static void main(String[] args) throws InterruptedException, ExecutionException {\n        ExecutorService pool=Executors.newFixedThreadPool(2);\n        pool.execute(() -> System.out.println(\"yo!\"));\n        pool.shutdown();\n}\n```\n\n##### Callable接口\n\n通过调用submit方法\n\n在`ExecutorService`中提供了重载的`submit()`方法，该方法既可以接收`Runnable`实例又能接收`Callable`实例。对于实现`Callable`接口的类，需要覆写`call()`方法，并且只能通过`ExecutorService`的`submit()`方法来启动`call()`方法\n\n```java\npublic static void main(String[] args) throws InterruptedException, ExecutionException {\n        ExecutorService pool=Executors.newFixedThreadPool(2);\n        Future future=pool.submit(() -> {\n            Thread.sleep(100);\n            return \"yo!\";\n        });\n        System.out.println(future.get());\n        pool.shutdown();\n}\n```\n\n##### 延时任务与周期任务的使用\n\n定义：延时任务(\"在100ms后执行的任务\") 周期任务(\"每10ms执行一次的任务\")\n\n使用：通过new ScheduledThreadPoolExector()对象\n\n<center>\n\n<img src=\"https://cdn.guohezuzi.cn/public/img/ScheduleExecutor.png\" width=\"80%\" />\n\n</center>\n\nDemo:\n\n```java\npublic class ScheduleExecutorDemo implements Runnable {\n    private String name;\n\n    public ScheduleExecutorDemo(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(name + \" 运行\");\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        ScheduledExecutorService executorService1 = Executors.newScheduledThreadPool(2);\n        // after 10s run\n        executorService1.schedule(new ScheduleExecutorDemo(\"task1\"), 10, TimeUnit.SECONDS);\n        executorService1.shutdown();\n\n        ScheduledExecutorService executorService2 = Executors.newScheduledThreadPool(2);\n        // run per 1s\n        executorService2.scheduleAtFixedRate(new ScheduleExecutorDemo(\"task1\"), \n                0, 1, TimeUnit.SECONDS);\n        // run per 2s\n        executorService2.scheduleWithFixedDelay(new ScheduleExecutorDemo(\"task2\"), \n                0, 2, TimeUnit.SECONDS);\n    }\n}\n```\n\n##### 使用tips\n\n来源：[阿里巴巴Java开发手册](https://github.com/alibaba/p3c)\n\n- 线程资源必须通过线程池提供,不允许在应用中自行显式创建线程。\n\n  说明: 使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销,解决资源不足的问题。如果不使用线程池,有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。\n\n- 线程池不允许使用 Executors 去创建,而是通过 ThreadPoolExecutor 的方式,这样的处理方式让写的同学更加明确线程池运行规则,规避资源耗尽的风险。\n\n  说明: Executors 返回的线程池对象的弊端如下:\n\n  - FixedThreadPool 和 SingleThreadPool :允许的请求队列长度为 Integer.MAX_VALUE ,可能会堆积大量的请求,从而导致 OOM 。\n\n  - CachedThreadPool 和 ScheduledThreadPool :允许的创建线程数量为 Integer.MAX_VALUE ,可能会创建大量的线程,从而导致 OOM 。\n\n- 多线程并行处理定时任务时, Timer 运行多个 TimeTask 时,只要其中之一没有捕获抛出的异常,其它任务便会自动终止运行,使用 ScheduledExecutorService 则没有这个问题。\n\n## Ref:\n\n1. JDK1.8.0 源码\n\n2. [Java多线程之Callable接口及线程池](http://codepub.cn/2016/02/01/Java-multi-thread-Callable-interface-and-thread-pool/)\n\n3. [《Java并发编程实战》](https://book.douban.com/subject/10484692/)\n\n4. [《Java多线程编程实战指南(核心篇)》](https://book.douban.com/subject/27034721/)\n","slug":"多线程/Java多线程-线程的使用","published":1,"updated":"2019-11-13T10:09:11.271Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxu000y1w2ehnyis5y2","content":"<h1 id=\"Java多线程-线程的使用\"><a href=\"#Java多线程-线程的使用\" class=\"headerlink\" title=\"Java多线程 - 线程的使用\"></a>Java多线程 - 线程的使用</h1><h2 id=\"线程的创建\"><a href=\"#线程的创建\" class=\"headerlink\" title=\"线程的创建\"></a>线程的创建</h2><h4 id=\"通过实现Runnable接口\"><a href=\"#通过实现Runnable接口\" class=\"headerlink\" title=\"通过实现Runnable接口\"></a>通过实现Runnable接口</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RunnableDemo</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String threadName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">RunnableDemo</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.threadName = name;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"creating thread:\"</span> + threadName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Running \"</span> + threadName);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"Thread:\"</span> + threadName + <span class=\"string\">\",\"</span> + i);</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">50</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Thread \"</span> + threadName + <span class=\"string\">\"interrupter\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Thread \"</span> + threadName + <span class=\"string\">\" exiting\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// run</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        RunnableDemo r = <span class=\"keyword\">new</span> RunnableDemo(<span class=\"string\">\"MyThread\"</span>);</span><br><span class=\"line\">        r.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"通过继承Thread类本身\"><a href=\"#通过继承Thread类本身\" class=\"headerlink\" title=\"通过继承Thread类本身\"></a>通过继承Thread类本身</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadDemo</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"thread\"</span> + Thread.currentThread().getId() + <span class=\"string\">\" running...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// run 10 thread</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        ThreadDemo[] threadDemos = <span class=\"keyword\">new</span> ThreadDemo[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; threadDemos.length; i++) &#123;</span><br><span class=\"line\">            threadDemos[i] = <span class=\"keyword\">new</span> ThreadDemo();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ThreadDemo threadDemo : threadDemos) &#123;</span><br><span class=\"line\">            threadDemo.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// wait other thread complete</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ThreadDemo threadDemo : threadDemos) &#123;</span><br><span class=\"line\">            threadDemo.join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"completing\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"通过实现Callable创建线程-可以对线程返回值处理\"><a href=\"#通过实现Callable创建线程-可以对线程返回值处理\" class=\"headerlink\" title=\"通过实现Callable创建线程(可以对线程返回值处理)\"></a>通过实现Callable创建线程(可以对线程返回值处理)</h4><p>通过<code>FutureTask</code>包装一个<code>Callable</code>的实例，再通过<code>Thread</code>包装<code>FutureTask</code>的实例，然后调用<code>Thread</code>的<code>start()</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallableDemo</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"yo!\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callUse</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        CallableDemo callableDemo = <span class=\"keyword\">new</span> CallableDemo();</span><br><span class=\"line\">        System.out.println(callableDemo.call());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">threadUse</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">        FutureTask&lt;String&gt; futureTask= <span class=\"keyword\">new</span> FutureTask&lt;&gt;(<span class=\"keyword\">new</span> CallableDemo());</span><br><span class=\"line\">        Thread thread=<span class=\"keyword\">new</span> Thread(futureTask);</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        System.out.println(futureTask.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>FutureTask继承关系</p>\n<center><br><br><img src=\"https://cdn.guohezuzi.cn/public/img/futureTask.png\" width=\"70%\"><br><br></center>\n\n\n<h2 id=\"线程池执行线程\"><a href=\"#线程池执行线程\" class=\"headerlink\" title=\"线程池执行线程\"></a>线程池执行线程</h2><h4 id=\"线程池的创建\"><a href=\"#线程池的创建\" class=\"headerlink\" title=\"线程池的创建\"></a>线程池的创建</h4><p>一般通过ThreadPoolExecutor类来创建线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadPoolExecutor poolExecutor = <span class=\"keyword\">new</span> ThreadPoolExecutor(</span><br><span class=\"line\">                          <span class=\"keyword\">int</span> corePoolSize,</span><br><span class=\"line\">                          <span class=\"keyword\">int</span> maximumPoolSize,</span><br><span class=\"line\">                          <span class=\"keyword\">long</span> keepAliveTime,</span><br><span class=\"line\">                          TimeUnit unit,</span><br><span class=\"line\">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class=\"line\">                          ThreadFactory threadFactory,</span><br><span class=\"line\">                          RejectedExecutionHandler handler</span><br><span class=\"line\">                          )</span><br></pre></td></tr></table></figure>\n<h5 id=\"变量说明\"><a href=\"#变量说明\" class=\"headerlink\" title=\"变量说明\"></a>变量说明</h5><ul>\n<li><p>corePoolSize 线程池的基本大小</p>\n</li>\n<li><p>maximumPoolSize 线程池的最大大小</p>\n</li>\n<li><p>keepAliveTime 空闲线程(超出基本大小的线程)的存活时间</p>\n</li>\n<li><p>unit 空闲线程存活时间的单位(毫秒,秒…)</p>\n</li>\n<li><p>workQueue 任务队列，提交的任务的阻塞队列(<code>BlockingQueue</code>)。more: <a href=\"https://www.guohezuzi.cn/article/java-multhread-blockingqueue\" target=\"_blank\" rel=\"noopener\">Java多线程 - 阻塞队列详解</a></p>\n</li>\n<li><p>threadFactory 线程工产，线程的创建策略，有默认实现，可以通过定制线程工厂来监听线程信息 </p>\n</li>\n<li><p>handler 饱和策略，当线程由于任务队列满了，或者某个任务被提交到一个已被关闭的线程的处理方式</p>\n<ul>\n<li><p>AbortPolicy 中止策略，<strong>默认策略</strong> ，该策略会抛出RejectExecutionException异常，调用者可以根据这个异常编写自己的处理代码</p>\n</li>\n<li><p>DiscardRunsPolicy 抛弃策略，悄悄抛弃该任务，不抛异常</p>\n</li>\n<li><p>DiscardOldestPolicy 抛弃最久任务策略 将工作队列中最老的（也就是下一个要执行的）任务抛弃。<strong>优先队列将会是优先级最高的</strong></p>\n</li>\n<li><p>CallerRunsPolicy 调用者执行策略，将线程添加到添加工作队列的线程去执行</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>ps: 构造器参考下表</p>\n<h5 id=\"继承关系\"><a href=\"#继承关系\" class=\"headerlink\" title=\"继承关系\"></a>继承关系</h5><center><br><br><img src=\"https://cdn.guohezuzi.cn/public/img/thread.png\" width=\"70%\"><br><br></center>\n\n<h4 id=\"线程池的使用\"><a href=\"#线程池的使用\" class=\"headerlink\" title=\"线程池的使用\"></a>线程池的使用</h4><h5 id=\"Runable接口\"><a href=\"#Runable接口\" class=\"headerlink\" title=\"Runable接口\"></a>Runable接口</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class=\"line\">        ExecutorService pool=Executors.newFixedThreadPool(<span class=\"number\">2</span>);</span><br><span class=\"line\">        pool.execute(() -&gt; System.out.println(<span class=\"string\">\"yo!\"</span>));</span><br><span class=\"line\">        pool.shutdown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"Callable接口\"><a href=\"#Callable接口\" class=\"headerlink\" title=\"Callable接口\"></a>Callable接口</h5><p>通过调用submit方法</p>\n<p>在<code>ExecutorService</code>中提供了重载的<code>submit()</code>方法，该方法既可以接收<code>Runnable</code>实例又能接收<code>Callable</code>实例。对于实现<code>Callable</code>接口的类，需要覆写<code>call()</code>方法，并且只能通过<code>ExecutorService</code>的<code>submit()</code>方法来启动<code>call()</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class=\"line\">        ExecutorService pool=Executors.newFixedThreadPool(<span class=\"number\">2</span>);</span><br><span class=\"line\">        Future future=pool.submit(() -&gt; &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"yo!\"</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        System.out.println(future.get());</span><br><span class=\"line\">        pool.shutdown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"延时任务与周期任务的使用\"><a href=\"#延时任务与周期任务的使用\" class=\"headerlink\" title=\"延时任务与周期任务的使用\"></a>延时任务与周期任务的使用</h5><p>定义：延时任务(“在100ms后执行的任务”) 周期任务(“每10ms执行一次的任务”)</p>\n<p>使用：通过new ScheduledThreadPoolExector()对象</p>\n<center><br><br><img src=\"https://cdn.guohezuzi.cn/public/img/ScheduleExecutor.png\" width=\"80%\"><br><br></center>\n\n<p>Demo:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScheduleExecutorDemo</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScheduleExecutorDemo</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(name + <span class=\"string\">\" 运行\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        ScheduledExecutorService executorService1 = Executors.newScheduledThreadPool(<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"comment\">// after 10s run</span></span><br><span class=\"line\">        executorService1.schedule(<span class=\"keyword\">new</span> ScheduleExecutorDemo(<span class=\"string\">\"task1\"</span>), <span class=\"number\">10</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">        executorService1.shutdown();</span><br><span class=\"line\"></span><br><span class=\"line\">        ScheduledExecutorService executorService2 = Executors.newScheduledThreadPool(<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"comment\">// run per 1s</span></span><br><span class=\"line\">        executorService2.scheduleAtFixedRate(<span class=\"keyword\">new</span> ScheduleExecutorDemo(<span class=\"string\">\"task1\"</span>), </span><br><span class=\"line\">                <span class=\"number\">0</span>, <span class=\"number\">1</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">        <span class=\"comment\">// run per 2s</span></span><br><span class=\"line\">        executorService2.scheduleWithFixedDelay(<span class=\"keyword\">new</span> ScheduleExecutorDemo(<span class=\"string\">\"task2\"</span>), </span><br><span class=\"line\">                <span class=\"number\">0</span>, <span class=\"number\">2</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"使用tips\"><a href=\"#使用tips\" class=\"headerlink\" title=\"使用tips\"></a>使用tips</h5><p>来源：<a href=\"https://github.com/alibaba/p3c\" target=\"_blank\" rel=\"noopener\">阿里巴巴Java开发手册</a></p>\n<ul>\n<li><p>线程资源必须通过线程池提供,不允许在应用中自行显式创建线程。</p>\n<p>说明: 使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销,解决资源不足的问题。如果不使用线程池,有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p>\n</li>\n<li><p>线程池不允许使用 Executors 去创建,而是通过 ThreadPoolExecutor 的方式,这样的处理方式让写的同学更加明确线程池运行规则,规避资源耗尽的风险。</p>\n<p>说明: Executors 返回的线程池对象的弊端如下:</p>\n<ul>\n<li><p>FixedThreadPool 和 SingleThreadPool :允许的请求队列长度为 Integer.MAX_VALUE ,可能会堆积大量的请求,从而导致 OOM 。</p>\n</li>\n<li><p>CachedThreadPool 和 ScheduledThreadPool :允许的创建线程数量为 Integer.MAX_VALUE ,可能会创建大量的线程,从而导致 OOM 。</p>\n</li>\n</ul>\n</li>\n<li><p>多线程并行处理定时任务时, Timer 运行多个 TimeTask 时,只要其中之一没有捕获抛出的异常,其它任务便会自动终止运行,使用 ScheduledExecutorService 则没有这个问题。</p>\n</li>\n</ul>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref:\"></a>Ref:</h2><ol>\n<li><p>JDK1.8.0 源码</p>\n</li>\n<li><p><a href=\"http://codepub.cn/2016/02/01/Java-multi-thread-Callable-interface-and-thread-pool/\" target=\"_blank\" rel=\"noopener\">Java多线程之Callable接口及线程池</a></p>\n</li>\n<li><p><a href=\"https://book.douban.com/subject/10484692/\" target=\"_blank\" rel=\"noopener\">《Java并发编程实战》</a></p>\n</li>\n<li><p><a href=\"https://book.douban.com/subject/27034721/\" target=\"_blank\" rel=\"noopener\">《Java多线程编程实战指南(核心篇)》</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java多线程-线程的使用\"><a href=\"#Java多线程-线程的使用\" class=\"headerlink\" title=\"Java多线程 - 线程的使用\"></a>Java多线程 - 线程的使用</h1><h2 id=\"线程的创建\"><a href=\"#线程的创建\" class=\"headerlink\" title=\"线程的创建\"></a>线程的创建</h2><h4 id=\"通过实现Runnable接口\"><a href=\"#通过实现Runnable接口\" class=\"headerlink\" title=\"通过实现Runnable接口\"></a>通过实现Runnable接口</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RunnableDemo</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String threadName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">RunnableDemo</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.threadName = name;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"creating thread:\"</span> + threadName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Running \"</span> + threadName);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"Thread:\"</span> + threadName + <span class=\"string\">\",\"</span> + i);</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">50</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Thread \"</span> + threadName + <span class=\"string\">\"interrupter\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Thread \"</span> + threadName + <span class=\"string\">\" exiting\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// run</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        RunnableDemo r = <span class=\"keyword\">new</span> RunnableDemo(<span class=\"string\">\"MyThread\"</span>);</span><br><span class=\"line\">        r.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"通过继承Thread类本身\"><a href=\"#通过继承Thread类本身\" class=\"headerlink\" title=\"通过继承Thread类本身\"></a>通过继承Thread类本身</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThreadDemo</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"thread\"</span> + Thread.currentThread().getId() + <span class=\"string\">\" running...\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// run 10 thread</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        ThreadDemo[] threadDemos = <span class=\"keyword\">new</span> ThreadDemo[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; threadDemos.length; i++) &#123;</span><br><span class=\"line\">            threadDemos[i] = <span class=\"keyword\">new</span> ThreadDemo();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ThreadDemo threadDemo : threadDemos) &#123;</span><br><span class=\"line\">            threadDemo.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// wait other thread complete</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ThreadDemo threadDemo : threadDemos) &#123;</span><br><span class=\"line\">            threadDemo.join();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"completing\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"通过实现Callable创建线程-可以对线程返回值处理\"><a href=\"#通过实现Callable创建线程-可以对线程返回值处理\" class=\"headerlink\" title=\"通过实现Callable创建线程(可以对线程返回值处理)\"></a>通过实现Callable创建线程(可以对线程返回值处理)</h4><p>通过<code>FutureTask</code>包装一个<code>Callable</code>的实例，再通过<code>Thread</code>包装<code>FutureTask</code>的实例，然后调用<code>Thread</code>的<code>start()</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallableDemo</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"yo!\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">callUse</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        CallableDemo callableDemo = <span class=\"keyword\">new</span> CallableDemo();</span><br><span class=\"line\">        System.out.println(callableDemo.call());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">threadUse</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">        FutureTask&lt;String&gt; futureTask= <span class=\"keyword\">new</span> FutureTask&lt;&gt;(<span class=\"keyword\">new</span> CallableDemo());</span><br><span class=\"line\">        Thread thread=<span class=\"keyword\">new</span> Thread(futureTask);</span><br><span class=\"line\">        thread.start();</span><br><span class=\"line\">        System.out.println(futureTask.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>FutureTask继承关系</p>\n<center><br><br><img src=\"https://cdn.guohezuzi.cn/public/img/futureTask.png\" width=\"70%\"><br><br></center>\n\n\n<h2 id=\"线程池执行线程\"><a href=\"#线程池执行线程\" class=\"headerlink\" title=\"线程池执行线程\"></a>线程池执行线程</h2><h4 id=\"线程池的创建\"><a href=\"#线程池的创建\" class=\"headerlink\" title=\"线程池的创建\"></a>线程池的创建</h4><p>一般通过ThreadPoolExecutor类来创建线程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ThreadPoolExecutor poolExecutor = <span class=\"keyword\">new</span> ThreadPoolExecutor(</span><br><span class=\"line\">                          <span class=\"keyword\">int</span> corePoolSize,</span><br><span class=\"line\">                          <span class=\"keyword\">int</span> maximumPoolSize,</span><br><span class=\"line\">                          <span class=\"keyword\">long</span> keepAliveTime,</span><br><span class=\"line\">                          TimeUnit unit,</span><br><span class=\"line\">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class=\"line\">                          ThreadFactory threadFactory,</span><br><span class=\"line\">                          RejectedExecutionHandler handler</span><br><span class=\"line\">                          )</span><br></pre></td></tr></table></figure>\n<h5 id=\"变量说明\"><a href=\"#变量说明\" class=\"headerlink\" title=\"变量说明\"></a>变量说明</h5><ul>\n<li><p>corePoolSize 线程池的基本大小</p>\n</li>\n<li><p>maximumPoolSize 线程池的最大大小</p>\n</li>\n<li><p>keepAliveTime 空闲线程(超出基本大小的线程)的存活时间</p>\n</li>\n<li><p>unit 空闲线程存活时间的单位(毫秒,秒…)</p>\n</li>\n<li><p>workQueue 任务队列，提交的任务的阻塞队列(<code>BlockingQueue</code>)。more: <a href=\"https://www.guohezuzi.cn/article/java-multhread-blockingqueue\" target=\"_blank\" rel=\"noopener\">Java多线程 - 阻塞队列详解</a></p>\n</li>\n<li><p>threadFactory 线程工产，线程的创建策略，有默认实现，可以通过定制线程工厂来监听线程信息 </p>\n</li>\n<li><p>handler 饱和策略，当线程由于任务队列满了，或者某个任务被提交到一个已被关闭的线程的处理方式</p>\n<ul>\n<li><p>AbortPolicy 中止策略，<strong>默认策略</strong> ，该策略会抛出RejectExecutionException异常，调用者可以根据这个异常编写自己的处理代码</p>\n</li>\n<li><p>DiscardRunsPolicy 抛弃策略，悄悄抛弃该任务，不抛异常</p>\n</li>\n<li><p>DiscardOldestPolicy 抛弃最久任务策略 将工作队列中最老的（也就是下一个要执行的）任务抛弃。<strong>优先队列将会是优先级最高的</strong></p>\n</li>\n<li><p>CallerRunsPolicy 调用者执行策略，将线程添加到添加工作队列的线程去执行</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>ps: 构造器参考下表</p>\n<h5 id=\"继承关系\"><a href=\"#继承关系\" class=\"headerlink\" title=\"继承关系\"></a>继承关系</h5><center><br><br><img src=\"https://cdn.guohezuzi.cn/public/img/thread.png\" width=\"70%\"><br><br></center>\n\n<h4 id=\"线程池的使用\"><a href=\"#线程池的使用\" class=\"headerlink\" title=\"线程池的使用\"></a>线程池的使用</h4><h5 id=\"Runable接口\"><a href=\"#Runable接口\" class=\"headerlink\" title=\"Runable接口\"></a>Runable接口</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class=\"line\">        ExecutorService pool=Executors.newFixedThreadPool(<span class=\"number\">2</span>);</span><br><span class=\"line\">        pool.execute(() -&gt; System.out.println(<span class=\"string\">\"yo!\"</span>));</span><br><span class=\"line\">        pool.shutdown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"Callable接口\"><a href=\"#Callable接口\" class=\"headerlink\" title=\"Callable接口\"></a>Callable接口</h5><p>通过调用submit方法</p>\n<p>在<code>ExecutorService</code>中提供了重载的<code>submit()</code>方法，该方法既可以接收<code>Runnable</code>实例又能接收<code>Callable</code>实例。对于实现<code>Callable</code>接口的类，需要覆写<code>call()</code>方法，并且只能通过<code>ExecutorService</code>的<code>submit()</code>方法来启动<code>call()</code>方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class=\"line\">        ExecutorService pool=Executors.newFixedThreadPool(<span class=\"number\">2</span>);</span><br><span class=\"line\">        Future future=pool.submit(() -&gt; &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">100</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"yo!\"</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        System.out.println(future.get());</span><br><span class=\"line\">        pool.shutdown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"延时任务与周期任务的使用\"><a href=\"#延时任务与周期任务的使用\" class=\"headerlink\" title=\"延时任务与周期任务的使用\"></a>延时任务与周期任务的使用</h5><p>定义：延时任务(“在100ms后执行的任务”) 周期任务(“每10ms执行一次的任务”)</p>\n<p>使用：通过new ScheduledThreadPoolExector()对象</p>\n<center><br><br><img src=\"https://cdn.guohezuzi.cn/public/img/ScheduleExecutor.png\" width=\"80%\"><br><br></center>\n\n<p>Demo:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScheduleExecutorDemo</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScheduleExecutorDemo</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(name + <span class=\"string\">\" 运行\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        ScheduledExecutorService executorService1 = Executors.newScheduledThreadPool(<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"comment\">// after 10s run</span></span><br><span class=\"line\">        executorService1.schedule(<span class=\"keyword\">new</span> ScheduleExecutorDemo(<span class=\"string\">\"task1\"</span>), <span class=\"number\">10</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">        executorService1.shutdown();</span><br><span class=\"line\"></span><br><span class=\"line\">        ScheduledExecutorService executorService2 = Executors.newScheduledThreadPool(<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"comment\">// run per 1s</span></span><br><span class=\"line\">        executorService2.scheduleAtFixedRate(<span class=\"keyword\">new</span> ScheduleExecutorDemo(<span class=\"string\">\"task1\"</span>), </span><br><span class=\"line\">                <span class=\"number\">0</span>, <span class=\"number\">1</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">        <span class=\"comment\">// run per 2s</span></span><br><span class=\"line\">        executorService2.scheduleWithFixedDelay(<span class=\"keyword\">new</span> ScheduleExecutorDemo(<span class=\"string\">\"task2\"</span>), </span><br><span class=\"line\">                <span class=\"number\">0</span>, <span class=\"number\">2</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"使用tips\"><a href=\"#使用tips\" class=\"headerlink\" title=\"使用tips\"></a>使用tips</h5><p>来源：<a href=\"https://github.com/alibaba/p3c\" target=\"_blank\" rel=\"noopener\">阿里巴巴Java开发手册</a></p>\n<ul>\n<li><p>线程资源必须通过线程池提供,不允许在应用中自行显式创建线程。</p>\n<p>说明: 使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销,解决资源不足的问题。如果不使用线程池,有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p>\n</li>\n<li><p>线程池不允许使用 Executors 去创建,而是通过 ThreadPoolExecutor 的方式,这样的处理方式让写的同学更加明确线程池运行规则,规避资源耗尽的风险。</p>\n<p>说明: Executors 返回的线程池对象的弊端如下:</p>\n<ul>\n<li><p>FixedThreadPool 和 SingleThreadPool :允许的请求队列长度为 Integer.MAX_VALUE ,可能会堆积大量的请求,从而导致 OOM 。</p>\n</li>\n<li><p>CachedThreadPool 和 ScheduledThreadPool :允许的创建线程数量为 Integer.MAX_VALUE ,可能会创建大量的线程,从而导致 OOM 。</p>\n</li>\n</ul>\n</li>\n<li><p>多线程并行处理定时任务时, Timer 运行多个 TimeTask 时,只要其中之一没有捕获抛出的异常,其它任务便会自动终止运行,使用 ScheduledExecutorService 则没有这个问题。</p>\n</li>\n</ul>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref:\"></a>Ref:</h2><ol>\n<li><p>JDK1.8.0 源码</p>\n</li>\n<li><p><a href=\"http://codepub.cn/2016/02/01/Java-multi-thread-Callable-interface-and-thread-pool/\" target=\"_blank\" rel=\"noopener\">Java多线程之Callable接口及线程池</a></p>\n</li>\n<li><p><a href=\"https://book.douban.com/subject/10484692/\" target=\"_blank\" rel=\"noopener\">《Java并发编程实战》</a></p>\n</li>\n<li><p><a href=\"https://book.douban.com/subject/27034721/\" target=\"_blank\" rel=\"noopener\">《Java多线程编程实战指南(核心篇)》</a></p>\n</li>\n</ol>\n"},{"title":"Java多线程 - 阻塞队列详解","date":"2019-06-12T09:19:04.000Z","_content":"\n# Java多线程 - 阻塞队列详解\n\n## 定义\n\n- 队列：其中的元素先进先出\n\n- 阻塞：写入队列空间时当队列满会阻塞，获取队列数据时当队列为空时将阻塞。\n\n- 实际情况：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。\n\n### 阻塞队列的继承关系\n\n<center>\n\n<img src=\"https://cdn.guohezuzi.cn/public/img/blockingqueue.png\" width=\"100%\" />\n\n</center>\n\n- ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。\n\n- LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。\n\n- PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。\n\n- DelayQueue：一个使用优先级队列实现的无界阻塞队列。\n\n- SynchronousQueue：一个不存储元素的阻塞队列。\n\n- LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。\n\n- LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。\n\n## 常用方法\n\n<center>\n\n<img src=\"https://cdn.guohezuzi.cn/public/img/blockingqueueMethod.png\" width=\"70%\" />\n\n</center>\n\n#### 详解\n\n- add(e) / remove(o) : 阻塞时抛异常，向队列中添加/移除一个指定元素，add操作当队列空间满了，会抛出IllegalStateException异常，当队列空间有限制时，**建议使用offer方法**；remove():向队列移除头部元素，当无元素时，抛出NoSuchElementException 异常(接口Queue的方法)\n\n- offer(e) / poll() :阻塞时返回值， 向队列中添加/取出一个元素，offer操作当队列空间满了，返回false；poll操作，将队列头部元素取出，无元素返回null\n\n- put(e)/take: 阻塞时等待，向队列中添加/删除一个元素，put操作队列满了，进行阻塞等待；take操作队列为空，同样进行阻塞等待。\n\n## 使用Demo\n\n模拟阻塞队列在多线程中使用，主线程中添加元素，另起一个线程消费队列，同时另一个线程打印队列的长度(检测阻塞队列)\n\n```java\npublic class BlockingQueueDemo {\n    // 在主线程向阻塞队列中添加任务，同时开启一个线程消费队列和另一个线程打印队列的长度\n    public static void main(String[] args) throws InterruptedException {\n        BlockingQueue<Runnable> blockingQueue = new ArrayBlockingQueue<>(4);\n        blockingQueue.put(new BlockingQueueRunnable(\"run-1\"));\n        blockingQueue.put(new BlockingQueueRunnable(\"run-2\"));\n        blockingQueue.put(new BlockingQueueRunnable(\"run-3\"));\n        blockingQueue.put(new BlockingQueueRunnable(\"run-4\"));\n        ResumeBlockingQueueThread blockingQueueThread = new ResumeBlockingQueueThread(blockingQueue);\n        blockingQueueThread.start();\n        GetBlockingQueueSize getBlockingQueueSize = new GetBlockingQueueSize(blockingQueue);\n        getBlockingQueueSize.start();\n\n        blockingQueue.put(new BlockingQueueRunnable(\"run-5\"));\n        blockingQueue.put(new BlockingQueueRunnable(\"run-6\"));\n        blockingQueue.put(new BlockingQueueRunnable(\"run-7\"));\n        blockingQueue.put(new BlockingQueueRunnable(\"run-8\"));\n        blockingQueue.put(new BlockingQueueRunnable(\"run-9\"));\n        blockingQueue.put(new BlockingQueueRunnable(\"run-10\"));\n    }\n\n    // 阻塞队列中的线程\n    private static class BlockingQueueRunnable implements Runnable {\n        public BlockingQueueRunnable(String name) {\n            this.name = name;\n        }\n        private String name;\n\n        @Override\n        public void run() {\n            System.out.println(\"thread\" + name + \": run\");\n        }\n    }\n\n    // 每隔1s消费阻塞队列的元素个数 10次\n    private static class ResumeBlockingQueueThread extends Thread {\n        BlockingQueue<Runnable> blockingQueue;\n\n        public ResumeBlockingQueueThread(BlockingQueue<Runnable> blockingQueue) {\n            this.blockingQueue = blockingQueue;\n        }\n\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    //sleep 1s\n                    Thread.sleep(2000);\n                    blockingQueue.take().run();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    // 每隔2s打印阻塞队列的元素个数 10次\n    private static class GetBlockingQueueSize extends Thread {\n        BlockingQueue<Runnable> blockingQueue;\n\n        public GetBlockingQueueSize(BlockingQueue<Runnable> blockingQueue) {\n            this.blockingQueue = blockingQueue;\n        }\n\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"阻塞队列的长度为:\"+blockingQueue.size());\n            }\n        }\n    }\n}\n```\n\n## 使用原理\n\n以ArrayBlockingQueue为例，\n\n需要阻塞时，通过使用Condition类，通过Condition类的await方法进行线程的阻塞。Condition类可参考:[Java多线程 - AQS详解](https://www.guohezuzi.cn/article/java-multithread-aqs#condition)\n\n不需要阻塞时，通过循环数组实现的队列入队/出队\n\n## Ref:\n\n1. JDK8源码\n\n2. [InfoQ 聊聊并发（七）——Java 中的阻塞队列](https://www.infoq.cn/article/java-blocking-queue)\n\n3. [一个自己实现的阻塞队列](https://crossoverjie.top/JCSprout/#/thread/ArrayBlockingQueue)\n","source":"_posts/多线程/Java多线程-阻塞队列详解.md","raw":"---\ntitle: Java多线程 - 阻塞队列详解\ndate: 2019-06-12 17:19:04\ntags:\n---\n\n# Java多线程 - 阻塞队列详解\n\n## 定义\n\n- 队列：其中的元素先进先出\n\n- 阻塞：写入队列空间时当队列满会阻塞，获取队列数据时当队列为空时将阻塞。\n\n- 实际情况：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。\n\n### 阻塞队列的继承关系\n\n<center>\n\n<img src=\"https://cdn.guohezuzi.cn/public/img/blockingqueue.png\" width=\"100%\" />\n\n</center>\n\n- ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。\n\n- LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。\n\n- PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。\n\n- DelayQueue：一个使用优先级队列实现的无界阻塞队列。\n\n- SynchronousQueue：一个不存储元素的阻塞队列。\n\n- LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。\n\n- LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。\n\n## 常用方法\n\n<center>\n\n<img src=\"https://cdn.guohezuzi.cn/public/img/blockingqueueMethod.png\" width=\"70%\" />\n\n</center>\n\n#### 详解\n\n- add(e) / remove(o) : 阻塞时抛异常，向队列中添加/移除一个指定元素，add操作当队列空间满了，会抛出IllegalStateException异常，当队列空间有限制时，**建议使用offer方法**；remove():向队列移除头部元素，当无元素时，抛出NoSuchElementException 异常(接口Queue的方法)\n\n- offer(e) / poll() :阻塞时返回值， 向队列中添加/取出一个元素，offer操作当队列空间满了，返回false；poll操作，将队列头部元素取出，无元素返回null\n\n- put(e)/take: 阻塞时等待，向队列中添加/删除一个元素，put操作队列满了，进行阻塞等待；take操作队列为空，同样进行阻塞等待。\n\n## 使用Demo\n\n模拟阻塞队列在多线程中使用，主线程中添加元素，另起一个线程消费队列，同时另一个线程打印队列的长度(检测阻塞队列)\n\n```java\npublic class BlockingQueueDemo {\n    // 在主线程向阻塞队列中添加任务，同时开启一个线程消费队列和另一个线程打印队列的长度\n    public static void main(String[] args) throws InterruptedException {\n        BlockingQueue<Runnable> blockingQueue = new ArrayBlockingQueue<>(4);\n        blockingQueue.put(new BlockingQueueRunnable(\"run-1\"));\n        blockingQueue.put(new BlockingQueueRunnable(\"run-2\"));\n        blockingQueue.put(new BlockingQueueRunnable(\"run-3\"));\n        blockingQueue.put(new BlockingQueueRunnable(\"run-4\"));\n        ResumeBlockingQueueThread blockingQueueThread = new ResumeBlockingQueueThread(blockingQueue);\n        blockingQueueThread.start();\n        GetBlockingQueueSize getBlockingQueueSize = new GetBlockingQueueSize(blockingQueue);\n        getBlockingQueueSize.start();\n\n        blockingQueue.put(new BlockingQueueRunnable(\"run-5\"));\n        blockingQueue.put(new BlockingQueueRunnable(\"run-6\"));\n        blockingQueue.put(new BlockingQueueRunnable(\"run-7\"));\n        blockingQueue.put(new BlockingQueueRunnable(\"run-8\"));\n        blockingQueue.put(new BlockingQueueRunnable(\"run-9\"));\n        blockingQueue.put(new BlockingQueueRunnable(\"run-10\"));\n    }\n\n    // 阻塞队列中的线程\n    private static class BlockingQueueRunnable implements Runnable {\n        public BlockingQueueRunnable(String name) {\n            this.name = name;\n        }\n        private String name;\n\n        @Override\n        public void run() {\n            System.out.println(\"thread\" + name + \": run\");\n        }\n    }\n\n    // 每隔1s消费阻塞队列的元素个数 10次\n    private static class ResumeBlockingQueueThread extends Thread {\n        BlockingQueue<Runnable> blockingQueue;\n\n        public ResumeBlockingQueueThread(BlockingQueue<Runnable> blockingQueue) {\n            this.blockingQueue = blockingQueue;\n        }\n\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    //sleep 1s\n                    Thread.sleep(2000);\n                    blockingQueue.take().run();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    // 每隔2s打印阻塞队列的元素个数 10次\n    private static class GetBlockingQueueSize extends Thread {\n        BlockingQueue<Runnable> blockingQueue;\n\n        public GetBlockingQueueSize(BlockingQueue<Runnable> blockingQueue) {\n            this.blockingQueue = blockingQueue;\n        }\n\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"阻塞队列的长度为:\"+blockingQueue.size());\n            }\n        }\n    }\n}\n```\n\n## 使用原理\n\n以ArrayBlockingQueue为例，\n\n需要阻塞时，通过使用Condition类，通过Condition类的await方法进行线程的阻塞。Condition类可参考:[Java多线程 - AQS详解](https://www.guohezuzi.cn/article/java-multithread-aqs#condition)\n\n不需要阻塞时，通过循环数组实现的队列入队/出队\n\n## Ref:\n\n1. JDK8源码\n\n2. [InfoQ 聊聊并发（七）——Java 中的阻塞队列](https://www.infoq.cn/article/java-blocking-queue)\n\n3. [一个自己实现的阻塞队列](https://crossoverjie.top/JCSprout/#/thread/ArrayBlockingQueue)\n","slug":"多线程/Java多线程-阻塞队列详解","published":1,"updated":"2019-11-13T10:09:11.271Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2x4ppxv000z1w2ebt30dt4t","content":"<h1 id=\"Java多线程-阻塞队列详解\"><a href=\"#Java多线程-阻塞队列详解\" class=\"headerlink\" title=\"Java多线程 - 阻塞队列详解\"></a>Java多线程 - 阻塞队列详解</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><ul>\n<li><p>队列：其中的元素先进先出</p>\n</li>\n<li><p>阻塞：写入队列空间时当队列满会阻塞，获取队列数据时当队列为空时将阻塞。</p>\n</li>\n<li><p>实际情况：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p>\n</li>\n</ul>\n<h3 id=\"阻塞队列的继承关系\"><a href=\"#阻塞队列的继承关系\" class=\"headerlink\" title=\"阻塞队列的继承关系\"></a>阻塞队列的继承关系</h3><center><br><br><img src=\"https://cdn.guohezuzi.cn/public/img/blockingqueue.png\" width=\"100%\"><br><br></center>\n\n<ul>\n<li><p>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</p>\n</li>\n<li><p>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</p>\n</li>\n<li><p>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</p>\n</li>\n<li><p>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</p>\n</li>\n<li><p>SynchronousQueue：一个不存储元素的阻塞队列。</p>\n</li>\n<li><p>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</p>\n</li>\n<li><p>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p>\n</li>\n</ul>\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><center><br><br><img src=\"https://cdn.guohezuzi.cn/public/img/blockingqueueMethod.png\" width=\"70%\"><br><br></center>\n\n<h4 id=\"详解\"><a href=\"#详解\" class=\"headerlink\" title=\"详解\"></a>详解</h4><ul>\n<li><p>add(e) / remove(o) : 阻塞时抛异常，向队列中添加/移除一个指定元素，add操作当队列空间满了，会抛出IllegalStateException异常，当队列空间有限制时，<strong>建议使用offer方法</strong>；remove():向队列移除头部元素，当无元素时，抛出NoSuchElementException 异常(接口Queue的方法)</p>\n</li>\n<li><p>offer(e) / poll() :阻塞时返回值， 向队列中添加/取出一个元素，offer操作当队列空间满了，返回false；poll操作，将队列头部元素取出，无元素返回null</p>\n</li>\n<li><p>put(e)/take: 阻塞时等待，向队列中添加/删除一个元素，put操作队列满了，进行阻塞等待；take操作队列为空，同样进行阻塞等待。</p>\n</li>\n</ul>\n<h2 id=\"使用Demo\"><a href=\"#使用Demo\" class=\"headerlink\" title=\"使用Demo\"></a>使用Demo</h2><p>模拟阻塞队列在多线程中使用，主线程中添加元素，另起一个线程消费队列，同时另一个线程打印队列的长度(检测阻塞队列)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlockingQueueDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在主线程向阻塞队列中添加任务，同时开启一个线程消费队列和另一个线程打印队列的长度</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        BlockingQueue&lt;Runnable&gt; blockingQueue = <span class=\"keyword\">new</span> ArrayBlockingQueue&lt;&gt;(<span class=\"number\">4</span>);</span><br><span class=\"line\">        blockingQueue.put(<span class=\"keyword\">new</span> BlockingQueueRunnable(<span class=\"string\">\"run-1\"</span>));</span><br><span class=\"line\">        blockingQueue.put(<span class=\"keyword\">new</span> BlockingQueueRunnable(<span class=\"string\">\"run-2\"</span>));</span><br><span class=\"line\">        blockingQueue.put(<span class=\"keyword\">new</span> BlockingQueueRunnable(<span class=\"string\">\"run-3\"</span>));</span><br><span class=\"line\">        blockingQueue.put(<span class=\"keyword\">new</span> BlockingQueueRunnable(<span class=\"string\">\"run-4\"</span>));</span><br><span class=\"line\">        ResumeBlockingQueueThread blockingQueueThread = <span class=\"keyword\">new</span> ResumeBlockingQueueThread(blockingQueue);</span><br><span class=\"line\">        blockingQueueThread.start();</span><br><span class=\"line\">        GetBlockingQueueSize getBlockingQueueSize = <span class=\"keyword\">new</span> GetBlockingQueueSize(blockingQueue);</span><br><span class=\"line\">        getBlockingQueueSize.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        blockingQueue.put(<span class=\"keyword\">new</span> BlockingQueueRunnable(<span class=\"string\">\"run-5\"</span>));</span><br><span class=\"line\">        blockingQueue.put(<span class=\"keyword\">new</span> BlockingQueueRunnable(<span class=\"string\">\"run-6\"</span>));</span><br><span class=\"line\">        blockingQueue.put(<span class=\"keyword\">new</span> BlockingQueueRunnable(<span class=\"string\">\"run-7\"</span>));</span><br><span class=\"line\">        blockingQueue.put(<span class=\"keyword\">new</span> BlockingQueueRunnable(<span class=\"string\">\"run-8\"</span>));</span><br><span class=\"line\">        blockingQueue.put(<span class=\"keyword\">new</span> BlockingQueueRunnable(<span class=\"string\">\"run-9\"</span>));</span><br><span class=\"line\">        blockingQueue.put(<span class=\"keyword\">new</span> BlockingQueueRunnable(<span class=\"string\">\"run-10\"</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞队列中的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlockingQueueRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BlockingQueueRunnable</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"thread\"</span> + name + <span class=\"string\">\": run\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 每隔1s消费阻塞队列的元素个数 10次</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResumeBlockingQueueThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">        BlockingQueue&lt;Runnable&gt; blockingQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ResumeBlockingQueueThread</span><span class=\"params\">(BlockingQueue&lt;Runnable&gt; blockingQueue)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.blockingQueue = blockingQueue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//sleep 1s</span></span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">                    blockingQueue.take().run();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 每隔2s打印阻塞队列的元素个数 10次</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GetBlockingQueueSize</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">        BlockingQueue&lt;Runnable&gt; blockingQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GetBlockingQueueSize</span><span class=\"params\">(BlockingQueue&lt;Runnable&gt; blockingQueue)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.blockingQueue = blockingQueue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"阻塞队列的长度为:\"</span>+blockingQueue.size());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用原理\"><a href=\"#使用原理\" class=\"headerlink\" title=\"使用原理\"></a>使用原理</h2><p>以ArrayBlockingQueue为例，</p>\n<p>需要阻塞时，通过使用Condition类，通过Condition类的await方法进行线程的阻塞。Condition类可参考:<a href=\"https://www.guohezuzi.cn/article/java-multithread-aqs#condition\" target=\"_blank\" rel=\"noopener\">Java多线程 - AQS详解</a></p>\n<p>不需要阻塞时，通过循环数组实现的队列入队/出队</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref:\"></a>Ref:</h2><ol>\n<li><p>JDK8源码</p>\n</li>\n<li><p><a href=\"https://www.infoq.cn/article/java-blocking-queue\" target=\"_blank\" rel=\"noopener\">InfoQ 聊聊并发（七）——Java 中的阻塞队列</a></p>\n</li>\n<li><p><a href=\"https://crossoverjie.top/JCSprout/#/thread/ArrayBlockingQueue\" target=\"_blank\" rel=\"noopener\">一个自己实现的阻塞队列</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java多线程-阻塞队列详解\"><a href=\"#Java多线程-阻塞队列详解\" class=\"headerlink\" title=\"Java多线程 - 阻塞队列详解\"></a>Java多线程 - 阻塞队列详解</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><ul>\n<li><p>队列：其中的元素先进先出</p>\n</li>\n<li><p>阻塞：写入队列空间时当队列满会阻塞，获取队列数据时当队列为空时将阻塞。</p>\n</li>\n<li><p>实际情况：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</p>\n</li>\n</ul>\n<h3 id=\"阻塞队列的继承关系\"><a href=\"#阻塞队列的继承关系\" class=\"headerlink\" title=\"阻塞队列的继承关系\"></a>阻塞队列的继承关系</h3><center><br><br><img src=\"https://cdn.guohezuzi.cn/public/img/blockingqueue.png\" width=\"100%\"><br><br></center>\n\n<ul>\n<li><p>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。</p>\n</li>\n<li><p>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列。</p>\n</li>\n<li><p>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</p>\n</li>\n<li><p>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</p>\n</li>\n<li><p>SynchronousQueue：一个不存储元素的阻塞队列。</p>\n</li>\n<li><p>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</p>\n</li>\n<li><p>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p>\n</li>\n</ul>\n<h2 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h2><center><br><br><img src=\"https://cdn.guohezuzi.cn/public/img/blockingqueueMethod.png\" width=\"70%\"><br><br></center>\n\n<h4 id=\"详解\"><a href=\"#详解\" class=\"headerlink\" title=\"详解\"></a>详解</h4><ul>\n<li><p>add(e) / remove(o) : 阻塞时抛异常，向队列中添加/移除一个指定元素，add操作当队列空间满了，会抛出IllegalStateException异常，当队列空间有限制时，<strong>建议使用offer方法</strong>；remove():向队列移除头部元素，当无元素时，抛出NoSuchElementException 异常(接口Queue的方法)</p>\n</li>\n<li><p>offer(e) / poll() :阻塞时返回值， 向队列中添加/取出一个元素，offer操作当队列空间满了，返回false；poll操作，将队列头部元素取出，无元素返回null</p>\n</li>\n<li><p>put(e)/take: 阻塞时等待，向队列中添加/删除一个元素，put操作队列满了，进行阻塞等待；take操作队列为空，同样进行阻塞等待。</p>\n</li>\n</ul>\n<h2 id=\"使用Demo\"><a href=\"#使用Demo\" class=\"headerlink\" title=\"使用Demo\"></a>使用Demo</h2><p>模拟阻塞队列在多线程中使用，主线程中添加元素，另起一个线程消费队列，同时另一个线程打印队列的长度(检测阻塞队列)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlockingQueueDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在主线程向阻塞队列中添加任务，同时开启一个线程消费队列和另一个线程打印队列的长度</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        BlockingQueue&lt;Runnable&gt; blockingQueue = <span class=\"keyword\">new</span> ArrayBlockingQueue&lt;&gt;(<span class=\"number\">4</span>);</span><br><span class=\"line\">        blockingQueue.put(<span class=\"keyword\">new</span> BlockingQueueRunnable(<span class=\"string\">\"run-1\"</span>));</span><br><span class=\"line\">        blockingQueue.put(<span class=\"keyword\">new</span> BlockingQueueRunnable(<span class=\"string\">\"run-2\"</span>));</span><br><span class=\"line\">        blockingQueue.put(<span class=\"keyword\">new</span> BlockingQueueRunnable(<span class=\"string\">\"run-3\"</span>));</span><br><span class=\"line\">        blockingQueue.put(<span class=\"keyword\">new</span> BlockingQueueRunnable(<span class=\"string\">\"run-4\"</span>));</span><br><span class=\"line\">        ResumeBlockingQueueThread blockingQueueThread = <span class=\"keyword\">new</span> ResumeBlockingQueueThread(blockingQueue);</span><br><span class=\"line\">        blockingQueueThread.start();</span><br><span class=\"line\">        GetBlockingQueueSize getBlockingQueueSize = <span class=\"keyword\">new</span> GetBlockingQueueSize(blockingQueue);</span><br><span class=\"line\">        getBlockingQueueSize.start();</span><br><span class=\"line\"></span><br><span class=\"line\">        blockingQueue.put(<span class=\"keyword\">new</span> BlockingQueueRunnable(<span class=\"string\">\"run-5\"</span>));</span><br><span class=\"line\">        blockingQueue.put(<span class=\"keyword\">new</span> BlockingQueueRunnable(<span class=\"string\">\"run-6\"</span>));</span><br><span class=\"line\">        blockingQueue.put(<span class=\"keyword\">new</span> BlockingQueueRunnable(<span class=\"string\">\"run-7\"</span>));</span><br><span class=\"line\">        blockingQueue.put(<span class=\"keyword\">new</span> BlockingQueueRunnable(<span class=\"string\">\"run-8\"</span>));</span><br><span class=\"line\">        blockingQueue.put(<span class=\"keyword\">new</span> BlockingQueueRunnable(<span class=\"string\">\"run-9\"</span>));</span><br><span class=\"line\">        blockingQueue.put(<span class=\"keyword\">new</span> BlockingQueueRunnable(<span class=\"string\">\"run-10\"</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 阻塞队列中的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlockingQueueRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BlockingQueueRunnable</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"thread\"</span> + name + <span class=\"string\">\": run\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 每隔1s消费阻塞队列的元素个数 10次</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResumeBlockingQueueThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">        BlockingQueue&lt;Runnable&gt; blockingQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ResumeBlockingQueueThread</span><span class=\"params\">(BlockingQueue&lt;Runnable&gt; blockingQueue)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.blockingQueue = blockingQueue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//sleep 1s</span></span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">                    blockingQueue.take().run();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 每隔2s打印阻塞队列的元素个数 10次</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GetBlockingQueueSize</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">        BlockingQueue&lt;Runnable&gt; blockingQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">GetBlockingQueueSize</span><span class=\"params\">(BlockingQueue&lt;Runnable&gt; blockingQueue)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.blockingQueue = blockingQueue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"阻塞队列的长度为:\"</span>+blockingQueue.size());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用原理\"><a href=\"#使用原理\" class=\"headerlink\" title=\"使用原理\"></a>使用原理</h2><p>以ArrayBlockingQueue为例，</p>\n<p>需要阻塞时，通过使用Condition类，通过Condition类的await方法进行线程的阻塞。Condition类可参考:<a href=\"https://www.guohezuzi.cn/article/java-multithread-aqs#condition\" target=\"_blank\" rel=\"noopener\">Java多线程 - AQS详解</a></p>\n<p>不需要阻塞时，通过循环数组实现的队列入队/出队</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref:\"></a>Ref:</h2><ol>\n<li><p>JDK8源码</p>\n</li>\n<li><p><a href=\"https://www.infoq.cn/article/java-blocking-queue\" target=\"_blank\" rel=\"noopener\">InfoQ 聊聊并发（七）——Java 中的阻塞队列</a></p>\n</li>\n<li><p><a href=\"https://crossoverjie.top/JCSprout/#/thread/ArrayBlockingQueue\" target=\"_blank\" rel=\"noopener\">一个自己实现的阻塞队列</a></p>\n</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}